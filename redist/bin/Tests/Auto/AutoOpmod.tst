;PROCEDURALLY GENERATED FILE

;Any modifications will be overwritten!
;Generated by the QuicheTestGen utility

$overflow on
code auto:2 mod[Integer] -128[Int8], -128[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3 mod[compile-time] -128[Int8], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -128;
endcode
varvalue r 0

$overflow on
code auto:4 mod[Integer] -128[Int8], -127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:5 mod[compile-time] -128[Int8], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -127;
endcode
varvalue r -1

$overflow on
code auto:6 mod[Integer] -128[Int8], -1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:7 mod[compile-time] -128[Int8], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -1;
endcode
varvalue r 0

$overflow on
code auto:8 mod[Integer] -128[Int8], 0[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:9 mod[compile-time] -128[Int8], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:10 mod[Integer] -128[Int8], 1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:11 mod[compile-time] -128[Int8], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:12 mod[Integer] -128[Int8], 127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:13 mod[compile-time] -128[Int8], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 127;
endcode
varvalue r -1

$overflow on
code auto:14 mod[Integer] -127[Int8], -128[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:15 mod[compile-time] -127[Int8], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod -128;
endcode
varvalue r -127

$overflow on
code auto:16 mod[Integer] -127[Int8], -127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:17 mod[compile-time] -127[Int8], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod -127;
endcode
varvalue r 0

$overflow on
code auto:18 mod[Integer] -127[Int8], -1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:19 mod[compile-time] -127[Int8], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod -1;
endcode
varvalue r 0

$overflow on
code auto:20 mod[Integer] -127[Int8], 0[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:21 mod[compile-time] -127[Int8], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 0;
endcode
compile error

$overflow on
code auto:22 mod[Integer] -127[Int8], 1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:23 mod[compile-time] -127[Int8], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:24 mod[Integer] -127[Int8], 127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:25 mod[compile-time] -127[Int8], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:26 mod[Integer] -1[Int8], -128[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:27 mod[compile-time] -1[Int8], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -128;
endcode
varvalue r -1

$overflow on
code auto:28 mod[Integer] -1[Int8], -127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:29 mod[compile-time] -1[Int8], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -127;
endcode
varvalue r -1

$overflow on
code auto:30 mod[Integer] -1[Int8], -1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:31 mod[compile-time] -1[Int8], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:32 mod[Integer] -1[Int8], 0[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:33 mod[compile-time] -1[Int8], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:34 mod[Integer] -1[Int8], 1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:35 mod[compile-time] -1[Int8], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:36 mod[Integer] -1[Int8], 127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:37 mod[compile-time] -1[Int8], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 127;
endcode
varvalue r -1

$overflow on
code auto:38 mod[Integer] 0[Int8], -128[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:39 mod[compile-time] 0[Int8], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow on
code auto:40 mod[Integer] 0[Int8], -127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:41 mod[compile-time] 0[Int8], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -127;
endcode
varvalue r 0

$overflow on
code auto:42 mod[Integer] 0[Int8], -1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:43 mod[compile-time] 0[Int8], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow on
code auto:44 mod[Integer] 0[Int8], 0[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:45 mod[compile-time] 0[Int8], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:46 mod[Integer] 0[Int8], 1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:47 mod[compile-time] 0[Int8], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:48 mod[Integer] 0[Int8], 127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:49 mod[compile-time] 0[Int8], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:50 mod[Integer] 1[Int8], -128[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:51 mod[compile-time] 1[Int8], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow on
code auto:52 mod[Integer] 1[Int8], -127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:53 mod[compile-time] 1[Int8], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -127;
endcode
varvalue r 1

$overflow on
code auto:54 mod[Integer] 1[Int8], -1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:55 mod[compile-time] 1[Int8], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:56 mod[Integer] 1[Int8], 0[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:57 mod[compile-time] 1[Int8], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:58 mod[Integer] 1[Int8], 1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:59 mod[compile-time] 1[Int8], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:60 mod[Integer] 1[Int8], 127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:61 mod[compile-time] 1[Int8], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow on
code auto:62 mod[Integer] 127[Int8], -128[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:63 mod[compile-time] 127[Int8], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow on
code auto:64 mod[Integer] 127[Int8], -127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:65 mod[compile-time] 127[Int8], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -127;
endcode
varvalue r 0

$overflow on
code auto:66 mod[Integer] 127[Int8], -1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:67 mod[compile-time] 127[Int8], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow on
code auto:68 mod[Integer] 127[Int8], 0[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:69 mod[compile-time] 127[Int8], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:70 mod[Integer] 127[Int8], 1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:71 mod[compile-time] 127[Int8], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:72 mod[Integer] 127[Int8], 127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:73 mod[compile-time] 127[Int8], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:74 mod[Integer] -128[Int8], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:75 mod[compile-time] -128[Int8], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -32768;
endcode
varvalue r -128

$overflow on
code auto:76 mod[Integer] -128[Int8], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:77 mod[compile-time] -128[Int8], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -32767;
endcode
varvalue r -128

$overflow on
code auto:78 mod[Integer] -128[Int8], -129[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:79 mod[compile-time] -128[Int8], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -129;
endcode
varvalue r -128

$overflow on
code auto:80 mod[Integer] -128[Int8], -128[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:81 mod[compile-time] -128[Int8], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -128;
endcode
varvalue r 0

$overflow on
code auto:82 mod[Integer] -128[Int8], -1[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:83 mod[compile-time] -128[Int8], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -1;
endcode
varvalue r 0

$overflow on
code auto:84 mod[Integer] -128[Int8], 0[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:85 mod[compile-time] -128[Int8], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:86 mod[Integer] -128[Int8], 1[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:87 mod[compile-time] -128[Int8], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:88 mod[Integer] -128[Int8], 127[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:89 mod[compile-time] -128[Int8], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 127;
endcode
varvalue r -1

$overflow on
code auto:90 mod[Integer] -128[Int8], 128[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:91 mod[compile-time] -128[Int8], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 128;
endcode
varvalue r 0

$overflow on
code auto:92 mod[Integer] -128[Int8], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:93 mod[compile-time] -128[Int8], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 32767;
endcode
varvalue r -128

$overflow on
code auto:94 mod[Integer] -127[Int8], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:95 mod[compile-time] -127[Int8], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod -32768;
endcode
varvalue r -127

$overflow on
code auto:96 mod[Integer] -127[Int8], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:97 mod[compile-time] -127[Int8], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod -32767;
endcode
varvalue r -127

$overflow on
code auto:98 mod[Integer] -127[Int8], -129[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:99 mod[compile-time] -127[Int8], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod -129;
endcode
varvalue r -127

$overflow on
code auto:100 mod[Integer] -127[Int8], -128[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:101 mod[compile-time] -127[Int8], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod -128;
endcode
varvalue r -127

$overflow on
code auto:102 mod[Integer] -127[Int8], -1[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:103 mod[compile-time] -127[Int8], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod -1;
endcode
varvalue r 0

$overflow on
code auto:104 mod[Integer] -127[Int8], 0[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:105 mod[compile-time] -127[Int8], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 0;
endcode
compile error

$overflow on
code auto:106 mod[Integer] -127[Int8], 1[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:107 mod[compile-time] -127[Int8], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:108 mod[Integer] -127[Int8], 127[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:109 mod[compile-time] -127[Int8], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:110 mod[Integer] -127[Int8], 128[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:111 mod[compile-time] -127[Int8], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 128;
endcode
varvalue r -127

$overflow on
code auto:112 mod[Integer] -127[Int8], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:113 mod[compile-time] -127[Int8], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 32767;
endcode
varvalue r -127

$overflow on
code auto:114 mod[Integer] -1[Int8], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:115 mod[compile-time] -1[Int8], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -32768;
endcode
varvalue r -1

$overflow on
code auto:116 mod[Integer] -1[Int8], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:117 mod[compile-time] -1[Int8], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -32767;
endcode
varvalue r -1

$overflow on
code auto:118 mod[Integer] -1[Int8], -129[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:119 mod[compile-time] -1[Int8], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -129;
endcode
varvalue r -1

$overflow on
code auto:120 mod[Integer] -1[Int8], -128[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:121 mod[compile-time] -1[Int8], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -128;
endcode
varvalue r -1

$overflow on
code auto:122 mod[Integer] -1[Int8], -1[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:123 mod[compile-time] -1[Int8], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:124 mod[Integer] -1[Int8], 0[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:125 mod[compile-time] -1[Int8], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:126 mod[Integer] -1[Int8], 1[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:127 mod[compile-time] -1[Int8], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:128 mod[Integer] -1[Int8], 127[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:129 mod[compile-time] -1[Int8], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 127;
endcode
varvalue r -1

$overflow on
code auto:130 mod[Integer] -1[Int8], 128[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:131 mod[compile-time] -1[Int8], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 128;
endcode
varvalue r -1

$overflow on
code auto:132 mod[Integer] -1[Int8], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:133 mod[compile-time] -1[Int8], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 32767;
endcode
varvalue r -1

$overflow on
code auto:134 mod[Integer] 0[Int8], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:135 mod[compile-time] 0[Int8], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -32768;
endcode
varvalue r 0

$overflow on
code auto:136 mod[Integer] 0[Int8], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:137 mod[compile-time] 0[Int8], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -32767;
endcode
varvalue r 0

$overflow on
code auto:138 mod[Integer] 0[Int8], -129[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:139 mod[compile-time] 0[Int8], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -129;
endcode
varvalue r 0

$overflow on
code auto:140 mod[Integer] 0[Int8], -128[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:141 mod[compile-time] 0[Int8], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow on
code auto:142 mod[Integer] 0[Int8], -1[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:143 mod[compile-time] 0[Int8], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow on
code auto:144 mod[Integer] 0[Int8], 0[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:145 mod[compile-time] 0[Int8], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:146 mod[Integer] 0[Int8], 1[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:147 mod[compile-time] 0[Int8], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:148 mod[Integer] 0[Int8], 127[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:149 mod[compile-time] 0[Int8], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:150 mod[Integer] 0[Int8], 128[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:151 mod[compile-time] 0[Int8], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow on
code auto:152 mod[Integer] 0[Int8], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:153 mod[compile-time] 0[Int8], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:154 mod[Integer] 1[Int8], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:155 mod[compile-time] 1[Int8], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -32768;
endcode
varvalue r 1

$overflow on
code auto:156 mod[Integer] 1[Int8], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:157 mod[compile-time] 1[Int8], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -32767;
endcode
varvalue r 1

$overflow on
code auto:158 mod[Integer] 1[Int8], -129[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:159 mod[compile-time] 1[Int8], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -129;
endcode
varvalue r 1

$overflow on
code auto:160 mod[Integer] 1[Int8], -128[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:161 mod[compile-time] 1[Int8], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow on
code auto:162 mod[Integer] 1[Int8], -1[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:163 mod[compile-time] 1[Int8], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:164 mod[Integer] 1[Int8], 0[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:165 mod[compile-time] 1[Int8], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:166 mod[Integer] 1[Int8], 1[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:167 mod[compile-time] 1[Int8], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:168 mod[Integer] 1[Int8], 127[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:169 mod[compile-time] 1[Int8], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow on
code auto:170 mod[Integer] 1[Int8], 128[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:171 mod[compile-time] 1[Int8], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow on
code auto:172 mod[Integer] 1[Int8], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:173 mod[compile-time] 1[Int8], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:174 mod[Integer] 127[Int8], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:175 mod[compile-time] 127[Int8], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -32768;
endcode
varvalue r 127

$overflow on
code auto:176 mod[Integer] 127[Int8], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:177 mod[compile-time] 127[Int8], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -32767;
endcode
varvalue r 127

$overflow on
code auto:178 mod[Integer] 127[Int8], -129[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:179 mod[compile-time] 127[Int8], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -129;
endcode
varvalue r 127

$overflow on
code auto:180 mod[Integer] 127[Int8], -128[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:181 mod[compile-time] 127[Int8], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow on
code auto:182 mod[Integer] 127[Int8], -1[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:183 mod[compile-time] 127[Int8], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow on
code auto:184 mod[Integer] 127[Int8], 0[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:185 mod[compile-time] 127[Int8], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:186 mod[Integer] 127[Int8], 1[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:187 mod[compile-time] 127[Int8], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:188 mod[Integer] 127[Int8], 127[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:189 mod[compile-time] 127[Int8], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:190 mod[Integer] 127[Int8], 128[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:191 mod[compile-time] 127[Int8], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow on
code auto:192 mod[Integer] 127[Int8], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:193 mod[compile-time] 127[Int8], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow on
code auto:194 mod[Integer] -128[Int8], 0[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:195 mod[compile-time] -128[Int8], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:196 mod[Integer] -128[Int8], 1[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:197 mod[compile-time] -128[Int8], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:198 mod[Integer] -128[Int8], 127[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:199 mod[compile-time] -128[Int8], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 127;
endcode
varvalue r -1

$overflow on
code auto:200 mod[Integer] -128[Int8], 128[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:201 mod[compile-time] -128[Int8], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 128;
endcode
varvalue r 0

$overflow on
code auto:202 mod[Integer] -128[Int8], 255[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:203 mod[compile-time] -128[Int8], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 255;
endcode
varvalue r -128

$overflow on
code auto:204 mod[Integer] -127[Int8], 0[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:205 mod[compile-time] -127[Int8], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 0;
endcode
compile error

$overflow on
code auto:206 mod[Integer] -127[Int8], 1[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:207 mod[compile-time] -127[Int8], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:208 mod[Integer] -127[Int8], 127[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:209 mod[compile-time] -127[Int8], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:210 mod[Integer] -127[Int8], 128[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:211 mod[compile-time] -127[Int8], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 128;
endcode
varvalue r -127

$overflow on
code auto:212 mod[Integer] -127[Int8], 255[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:213 mod[compile-time] -127[Int8], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 255;
endcode
varvalue r -127

$overflow on
code auto:214 mod[Integer] -1[Int8], 0[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:215 mod[compile-time] -1[Int8], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:216 mod[Integer] -1[Int8], 1[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:217 mod[compile-time] -1[Int8], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:218 mod[Integer] -1[Int8], 127[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:219 mod[compile-time] -1[Int8], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 127;
endcode
varvalue r -1

$overflow on
code auto:220 mod[Integer] -1[Int8], 128[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:221 mod[compile-time] -1[Int8], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 128;
endcode
varvalue r -1

$overflow on
code auto:222 mod[Integer] -1[Int8], 255[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:223 mod[compile-time] -1[Int8], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 255;
endcode
varvalue r -1

$overflow on
code auto:224 mod[Integer] 0[Int8], 0[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:225 mod[compile-time] 0[Int8], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:226 mod[Integer] 0[Int8], 1[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:227 mod[compile-time] 0[Int8], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:228 mod[Integer] 0[Int8], 127[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:229 mod[compile-time] 0[Int8], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:230 mod[Integer] 0[Int8], 128[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:231 mod[compile-time] 0[Int8], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow on
code auto:232 mod[Integer] 0[Int8], 255[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:233 mod[compile-time] 0[Int8], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:234 mod[Integer] 1[Int8], 0[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:235 mod[compile-time] 1[Int8], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:236 mod[Integer] 1[Int8], 1[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:237 mod[compile-time] 1[Int8], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:238 mod[Integer] 1[Int8], 127[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:239 mod[compile-time] 1[Int8], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow on
code auto:240 mod[Integer] 1[Int8], 128[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:241 mod[compile-time] 1[Int8], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow on
code auto:242 mod[Integer] 1[Int8], 255[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:243 mod[compile-time] 1[Int8], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow on
code auto:244 mod[Integer] 127[Int8], 0[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:245 mod[compile-time] 127[Int8], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:246 mod[Integer] 127[Int8], 1[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:247 mod[compile-time] 127[Int8], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:248 mod[Integer] 127[Int8], 127[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:249 mod[compile-time] 127[Int8], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:250 mod[Integer] 127[Int8], 128[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:251 mod[compile-time] 127[Int8], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow on
code auto:252 mod[Integer] 127[Int8], 255[Byte] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:253 mod[compile-time] 127[Int8], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow on
code auto:254 mod[Integer] -128[Int8], 0[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:255 mod[compile-time] -128[Int8], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:256 mod[Integer] -128[Int8], 255[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:257 mod[compile-time] -128[Int8], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 255;
endcode
varvalue r -128

$overflow on
code auto:258 mod[Integer] -128[Int8], 32767[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:259 mod[compile-time] -128[Int8], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 32767;
endcode
varvalue r -128

$overflow on
code auto:260 mod[Integer] -128[Int8], 32768[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:261 mod[compile-time] -128[Int8], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 32768;
endcode
varvalue r -128

$overflow on
code auto:262 mod[Integer] -128[Int8], 65535[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:263 mod[compile-time] -128[Int8], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 65535;
endcode
varvalue r -128

$overflow on
code auto:264 mod[Integer] -127[Int8], 0[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:265 mod[compile-time] -127[Int8], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 0;
endcode
compile error

$overflow on
code auto:266 mod[Integer] -127[Int8], 255[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:267 mod[compile-time] -127[Int8], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 255;
endcode
varvalue r -127

$overflow on
code auto:268 mod[Integer] -127[Int8], 32767[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:269 mod[compile-time] -127[Int8], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 32767;
endcode
varvalue r -127

$overflow on
code auto:270 mod[Integer] -127[Int8], 32768[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:271 mod[compile-time] -127[Int8], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 32768;
endcode
varvalue r -127

$overflow on
code auto:272 mod[Integer] -127[Int8], 65535[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:273 mod[compile-time] -127[Int8], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 65535;
endcode
varvalue r -127

$overflow on
code auto:274 mod[Integer] -1[Int8], 0[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:275 mod[compile-time] -1[Int8], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:276 mod[Integer] -1[Int8], 255[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:277 mod[compile-time] -1[Int8], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 255;
endcode
varvalue r -1

$overflow on
code auto:278 mod[Integer] -1[Int8], 32767[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:279 mod[compile-time] -1[Int8], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 32767;
endcode
varvalue r -1

$overflow on
code auto:280 mod[Integer] -1[Int8], 32768[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:281 mod[compile-time] -1[Int8], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 32768;
endcode
varvalue r -1

$overflow on
code auto:282 mod[Integer] -1[Int8], 65535[Word] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:283 mod[compile-time] -1[Int8], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 65535;
endcode
varvalue r -1

$overflow on
code auto:284 mod[Integer] 0[Int8], 0[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:285 mod[compile-time] 0[Int8], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:286 mod[Integer] 0[Int8], 255[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:287 mod[compile-time] 0[Int8], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:288 mod[Integer] 0[Int8], 32767[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:289 mod[compile-time] 0[Int8], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:290 mod[Integer] 0[Int8], 32768[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:291 mod[compile-time] 0[Int8], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:292 mod[Integer] 0[Int8], 65535[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:293 mod[compile-time] 0[Int8], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:294 mod[Integer] 1[Int8], 0[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:295 mod[compile-time] 1[Int8], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:296 mod[Integer] 1[Int8], 255[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:297 mod[compile-time] 1[Int8], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow on
code auto:298 mod[Integer] 1[Int8], 32767[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:299 mod[compile-time] 1[Int8], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:300 mod[Integer] 1[Int8], 32768[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:301 mod[compile-time] 1[Int8], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 32768;
endcode
varvalue r 1

$overflow on
code auto:302 mod[Integer] 1[Int8], 65535[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:303 mod[compile-time] 1[Int8], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 65535;
endcode
varvalue r 1

$overflow on
code auto:304 mod[Integer] 127[Int8], 0[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:305 mod[compile-time] 127[Int8], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:306 mod[Integer] 127[Int8], 255[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:307 mod[compile-time] 127[Int8], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow on
code auto:308 mod[Integer] 127[Int8], 32767[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:309 mod[compile-time] 127[Int8], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow on
code auto:310 mod[Integer] 127[Int8], 32768[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:311 mod[compile-time] 127[Int8], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 32768;
endcode
varvalue r 127

$overflow on
code auto:312 mod[Integer] 127[Int8], 65535[Word] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:313 mod[compile-time] 127[Int8], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 65535;
endcode
varvalue r 127

$overflow on
code auto:314 mod[Pointer] -128[Int8], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:315 mod[compile-time] -128[Int8], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:316 mod[Pointer] -128[Int8], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:317 mod[compile-time] -128[Int8], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -128 mod 255;
endcode
compile error

$overflow on
code auto:318 mod[Pointer] -128[Int8], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:319 mod[compile-time] -128[Int8], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -128 mod 32767;
endcode
compile error

$overflow on
code auto:320 mod[Pointer] -128[Int8], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:321 mod[compile-time] -128[Int8], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -128 mod 32768;
endcode
compile error

$overflow on
code auto:322 mod[Pointer] -128[Int8], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:323 mod[compile-time] -128[Int8], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -128 mod 65535;
endcode
compile error

$overflow on
code auto:324 mod[Pointer] -127[Int8], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:325 mod[compile-time] -127[Int8], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -127 mod 0;
endcode
compile error

$overflow on
code auto:326 mod[Pointer] -127[Int8], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:327 mod[compile-time] -127[Int8], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -127 mod 255;
endcode
compile error

$overflow on
code auto:328 mod[Pointer] -127[Int8], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:329 mod[compile-time] -127[Int8], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -127 mod 32767;
endcode
compile error

$overflow on
code auto:330 mod[Pointer] -127[Int8], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:331 mod[compile-time] -127[Int8], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -127 mod 32768;
endcode
compile error

$overflow on
code auto:332 mod[Pointer] -127[Int8], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:333 mod[compile-time] -127[Int8], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -127 mod 65535;
endcode
compile error

$overflow on
code auto:334 mod[Pointer] -1[Int8], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:335 mod[compile-time] -1[Int8], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:336 mod[Pointer] -1[Int8], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:337 mod[compile-time] -1[Int8], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -1 mod 255;
endcode
compile error

$overflow on
code auto:338 mod[Pointer] -1[Int8], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:339 mod[compile-time] -1[Int8], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -1 mod 32767;
endcode
compile error

$overflow on
code auto:340 mod[Pointer] -1[Int8], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:341 mod[compile-time] -1[Int8], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -1 mod 32768;
endcode
compile error

$overflow on
code auto:342 mod[Pointer] -1[Int8], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:343 mod[compile-time] -1[Int8], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -1 mod 65535;
endcode
compile error

$overflow on
code auto:344 mod[Pointer] 0[Int8], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:345 mod[compile-time] 0[Int8], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:346 mod[Pointer] 0[Int8], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:347 mod[compile-time] 0[Int8], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:348 mod[Pointer] 0[Int8], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:349 mod[compile-time] 0[Int8], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:350 mod[Pointer] 0[Int8], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:351 mod[compile-time] 0[Int8], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:352 mod[Pointer] 0[Int8], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:353 mod[compile-time] 0[Int8], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:354 mod[Pointer] 1[Int8], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:355 mod[compile-time] 1[Int8], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:356 mod[Pointer] 1[Int8], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:357 mod[compile-time] 1[Int8], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow on
code auto:358 mod[Pointer] 1[Int8], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:359 mod[compile-time] 1[Int8], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:360 mod[Pointer] 1[Int8], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:361 mod[compile-time] 1[Int8], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 32768;
endcode
varvalue r 1

$overflow on
code auto:362 mod[Pointer] 1[Int8], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:363 mod[compile-time] 1[Int8], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 65535;
endcode
varvalue r 1

$overflow on
code auto:364 mod[Pointer] 127[Int8], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:365 mod[compile-time] 127[Int8], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:366 mod[Pointer] 127[Int8], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:367 mod[compile-time] 127[Int8], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow on
code auto:368 mod[Pointer] 127[Int8], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:369 mod[compile-time] 127[Int8], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow on
code auto:370 mod[Pointer] 127[Int8], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:371 mod[compile-time] 127[Int8], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 32768;
endcode
varvalue r 127

$overflow on
code auto:372 mod[Pointer] 127[Int8], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:373 mod[compile-time] 127[Int8], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 65535;
endcode
varvalue r 127

$overflow on
code auto:374 mod[Integer] -32768[Integer], -128[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:375 mod[compile-time] -32768[Integer], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -128;
endcode
varvalue r 0

$overflow on
code auto:376 mod[Integer] -32768[Integer], -127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -2

code auto:377 mod[compile-time] -32768[Integer], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -127;
endcode
varvalue r -2

$overflow on
code auto:378 mod[Integer] -32768[Integer], -1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:379 mod[compile-time] -32768[Integer], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -1;
endcode
varvalue r 0

$overflow on
code auto:380 mod[Integer] -32768[Integer], 0[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:381 mod[compile-time] -32768[Integer], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 0;
endcode
compile error

$overflow on
code auto:382 mod[Integer] -32768[Integer], 1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:383 mod[compile-time] -32768[Integer], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 1;
endcode
varvalue r 0

$overflow on
code auto:384 mod[Integer] -32768[Integer], 127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -2

code auto:385 mod[compile-time] -32768[Integer], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 127;
endcode
varvalue r -2

$overflow on
code auto:386 mod[Integer] -32767[Integer], -128[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:387 mod[compile-time] -32767[Integer], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -128;
endcode
varvalue r -127

$overflow on
code auto:388 mod[Integer] -32767[Integer], -127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:389 mod[compile-time] -32767[Integer], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -127;
endcode
varvalue r -1

$overflow on
code auto:390 mod[Integer] -32767[Integer], -1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:391 mod[compile-time] -32767[Integer], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -1;
endcode
varvalue r 0

$overflow on
code auto:392 mod[Integer] -32767[Integer], 0[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:393 mod[compile-time] -32767[Integer], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 0;
endcode
compile error

$overflow on
code auto:394 mod[Integer] -32767[Integer], 1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:395 mod[compile-time] -32767[Integer], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:396 mod[Integer] -32767[Integer], 127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:397 mod[compile-time] -32767[Integer], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 127;
endcode
varvalue r -1

$overflow on
code auto:398 mod[Integer] -129[Integer], -128[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:399 mod[compile-time] -129[Integer], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -128;
endcode
varvalue r -1

$overflow on
code auto:400 mod[Integer] -129[Integer], -127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -2

code auto:401 mod[compile-time] -129[Integer], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -127;
endcode
varvalue r -2

$overflow on
code auto:402 mod[Integer] -129[Integer], -1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:403 mod[compile-time] -129[Integer], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -1;
endcode
varvalue r 0

$overflow on
code auto:404 mod[Integer] -129[Integer], 0[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:405 mod[compile-time] -129[Integer], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 0;
endcode
compile error

$overflow on
code auto:406 mod[Integer] -129[Integer], 1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:407 mod[compile-time] -129[Integer], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 1;
endcode
varvalue r 0

$overflow on
code auto:408 mod[Integer] -129[Integer], 127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -2

code auto:409 mod[compile-time] -129[Integer], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 127;
endcode
varvalue r -2

$overflow on
code auto:410 mod[Integer] -128[Integer], -128[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:411 mod[compile-time] -128[Integer], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -128;
endcode
varvalue r 0

$overflow on
code auto:412 mod[Integer] -128[Integer], -127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:413 mod[compile-time] -128[Integer], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -127;
endcode
varvalue r -1

$overflow on
code auto:414 mod[Integer] -128[Integer], -1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:415 mod[compile-time] -128[Integer], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -1;
endcode
varvalue r 0

$overflow on
code auto:416 mod[Integer] -128[Integer], 0[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:417 mod[compile-time] -128[Integer], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:418 mod[Integer] -128[Integer], 1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:419 mod[compile-time] -128[Integer], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:420 mod[Integer] -128[Integer], 127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:421 mod[compile-time] -128[Integer], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 127;
endcode
varvalue r -1

$overflow on
code auto:422 mod[Integer] -1[Integer], -128[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:423 mod[compile-time] -1[Integer], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -128;
endcode
varvalue r -1

$overflow on
code auto:424 mod[Integer] -1[Integer], -127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:425 mod[compile-time] -1[Integer], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -127;
endcode
varvalue r -1

$overflow on
code auto:426 mod[Integer] -1[Integer], -1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:427 mod[compile-time] -1[Integer], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:428 mod[Integer] -1[Integer], 0[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:429 mod[compile-time] -1[Integer], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:430 mod[Integer] -1[Integer], 1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:431 mod[compile-time] -1[Integer], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:432 mod[Integer] -1[Integer], 127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:433 mod[compile-time] -1[Integer], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 127;
endcode
varvalue r -1

$overflow on
code auto:434 mod[Integer] 0[Integer], -128[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:435 mod[compile-time] 0[Integer], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow on
code auto:436 mod[Integer] 0[Integer], -127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:437 mod[compile-time] 0[Integer], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -127;
endcode
varvalue r 0

$overflow on
code auto:438 mod[Integer] 0[Integer], -1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:439 mod[compile-time] 0[Integer], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow on
code auto:440 mod[Integer] 0[Integer], 0[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:441 mod[compile-time] 0[Integer], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:442 mod[Integer] 0[Integer], 1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:443 mod[compile-time] 0[Integer], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:444 mod[Integer] 0[Integer], 127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:445 mod[compile-time] 0[Integer], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:446 mod[Integer] 1[Integer], -128[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:447 mod[compile-time] 1[Integer], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow on
code auto:448 mod[Integer] 1[Integer], -127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:449 mod[compile-time] 1[Integer], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -127;
endcode
varvalue r 1

$overflow on
code auto:450 mod[Integer] 1[Integer], -1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:451 mod[compile-time] 1[Integer], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:452 mod[Integer] 1[Integer], 0[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:453 mod[compile-time] 1[Integer], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:454 mod[Integer] 1[Integer], 1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:455 mod[compile-time] 1[Integer], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:456 mod[Integer] 1[Integer], 127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:457 mod[compile-time] 1[Integer], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow on
code auto:458 mod[Integer] 127[Integer], -128[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:459 mod[compile-time] 127[Integer], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow on
code auto:460 mod[Integer] 127[Integer], -127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:461 mod[compile-time] 127[Integer], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -127;
endcode
varvalue r 0

$overflow on
code auto:462 mod[Integer] 127[Integer], -1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:463 mod[compile-time] 127[Integer], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow on
code auto:464 mod[Integer] 127[Integer], 0[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:465 mod[compile-time] 127[Integer], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:466 mod[Integer] 127[Integer], 1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:467 mod[compile-time] 127[Integer], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:468 mod[Integer] 127[Integer], 127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:469 mod[compile-time] 127[Integer], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:470 mod[Integer] 128[Integer], -128[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:471 mod[compile-time] 128[Integer], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -128;
endcode
varvalue r 0

$overflow on
code auto:472 mod[Integer] 128[Integer], -127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:473 mod[compile-time] 128[Integer], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -127;
endcode
varvalue r 1

$overflow on
code auto:474 mod[Integer] 128[Integer], -1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:475 mod[compile-time] 128[Integer], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -1;
endcode
varvalue r 0

$overflow on
code auto:476 mod[Integer] 128[Integer], 0[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:477 mod[compile-time] 128[Integer], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:478 mod[Integer] 128[Integer], 1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:479 mod[compile-time] 128[Integer], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:480 mod[Integer] 128[Integer], 127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:481 mod[compile-time] 128[Integer], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow on
code auto:482 mod[Integer] 32767[Integer], -128[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:483 mod[compile-time] 32767[Integer], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -128;
endcode
varvalue r 127

$overflow on
code auto:484 mod[Integer] 32767[Integer], -127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:485 mod[compile-time] 32767[Integer], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -127;
endcode
varvalue r 1

$overflow on
code auto:486 mod[Integer] 32767[Integer], -1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:487 mod[compile-time] 32767[Integer], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -1;
endcode
varvalue r 0

$overflow on
code auto:488 mod[Integer] 32767[Integer], 0[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:489 mod[compile-time] 32767[Integer], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:490 mod[Integer] 32767[Integer], 1[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:491 mod[compile-time] 32767[Integer], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:492 mod[Integer] 32767[Integer], 127[Int8] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:493 mod[compile-time] 32767[Integer], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow on
code auto:494 mod[Integer] -32768[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:495 mod[compile-time] -32768[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -32768;
endcode
varvalue r 0

$overflow on
code auto:496 mod[Integer] -32768[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:497 mod[compile-time] -32768[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -32767;
endcode
varvalue r -1

$overflow on
code auto:498 mod[Integer] -32768[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -2

code auto:499 mod[compile-time] -32768[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -129;
endcode
varvalue r -2

$overflow on
code auto:500 mod[Integer] -32768[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:501 mod[compile-time] -32768[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -128;
endcode
varvalue r 0

$overflow on
code auto:502 mod[Integer] -32768[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:503 mod[compile-time] -32768[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -1;
endcode
varvalue r 0

$overflow on
code auto:504 mod[Integer] -32768[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:505 mod[compile-time] -32768[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 0;
endcode
compile error

$overflow on
code auto:506 mod[Integer] -32768[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:507 mod[compile-time] -32768[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 1;
endcode
varvalue r 0

$overflow on
code auto:508 mod[Integer] -32768[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -2

code auto:509 mod[compile-time] -32768[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 127;
endcode
varvalue r -2

$overflow on
code auto:510 mod[Integer] -32768[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:511 mod[compile-time] -32768[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 128;
endcode
varvalue r 0

$overflow on
code auto:512 mod[Integer] -32768[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:513 mod[compile-time] -32768[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 32767;
endcode
varvalue r -1

$overflow on
code auto:514 mod[Integer] -32767[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -32767

code auto:515 mod[compile-time] -32767[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -32768;
endcode
varvalue r -32767

$overflow on
code auto:516 mod[Integer] -32767[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:517 mod[compile-time] -32767[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -32767;
endcode
varvalue r 0

$overflow on
code auto:518 mod[Integer] -32767[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:519 mod[compile-time] -32767[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -129;
endcode
varvalue r -1

$overflow on
code auto:520 mod[Integer] -32767[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:521 mod[compile-time] -32767[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -128;
endcode
varvalue r -127

$overflow on
code auto:522 mod[Integer] -32767[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:523 mod[compile-time] -32767[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -1;
endcode
varvalue r 0

$overflow on
code auto:524 mod[Integer] -32767[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:525 mod[compile-time] -32767[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 0;
endcode
compile error

$overflow on
code auto:526 mod[Integer] -32767[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:527 mod[compile-time] -32767[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:528 mod[Integer] -32767[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:529 mod[compile-time] -32767[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 127;
endcode
varvalue r -1

$overflow on
code auto:530 mod[Integer] -32767[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:531 mod[compile-time] -32767[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 128;
endcode
varvalue r -127

$overflow on
code auto:532 mod[Integer] -32767[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:533 mod[compile-time] -32767[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:534 mod[Integer] -129[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -129

code auto:535 mod[compile-time] -129[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -32768;
endcode
varvalue r -129

$overflow on
code auto:536 mod[Integer] -129[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -129

code auto:537 mod[compile-time] -129[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -32767;
endcode
varvalue r -129

$overflow on
code auto:538 mod[Integer] -129[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:539 mod[compile-time] -129[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -129;
endcode
varvalue r 0

$overflow on
code auto:540 mod[Integer] -129[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:541 mod[compile-time] -129[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -128;
endcode
varvalue r -1

$overflow on
code auto:542 mod[Integer] -129[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:543 mod[compile-time] -129[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -1;
endcode
varvalue r 0

$overflow on
code auto:544 mod[Integer] -129[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:545 mod[compile-time] -129[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 0;
endcode
compile error

$overflow on
code auto:546 mod[Integer] -129[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:547 mod[compile-time] -129[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 1;
endcode
varvalue r 0

$overflow on
code auto:548 mod[Integer] -129[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -2

code auto:549 mod[compile-time] -129[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 127;
endcode
varvalue r -2

$overflow on
code auto:550 mod[Integer] -129[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:551 mod[compile-time] -129[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 128;
endcode
varvalue r -1

$overflow on
code auto:552 mod[Integer] -129[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -129

code auto:553 mod[compile-time] -129[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 32767;
endcode
varvalue r -129

$overflow on
code auto:554 mod[Integer] -128[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:555 mod[compile-time] -128[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -32768;
endcode
varvalue r -128

$overflow on
code auto:556 mod[Integer] -128[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:557 mod[compile-time] -128[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -32767;
endcode
varvalue r -128

$overflow on
code auto:558 mod[Integer] -128[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:559 mod[compile-time] -128[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -129;
endcode
varvalue r -128

$overflow on
code auto:560 mod[Integer] -128[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:561 mod[compile-time] -128[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -128;
endcode
varvalue r 0

$overflow on
code auto:562 mod[Integer] -128[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:563 mod[compile-time] -128[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -1;
endcode
varvalue r 0

$overflow on
code auto:564 mod[Integer] -128[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:565 mod[compile-time] -128[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:566 mod[Integer] -128[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:567 mod[compile-time] -128[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:568 mod[Integer] -128[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:569 mod[compile-time] -128[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 127;
endcode
varvalue r -1

$overflow on
code auto:570 mod[Integer] -128[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:571 mod[compile-time] -128[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 128;
endcode
varvalue r 0

$overflow on
code auto:572 mod[Integer] -128[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:573 mod[compile-time] -128[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 32767;
endcode
varvalue r -128

$overflow on
code auto:574 mod[Integer] -1[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:575 mod[compile-time] -1[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -32768;
endcode
varvalue r -1

$overflow on
code auto:576 mod[Integer] -1[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:577 mod[compile-time] -1[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -32767;
endcode
varvalue r -1

$overflow on
code auto:578 mod[Integer] -1[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:579 mod[compile-time] -1[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -129;
endcode
varvalue r -1

$overflow on
code auto:580 mod[Integer] -1[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:581 mod[compile-time] -1[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -128;
endcode
varvalue r -1

$overflow on
code auto:582 mod[Integer] -1[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:583 mod[compile-time] -1[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:584 mod[Integer] -1[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:585 mod[compile-time] -1[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:586 mod[Integer] -1[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:587 mod[compile-time] -1[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:588 mod[Integer] -1[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:589 mod[compile-time] -1[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 127;
endcode
varvalue r -1

$overflow on
code auto:590 mod[Integer] -1[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:591 mod[compile-time] -1[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 128;
endcode
varvalue r -1

$overflow on
code auto:592 mod[Integer] -1[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:593 mod[compile-time] -1[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 32767;
endcode
varvalue r -1

$overflow on
code auto:594 mod[Integer] 0[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:595 mod[compile-time] 0[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -32768;
endcode
varvalue r 0

$overflow on
code auto:596 mod[Integer] 0[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:597 mod[compile-time] 0[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -32767;
endcode
varvalue r 0

$overflow on
code auto:598 mod[Integer] 0[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:599 mod[compile-time] 0[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -129;
endcode
varvalue r 0

$overflow on
code auto:600 mod[Integer] 0[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:601 mod[compile-time] 0[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow on
code auto:602 mod[Integer] 0[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:603 mod[compile-time] 0[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow on
code auto:604 mod[Integer] 0[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:605 mod[compile-time] 0[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:606 mod[Integer] 0[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:607 mod[compile-time] 0[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:608 mod[Integer] 0[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:609 mod[compile-time] 0[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:610 mod[Integer] 0[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:611 mod[compile-time] 0[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow on
code auto:612 mod[Integer] 0[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:613 mod[compile-time] 0[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:614 mod[Integer] 1[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:615 mod[compile-time] 1[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -32768;
endcode
varvalue r 1

$overflow on
code auto:616 mod[Integer] 1[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:617 mod[compile-time] 1[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -32767;
endcode
varvalue r 1

$overflow on
code auto:618 mod[Integer] 1[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:619 mod[compile-time] 1[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -129;
endcode
varvalue r 1

$overflow on
code auto:620 mod[Integer] 1[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:621 mod[compile-time] 1[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow on
code auto:622 mod[Integer] 1[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:623 mod[compile-time] 1[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:624 mod[Integer] 1[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:625 mod[compile-time] 1[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:626 mod[Integer] 1[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:627 mod[compile-time] 1[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:628 mod[Integer] 1[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:629 mod[compile-time] 1[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow on
code auto:630 mod[Integer] 1[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:631 mod[compile-time] 1[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow on
code auto:632 mod[Integer] 1[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:633 mod[compile-time] 1[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:634 mod[Integer] 127[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:635 mod[compile-time] 127[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -32768;
endcode
varvalue r 127

$overflow on
code auto:636 mod[Integer] 127[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:637 mod[compile-time] 127[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -32767;
endcode
varvalue r 127

$overflow on
code auto:638 mod[Integer] 127[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:639 mod[compile-time] 127[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -129;
endcode
varvalue r 127

$overflow on
code auto:640 mod[Integer] 127[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:641 mod[compile-time] 127[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow on
code auto:642 mod[Integer] 127[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:643 mod[compile-time] 127[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow on
code auto:644 mod[Integer] 127[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:645 mod[compile-time] 127[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:646 mod[Integer] 127[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:647 mod[compile-time] 127[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:648 mod[Integer] 127[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:649 mod[compile-time] 127[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:650 mod[Integer] 127[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:651 mod[compile-time] 127[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow on
code auto:652 mod[Integer] 127[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:653 mod[compile-time] 127[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow on
code auto:654 mod[Integer] 128[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:655 mod[compile-time] 128[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -32768;
endcode
varvalue r 128

$overflow on
code auto:656 mod[Integer] 128[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:657 mod[compile-time] 128[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -32767;
endcode
varvalue r 128

$overflow on
code auto:658 mod[Integer] 128[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:659 mod[compile-time] 128[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -129;
endcode
varvalue r 128

$overflow on
code auto:660 mod[Integer] 128[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:661 mod[compile-time] 128[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -128;
endcode
varvalue r 0

$overflow on
code auto:662 mod[Integer] 128[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:663 mod[compile-time] 128[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -1;
endcode
varvalue r 0

$overflow on
code auto:664 mod[Integer] 128[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:665 mod[compile-time] 128[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:666 mod[Integer] 128[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:667 mod[compile-time] 128[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:668 mod[Integer] 128[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:669 mod[compile-time] 128[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow on
code auto:670 mod[Integer] 128[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:671 mod[compile-time] 128[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 128;
endcode
varvalue r 0

$overflow on
code auto:672 mod[Integer] 128[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:673 mod[compile-time] 128[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 32767;
endcode
varvalue r 128

$overflow on
code auto:674 mod[Integer] 32767[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 32767

code auto:675 mod[compile-time] 32767[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -32768;
endcode
varvalue r 32767

$overflow on
code auto:676 mod[Integer] 32767[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:677 mod[compile-time] 32767[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -32767;
endcode
varvalue r 0

$overflow on
code auto:678 mod[Integer] 32767[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:679 mod[compile-time] 32767[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -129;
endcode
varvalue r 1

$overflow on
code auto:680 mod[Integer] 32767[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:681 mod[compile-time] 32767[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -128;
endcode
varvalue r 127

$overflow on
code auto:682 mod[Integer] 32767[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:683 mod[compile-time] 32767[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -1;
endcode
varvalue r 0

$overflow on
code auto:684 mod[Integer] 32767[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:685 mod[compile-time] 32767[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:686 mod[Integer] 32767[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:687 mod[compile-time] 32767[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:688 mod[Integer] 32767[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:689 mod[compile-time] 32767[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow on
code auto:690 mod[Integer] 32767[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:691 mod[compile-time] 32767[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 128;
endcode
varvalue r 127

$overflow on
code auto:692 mod[Integer] 32767[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:693 mod[compile-time] 32767[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:694 mod[Integer] -32768[Integer], 0[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:695 mod[compile-time] -32768[Integer], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 0;
endcode
compile error

$overflow on
code auto:696 mod[Integer] -32768[Integer], 1[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:697 mod[compile-time] -32768[Integer], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 1;
endcode
varvalue r 0

$overflow on
code auto:698 mod[Integer] -32768[Integer], 127[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -2

code auto:699 mod[compile-time] -32768[Integer], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 127;
endcode
varvalue r -2

$overflow on
code auto:700 mod[Integer] -32768[Integer], 128[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:701 mod[compile-time] -32768[Integer], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 128;
endcode
varvalue r 0

$overflow on
code auto:702 mod[Integer] -32768[Integer], 255[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:703 mod[compile-time] -32768[Integer], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 255;
endcode
varvalue r -128

$overflow on
code auto:704 mod[Integer] -32767[Integer], 0[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:705 mod[compile-time] -32767[Integer], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 0;
endcode
compile error

$overflow on
code auto:706 mod[Integer] -32767[Integer], 1[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:707 mod[compile-time] -32767[Integer], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:708 mod[Integer] -32767[Integer], 127[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:709 mod[compile-time] -32767[Integer], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 127;
endcode
varvalue r -1

$overflow on
code auto:710 mod[Integer] -32767[Integer], 128[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:711 mod[compile-time] -32767[Integer], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 128;
endcode
varvalue r -127

$overflow on
code auto:712 mod[Integer] -32767[Integer], 255[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:713 mod[compile-time] -32767[Integer], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 255;
endcode
varvalue r -127

$overflow on
code auto:714 mod[Integer] -129[Integer], 0[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:715 mod[compile-time] -129[Integer], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 0;
endcode
compile error

$overflow on
code auto:716 mod[Integer] -129[Integer], 1[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:717 mod[compile-time] -129[Integer], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 1;
endcode
varvalue r 0

$overflow on
code auto:718 mod[Integer] -129[Integer], 127[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -2

code auto:719 mod[compile-time] -129[Integer], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 127;
endcode
varvalue r -2

$overflow on
code auto:720 mod[Integer] -129[Integer], 128[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:721 mod[compile-time] -129[Integer], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 128;
endcode
varvalue r -1

$overflow on
code auto:722 mod[Integer] -129[Integer], 255[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -129

code auto:723 mod[compile-time] -129[Integer], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 255;
endcode
varvalue r -129

$overflow on
code auto:724 mod[Integer] -128[Integer], 0[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:725 mod[compile-time] -128[Integer], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:726 mod[Integer] -128[Integer], 1[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:727 mod[compile-time] -128[Integer], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:728 mod[Integer] -128[Integer], 127[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:729 mod[compile-time] -128[Integer], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 127;
endcode
varvalue r -1

$overflow on
code auto:730 mod[Integer] -128[Integer], 128[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:731 mod[compile-time] -128[Integer], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 128;
endcode
varvalue r 0

$overflow on
code auto:732 mod[Integer] -128[Integer], 255[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:733 mod[compile-time] -128[Integer], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 255;
endcode
varvalue r -128

$overflow on
code auto:734 mod[Integer] -1[Integer], 0[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:735 mod[compile-time] -1[Integer], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:736 mod[Integer] -1[Integer], 1[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:737 mod[compile-time] -1[Integer], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:738 mod[Integer] -1[Integer], 127[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:739 mod[compile-time] -1[Integer], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 127;
endcode
varvalue r -1

$overflow on
code auto:740 mod[Integer] -1[Integer], 128[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:741 mod[compile-time] -1[Integer], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 128;
endcode
varvalue r -1

$overflow on
code auto:742 mod[Integer] -1[Integer], 255[Byte] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:743 mod[compile-time] -1[Integer], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 255;
endcode
varvalue r -1

$overflow on
code auto:744 mod[Integer] 0[Integer], 0[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:745 mod[compile-time] 0[Integer], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:746 mod[Integer] 0[Integer], 1[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:747 mod[compile-time] 0[Integer], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:748 mod[Integer] 0[Integer], 127[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:749 mod[compile-time] 0[Integer], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:750 mod[Integer] 0[Integer], 128[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:751 mod[compile-time] 0[Integer], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow on
code auto:752 mod[Integer] 0[Integer], 255[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:753 mod[compile-time] 0[Integer], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:754 mod[Integer] 1[Integer], 0[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:755 mod[compile-time] 1[Integer], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:756 mod[Integer] 1[Integer], 1[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:757 mod[compile-time] 1[Integer], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:758 mod[Integer] 1[Integer], 127[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:759 mod[compile-time] 1[Integer], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow on
code auto:760 mod[Integer] 1[Integer], 128[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:761 mod[compile-time] 1[Integer], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow on
code auto:762 mod[Integer] 1[Integer], 255[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:763 mod[compile-time] 1[Integer], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow on
code auto:764 mod[Integer] 127[Integer], 0[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:765 mod[compile-time] 127[Integer], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:766 mod[Integer] 127[Integer], 1[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:767 mod[compile-time] 127[Integer], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:768 mod[Integer] 127[Integer], 127[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:769 mod[compile-time] 127[Integer], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:770 mod[Integer] 127[Integer], 128[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:771 mod[compile-time] 127[Integer], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow on
code auto:772 mod[Integer] 127[Integer], 255[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:773 mod[compile-time] 127[Integer], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow on
code auto:774 mod[Integer] 128[Integer], 0[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:775 mod[compile-time] 128[Integer], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:776 mod[Integer] 128[Integer], 1[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:777 mod[compile-time] 128[Integer], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:778 mod[Integer] 128[Integer], 127[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:779 mod[compile-time] 128[Integer], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow on
code auto:780 mod[Integer] 128[Integer], 128[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:781 mod[compile-time] 128[Integer], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 128;
endcode
varvalue r 0

$overflow on
code auto:782 mod[Integer] 128[Integer], 255[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:783 mod[compile-time] 128[Integer], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 255;
endcode
varvalue r 128

$overflow on
code auto:784 mod[Integer] 32767[Integer], 0[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:785 mod[compile-time] 32767[Integer], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:786 mod[Integer] 32767[Integer], 1[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:787 mod[compile-time] 32767[Integer], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:788 mod[Integer] 32767[Integer], 127[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:789 mod[compile-time] 32767[Integer], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow on
code auto:790 mod[Integer] 32767[Integer], 128[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:791 mod[compile-time] 32767[Integer], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 128;
endcode
varvalue r 127

$overflow on
code auto:792 mod[Integer] 32767[Integer], 255[Byte] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:793 mod[compile-time] 32767[Integer], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow on
code auto:794 mod[Integer] -32768[Integer], 0[Word] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:795 mod[compile-time] -32768[Integer], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 0;
endcode
compile error

$overflow on
code auto:796 mod[Integer] -32768[Integer], 255[Word] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:797 mod[compile-time] -32768[Integer], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 255;
endcode
varvalue r -128

$overflow on
code auto:798 mod[Integer] -32768[Integer], 32767[Word] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:799 mod[compile-time] -32768[Integer], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 32767;
endcode
varvalue r -1

$overflow on
code auto:800 mod[Integer] -32768[Integer], 32768[Word] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:801 mod[compile-time] -32768[Integer], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:802 mod[Integer] -32768[Integer], 65535[Word] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -32768

code auto:803 mod[compile-time] -32768[Integer], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 65535;
endcode
varvalue r -32768

$overflow on
code auto:804 mod[Integer] -32767[Integer], 0[Word] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:805 mod[compile-time] -32767[Integer], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 0;
endcode
compile error

$overflow on
code auto:806 mod[Integer] -32767[Integer], 255[Word] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:807 mod[compile-time] -32767[Integer], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 255;
endcode
varvalue r -127

$overflow on
code auto:808 mod[Integer] -32767[Integer], 32767[Word] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:809 mod[compile-time] -32767[Integer], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:810 mod[Integer] -32767[Integer], 32768[Word] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -32767

code auto:811 mod[compile-time] -32767[Integer], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 32768;
endcode
varvalue r -32767

$overflow on
code auto:812 mod[Integer] -32767[Integer], 65535[Word] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -32767

code auto:813 mod[compile-time] -32767[Integer], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 65535;
endcode
varvalue r -32767

$overflow on
code auto:814 mod[Integer] -129[Integer], 0[Word] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:815 mod[compile-time] -129[Integer], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 0;
endcode
compile error

$overflow on
code auto:816 mod[Integer] -129[Integer], 255[Word] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -129

code auto:817 mod[compile-time] -129[Integer], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 255;
endcode
varvalue r -129

$overflow on
code auto:818 mod[Integer] -129[Integer], 32767[Word] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -129

code auto:819 mod[compile-time] -129[Integer], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 32767;
endcode
varvalue r -129

$overflow on
code auto:820 mod[Integer] -129[Integer], 32768[Word] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -129

code auto:821 mod[compile-time] -129[Integer], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 32768;
endcode
varvalue r -129

$overflow on
code auto:822 mod[Integer] -129[Integer], 65535[Word] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -129

code auto:823 mod[compile-time] -129[Integer], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 65535;
endcode
varvalue r -129

$overflow on
code auto:824 mod[Integer] -128[Integer], 0[Word] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:825 mod[compile-time] -128[Integer], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:826 mod[Integer] -128[Integer], 255[Word] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:827 mod[compile-time] -128[Integer], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 255;
endcode
varvalue r -128

$overflow on
code auto:828 mod[Integer] -128[Integer], 32767[Word] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:829 mod[compile-time] -128[Integer], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 32767;
endcode
varvalue r -128

$overflow on
code auto:830 mod[Integer] -128[Integer], 32768[Word] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:831 mod[compile-time] -128[Integer], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 32768;
endcode
varvalue r -128

$overflow on
code auto:832 mod[Integer] -128[Integer], 65535[Word] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:833 mod[compile-time] -128[Integer], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 65535;
endcode
varvalue r -128

$overflow on
code auto:834 mod[Integer] -1[Integer], 0[Word] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:835 mod[compile-time] -1[Integer], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:836 mod[Integer] -1[Integer], 255[Word] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:837 mod[compile-time] -1[Integer], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 255;
endcode
varvalue r -1

$overflow on
code auto:838 mod[Integer] -1[Integer], 32767[Word] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:839 mod[compile-time] -1[Integer], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 32767;
endcode
varvalue r -1

$overflow on
code auto:840 mod[Integer] -1[Integer], 32768[Word] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:841 mod[compile-time] -1[Integer], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 32768;
endcode
varvalue r -1

$overflow on
code auto:842 mod[Integer] -1[Integer], 65535[Word] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:843 mod[compile-time] -1[Integer], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 65535;
endcode
varvalue r -1

$overflow on
code auto:844 mod[Integer] 0[Integer], 0[Word] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:845 mod[compile-time] 0[Integer], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:846 mod[Integer] 0[Integer], 255[Word] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:847 mod[compile-time] 0[Integer], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:848 mod[Integer] 0[Integer], 32767[Word] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:849 mod[compile-time] 0[Integer], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:850 mod[Integer] 0[Integer], 32768[Word] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:851 mod[compile-time] 0[Integer], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:852 mod[Integer] 0[Integer], 65535[Word] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:853 mod[compile-time] 0[Integer], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:854 mod[Integer] 1[Integer], 0[Word] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:855 mod[compile-time] 1[Integer], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:856 mod[Integer] 1[Integer], 255[Word] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:857 mod[compile-time] 1[Integer], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow on
code auto:858 mod[Integer] 1[Integer], 32767[Word] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:859 mod[compile-time] 1[Integer], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:860 mod[Integer] 1[Integer], 32768[Word] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:861 mod[compile-time] 1[Integer], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 32768;
endcode
varvalue r 1

$overflow on
code auto:862 mod[Integer] 1[Integer], 65535[Word] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:863 mod[compile-time] 1[Integer], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 65535;
endcode
varvalue r 1

$overflow on
code auto:864 mod[Integer] 127[Integer], 0[Word] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:865 mod[compile-time] 127[Integer], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:866 mod[Integer] 127[Integer], 255[Word] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:867 mod[compile-time] 127[Integer], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow on
code auto:868 mod[Integer] 127[Integer], 32767[Word] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:869 mod[compile-time] 127[Integer], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow on
code auto:870 mod[Integer] 127[Integer], 32768[Word] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:871 mod[compile-time] 127[Integer], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 32768;
endcode
varvalue r 127

$overflow on
code auto:872 mod[Integer] 127[Integer], 65535[Word] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:873 mod[compile-time] 127[Integer], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 65535;
endcode
varvalue r 127

$overflow on
code auto:874 mod[Integer] 128[Integer], 0[Word] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:875 mod[compile-time] 128[Integer], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:876 mod[Integer] 128[Integer], 255[Word] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:877 mod[compile-time] 128[Integer], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 255;
endcode
varvalue r 128

$overflow on
code auto:878 mod[Integer] 128[Integer], 32767[Word] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:879 mod[compile-time] 128[Integer], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 32767;
endcode
varvalue r 128

$overflow on
code auto:880 mod[Integer] 128[Integer], 32768[Word] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:881 mod[compile-time] 128[Integer], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 32768;
endcode
varvalue r 128

$overflow on
code auto:882 mod[Integer] 128[Integer], 65535[Word] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:883 mod[compile-time] 128[Integer], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 65535;
endcode
varvalue r 128

$overflow on
code auto:884 mod[Integer] 32767[Integer], 0[Word] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:885 mod[compile-time] 32767[Integer], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:886 mod[Integer] 32767[Integer], 255[Word] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:887 mod[compile-time] 32767[Integer], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow on
code auto:888 mod[Integer] 32767[Integer], 32767[Word] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:889 mod[compile-time] 32767[Integer], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:890 mod[Integer] 32767[Integer], 32768[Word] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 32767

code auto:891 mod[compile-time] 32767[Integer], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 32768;
endcode
varvalue r 32767

$overflow on
code auto:892 mod[Integer] 32767[Integer], 65535[Word] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 32767

code auto:893 mod[compile-time] 32767[Integer], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 65535;
endcode
varvalue r 32767

$overflow on
code auto:894 mod[Pointer] -32768[Integer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:895 mod[compile-time] -32768[Integer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -32768 mod 0;
endcode
compile error

$overflow on
code auto:896 mod[Pointer] -32768[Integer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:897 mod[compile-time] -32768[Integer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -32768 mod 255;
endcode
compile error

$overflow on
code auto:898 mod[Pointer] -32768[Integer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:899 mod[compile-time] -32768[Integer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -32768 mod 32767;
endcode
compile error

$overflow on
code auto:900 mod[Pointer] -32768[Integer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:901 mod[compile-time] -32768[Integer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -32768 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:902 mod[Pointer] -32768[Integer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:903 mod[compile-time] -32768[Integer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -32768 mod 65535;
endcode
compile error

$overflow on
code auto:904 mod[Pointer] -32767[Integer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:905 mod[compile-time] -32767[Integer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -32767 mod 0;
endcode
compile error

$overflow on
code auto:906 mod[Pointer] -32767[Integer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:907 mod[compile-time] -32767[Integer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -32767 mod 255;
endcode
compile error

$overflow on
code auto:908 mod[Pointer] -32767[Integer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:909 mod[compile-time] -32767[Integer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:910 mod[Pointer] -32767[Integer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:911 mod[compile-time] -32767[Integer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -32767 mod 32768;
endcode
compile error

$overflow on
code auto:912 mod[Pointer] -32767[Integer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:913 mod[compile-time] -32767[Integer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -32767 mod 65535;
endcode
compile error

$overflow on
code auto:914 mod[Pointer] -129[Integer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -129;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:915 mod[compile-time] -129[Integer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -129 mod 0;
endcode
compile error

$overflow on
code auto:916 mod[Pointer] -129[Integer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -129;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:917 mod[compile-time] -129[Integer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -129 mod 255;
endcode
compile error

$overflow on
code auto:918 mod[Pointer] -129[Integer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -129;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:919 mod[compile-time] -129[Integer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -129 mod 32767;
endcode
compile error

$overflow on
code auto:920 mod[Pointer] -129[Integer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -129;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:921 mod[compile-time] -129[Integer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -129 mod 32768;
endcode
compile error

$overflow on
code auto:922 mod[Pointer] -129[Integer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -129;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:923 mod[compile-time] -129[Integer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -129 mod 65535;
endcode
compile error

$overflow on
code auto:924 mod[Pointer] -128[Integer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -128;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:925 mod[compile-time] -128[Integer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:926 mod[Pointer] -128[Integer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -128;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:927 mod[compile-time] -128[Integer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -128 mod 255;
endcode
compile error

$overflow on
code auto:928 mod[Pointer] -128[Integer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -128;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:929 mod[compile-time] -128[Integer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -128 mod 32767;
endcode
compile error

$overflow on
code auto:930 mod[Pointer] -128[Integer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -128;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:931 mod[compile-time] -128[Integer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -128 mod 32768;
endcode
compile error

$overflow on
code auto:932 mod[Pointer] -128[Integer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -128;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:933 mod[compile-time] -128[Integer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -128 mod 65535;
endcode
compile error

$overflow on
code auto:934 mod[Pointer] -1[Integer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -1;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:935 mod[compile-time] -1[Integer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:936 mod[Pointer] -1[Integer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -1;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:937 mod[compile-time] -1[Integer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -1 mod 255;
endcode
compile error

$overflow on
code auto:938 mod[Pointer] -1[Integer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -1;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:939 mod[compile-time] -1[Integer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -1 mod 32767;
endcode
compile error

$overflow on
code auto:940 mod[Pointer] -1[Integer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -1;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:941 mod[compile-time] -1[Integer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -1 mod 32768;
endcode
compile error

$overflow on
code auto:942 mod[Pointer] -1[Integer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = -1;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
runtime overflow

code auto:943 mod[compile-time] -1[Integer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := -1 mod 65535;
endcode
compile error

$overflow on
code auto:944 mod[Pointer] 0[Integer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 0;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:945 mod[compile-time] 0[Integer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:946 mod[Pointer] 0[Integer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 0;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:947 mod[compile-time] 0[Integer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:948 mod[Pointer] 0[Integer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 0;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:949 mod[compile-time] 0[Integer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:950 mod[Pointer] 0[Integer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 0;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:951 mod[compile-time] 0[Integer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:952 mod[Pointer] 0[Integer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 0;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:953 mod[compile-time] 0[Integer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:954 mod[Pointer] 1[Integer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 1;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:955 mod[compile-time] 1[Integer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:956 mod[Pointer] 1[Integer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 1;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:957 mod[compile-time] 1[Integer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow on
code auto:958 mod[Pointer] 1[Integer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 1;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:959 mod[compile-time] 1[Integer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:960 mod[Pointer] 1[Integer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 1;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:961 mod[compile-time] 1[Integer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 32768;
endcode
varvalue r 1

$overflow on
code auto:962 mod[Pointer] 1[Integer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 1;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:963 mod[compile-time] 1[Integer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 65535;
endcode
varvalue r 1

$overflow on
code auto:964 mod[Pointer] 127[Integer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 127;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:965 mod[compile-time] 127[Integer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:966 mod[Pointer] 127[Integer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 127;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:967 mod[compile-time] 127[Integer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow on
code auto:968 mod[Pointer] 127[Integer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 127;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:969 mod[compile-time] 127[Integer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow on
code auto:970 mod[Pointer] 127[Integer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 127;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:971 mod[compile-time] 127[Integer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 32768;
endcode
varvalue r 127

$overflow on
code auto:972 mod[Pointer] 127[Integer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 127;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:973 mod[compile-time] 127[Integer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 65535;
endcode
varvalue r 127

$overflow on
code auto:974 mod[Pointer] 128[Integer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 128;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:975 mod[compile-time] 128[Integer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:976 mod[Pointer] 128[Integer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 128;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 128

code auto:977 mod[compile-time] 128[Integer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 128 mod 255;
endcode
varvalue r 128

$overflow on
code auto:978 mod[Pointer] 128[Integer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 128;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 128

code auto:979 mod[compile-time] 128[Integer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 128 mod 32767;
endcode
varvalue r 128

$overflow on
code auto:980 mod[Pointer] 128[Integer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 128;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 128

code auto:981 mod[compile-time] 128[Integer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 128 mod 32768;
endcode
varvalue r 128

$overflow on
code auto:982 mod[Pointer] 128[Integer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 128;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 128

code auto:983 mod[compile-time] 128[Integer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 128 mod 65535;
endcode
varvalue r 128

$overflow on
code auto:984 mod[Pointer] 32767[Integer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:985 mod[compile-time] 32767[Integer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:986 mod[Pointer] 32767[Integer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:987 mod[compile-time] 32767[Integer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow on
code auto:988 mod[Pointer] 32767[Integer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:989 mod[compile-time] 32767[Integer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:990 mod[Pointer] 32767[Integer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:991 mod[compile-time] 32767[Integer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 32768;
endcode
varvalue r 32767

$overflow on
code auto:992 mod[Pointer] 32767[Integer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:993 mod[compile-time] 32767[Integer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 65535;
endcode
varvalue r 32767

$overflow on
code auto:994 mod[Integer] 0[Byte], -128[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:995 mod[compile-time] 0[Byte], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow on
code auto:996 mod[Integer] 0[Byte], -127[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:997 mod[compile-time] 0[Byte], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -127;
endcode
varvalue r 0

$overflow on
code auto:998 mod[Integer] 0[Byte], -1[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:999 mod[compile-time] 0[Byte], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1000 mod[Integer] 0[Byte], 0[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1001 mod[compile-time] 0[Byte], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1002 mod[Integer] 0[Byte], 1[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1003 mod[compile-time] 0[Byte], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1004 mod[Integer] 0[Byte], 127[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1005 mod[compile-time] 0[Byte], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1006 mod[Integer] 1[Byte], -128[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1007 mod[compile-time] 1[Byte], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow on
code auto:1008 mod[Integer] 1[Byte], -127[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1009 mod[compile-time] 1[Byte], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -127;
endcode
varvalue r 1

$overflow on
code auto:1010 mod[Integer] 1[Byte], -1[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1011 mod[compile-time] 1[Byte], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1012 mod[Integer] 1[Byte], 0[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1013 mod[compile-time] 1[Byte], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:1014 mod[Integer] 1[Byte], 1[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1015 mod[compile-time] 1[Byte], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1016 mod[Integer] 1[Byte], 127[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1017 mod[compile-time] 1[Byte], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1018 mod[Integer] 127[Byte], -128[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1019 mod[compile-time] 127[Byte], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1020 mod[Integer] 127[Byte], -127[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1021 mod[compile-time] 127[Byte], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -127;
endcode
varvalue r 0

$overflow on
code auto:1022 mod[Integer] 127[Byte], -1[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1023 mod[compile-time] 127[Byte], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1024 mod[Integer] 127[Byte], 0[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1025 mod[compile-time] 127[Byte], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:1026 mod[Integer] 127[Byte], 1[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1027 mod[compile-time] 127[Byte], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1028 mod[Integer] 127[Byte], 127[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1029 mod[compile-time] 127[Byte], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1030 mod[Integer] 128[Byte], -128[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1031 mod[compile-time] 128[Byte], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1032 mod[Integer] 128[Byte], -127[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1033 mod[compile-time] 128[Byte], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -127;
endcode
varvalue r 1

$overflow on
code auto:1034 mod[Integer] 128[Byte], -1[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1035 mod[compile-time] 128[Byte], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1036 mod[Integer] 128[Byte], 0[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1037 mod[compile-time] 128[Byte], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:1038 mod[Integer] 128[Byte], 1[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1039 mod[compile-time] 128[Byte], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1040 mod[Integer] 128[Byte], 127[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1041 mod[compile-time] 128[Byte], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1042 mod[Integer] 255[Byte], -128[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1043 mod[compile-time] 255[Byte], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1044 mod[Integer] 255[Byte], -127[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1045 mod[compile-time] 255[Byte], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -127;
endcode
varvalue r 1

$overflow on
code auto:1046 mod[Integer] 255[Byte], -1[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1047 mod[compile-time] 255[Byte], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1048 mod[Integer] 255[Byte], 0[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1049 mod[compile-time] 255[Byte], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1050 mod[Integer] 255[Byte], 1[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1051 mod[compile-time] 255[Byte], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1052 mod[Integer] 255[Byte], 127[Int8] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1053 mod[compile-time] 255[Byte], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1054 mod[Integer] 0[Byte], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1055 mod[compile-time] 0[Byte], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -32768;
endcode
varvalue r 0

$overflow on
code auto:1056 mod[Integer] 0[Byte], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1057 mod[compile-time] 0[Byte], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -32767;
endcode
varvalue r 0

$overflow on
code auto:1058 mod[Integer] 0[Byte], -129[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1059 mod[compile-time] 0[Byte], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -129;
endcode
varvalue r 0

$overflow on
code auto:1060 mod[Integer] 0[Byte], -128[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1061 mod[compile-time] 0[Byte], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1062 mod[Integer] 0[Byte], -1[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1063 mod[compile-time] 0[Byte], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1064 mod[Integer] 0[Byte], 0[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1065 mod[compile-time] 0[Byte], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1066 mod[Integer] 0[Byte], 1[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1067 mod[compile-time] 0[Byte], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1068 mod[Integer] 0[Byte], 127[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1069 mod[compile-time] 0[Byte], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1070 mod[Integer] 0[Byte], 128[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1071 mod[compile-time] 0[Byte], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow on
code auto:1072 mod[Integer] 0[Byte], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1073 mod[compile-time] 0[Byte], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1074 mod[Integer] 1[Byte], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1075 mod[compile-time] 1[Byte], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -32768;
endcode
varvalue r 1

$overflow on
code auto:1076 mod[Integer] 1[Byte], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1077 mod[compile-time] 1[Byte], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -32767;
endcode
varvalue r 1

$overflow on
code auto:1078 mod[Integer] 1[Byte], -129[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1079 mod[compile-time] 1[Byte], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -129;
endcode
varvalue r 1

$overflow on
code auto:1080 mod[Integer] 1[Byte], -128[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1081 mod[compile-time] 1[Byte], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow on
code auto:1082 mod[Integer] 1[Byte], -1[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1083 mod[compile-time] 1[Byte], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1084 mod[Integer] 1[Byte], 0[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1085 mod[compile-time] 1[Byte], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:1086 mod[Integer] 1[Byte], 1[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1087 mod[compile-time] 1[Byte], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1088 mod[Integer] 1[Byte], 127[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1089 mod[compile-time] 1[Byte], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1090 mod[Integer] 1[Byte], 128[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1091 mod[compile-time] 1[Byte], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow on
code auto:1092 mod[Integer] 1[Byte], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1093 mod[compile-time] 1[Byte], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1094 mod[Integer] 127[Byte], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1095 mod[compile-time] 127[Byte], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -32768;
endcode
varvalue r 127

$overflow on
code auto:1096 mod[Integer] 127[Byte], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1097 mod[compile-time] 127[Byte], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -32767;
endcode
varvalue r 127

$overflow on
code auto:1098 mod[Integer] 127[Byte], -129[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1099 mod[compile-time] 127[Byte], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -129;
endcode
varvalue r 127

$overflow on
code auto:1100 mod[Integer] 127[Byte], -128[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1101 mod[compile-time] 127[Byte], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1102 mod[Integer] 127[Byte], -1[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1103 mod[compile-time] 127[Byte], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1104 mod[Integer] 127[Byte], 0[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1105 mod[compile-time] 127[Byte], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:1106 mod[Integer] 127[Byte], 1[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1107 mod[compile-time] 127[Byte], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1108 mod[Integer] 127[Byte], 127[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1109 mod[compile-time] 127[Byte], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1110 mod[Integer] 127[Byte], 128[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1111 mod[compile-time] 127[Byte], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1112 mod[Integer] 127[Byte], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1113 mod[compile-time] 127[Byte], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow on
code auto:1114 mod[Integer] 128[Byte], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:1115 mod[compile-time] 128[Byte], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -32768;
endcode
varvalue r 128

$overflow on
code auto:1116 mod[Integer] 128[Byte], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:1117 mod[compile-time] 128[Byte], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -32767;
endcode
varvalue r 128

$overflow on
code auto:1118 mod[Integer] 128[Byte], -129[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:1119 mod[compile-time] 128[Byte], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -129;
endcode
varvalue r 128

$overflow on
code auto:1120 mod[Integer] 128[Byte], -128[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1121 mod[compile-time] 128[Byte], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1122 mod[Integer] 128[Byte], -1[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1123 mod[compile-time] 128[Byte], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1124 mod[Integer] 128[Byte], 0[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1125 mod[compile-time] 128[Byte], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:1126 mod[Integer] 128[Byte], 1[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1127 mod[compile-time] 128[Byte], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1128 mod[Integer] 128[Byte], 127[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1129 mod[compile-time] 128[Byte], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1130 mod[Integer] 128[Byte], 128[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1131 mod[compile-time] 128[Byte], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 128;
endcode
varvalue r 0

$overflow on
code auto:1132 mod[Integer] 128[Byte], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:1133 mod[compile-time] 128[Byte], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 32767;
endcode
varvalue r 128

$overflow on
code auto:1134 mod[Integer] 255[Byte], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 255

code auto:1135 mod[compile-time] 255[Byte], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -32768;
endcode
varvalue r 255

$overflow on
code auto:1136 mod[Integer] 255[Byte], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 255

code auto:1137 mod[compile-time] 255[Byte], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -32767;
endcode
varvalue r 255

$overflow on
code auto:1138 mod[Integer] 255[Byte], -129[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 126

code auto:1139 mod[compile-time] 255[Byte], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -129;
endcode
varvalue r 126

$overflow on
code auto:1140 mod[Integer] 255[Byte], -128[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1141 mod[compile-time] 255[Byte], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1142 mod[Integer] 255[Byte], -1[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1143 mod[compile-time] 255[Byte], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1144 mod[Integer] 255[Byte], 0[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1145 mod[compile-time] 255[Byte], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1146 mod[Integer] 255[Byte], 1[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1147 mod[compile-time] 255[Byte], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1148 mod[Integer] 255[Byte], 127[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1149 mod[compile-time] 255[Byte], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1150 mod[Integer] 255[Byte], 128[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1151 mod[compile-time] 255[Byte], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1152 mod[Integer] 255[Byte], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 255

code auto:1153 mod[compile-time] 255[Byte], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow on
code auto:1154 mod[Byte] 0[Byte], 0[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1155 mod[compile-time] 0[Byte], 0[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1156 mod[Byte] 0[Byte], 1[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:1157 mod[compile-time] 0[Byte], 1[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1158 mod[Byte] 0[Byte], 127[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:1159 mod[compile-time] 0[Byte], 127[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1160 mod[Byte] 0[Byte], 128[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:1161 mod[compile-time] 0[Byte], 128[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow on
code auto:1162 mod[Byte] 0[Byte], 255[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:1163 mod[compile-time] 0[Byte], 255[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1164 mod[Byte] 1[Byte], 0[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1165 mod[compile-time] 1[Byte], 0[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:1166 mod[Byte] 1[Byte], 1[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:1167 mod[compile-time] 1[Byte], 1[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1168 mod[Byte] 1[Byte], 127[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:1169 mod[compile-time] 1[Byte], 127[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1170 mod[Byte] 1[Byte], 128[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:1171 mod[compile-time] 1[Byte], 128[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow on
code auto:1172 mod[Byte] 1[Byte], 255[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:1173 mod[compile-time] 1[Byte], 255[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow on
code auto:1174 mod[Byte] 127[Byte], 0[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1175 mod[compile-time] 127[Byte], 0[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:1176 mod[Byte] 127[Byte], 1[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:1177 mod[compile-time] 127[Byte], 1[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1178 mod[Byte] 127[Byte], 127[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:1179 mod[compile-time] 127[Byte], 127[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1180 mod[Byte] 127[Byte], 128[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:1181 mod[compile-time] 127[Byte], 128[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1182 mod[Byte] 127[Byte], 255[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:1183 mod[compile-time] 127[Byte], 255[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow on
code auto:1184 mod[Byte] 128[Byte], 0[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1185 mod[compile-time] 128[Byte], 0[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:1186 mod[Byte] 128[Byte], 1[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:1187 mod[compile-time] 128[Byte], 1[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1188 mod[Byte] 128[Byte], 127[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:1189 mod[compile-time] 128[Byte], 127[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1190 mod[Byte] 128[Byte], 128[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:1191 mod[compile-time] 128[Byte], 128[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 128;
endcode
varvalue r 0

$overflow on
code auto:1192 mod[Byte] 128[Byte], 255[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 128

code auto:1193 mod[compile-time] 128[Byte], 255[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 255;
endcode
varvalue r 128

$overflow on
code auto:1194 mod[Byte] 255[Byte], 0[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1195 mod[compile-time] 255[Byte], 0[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1196 mod[Byte] 255[Byte], 1[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:1197 mod[compile-time] 255[Byte], 1[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1198 mod[Byte] 255[Byte], 127[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:1199 mod[compile-time] 255[Byte], 127[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1200 mod[Byte] 255[Byte], 128[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:1201 mod[compile-time] 255[Byte], 128[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1202 mod[Byte] 255[Byte], 255[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:1203 mod[compile-time] 255[Byte], 255[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1204 mod[Word] 0[Byte], 0[Word] -> [Word] Var $overflow on
  var  a: Byte = 0;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1205 mod[compile-time] 0[Byte], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1206 mod[Word] 0[Byte], 255[Word] -> [Word] Var $overflow on
  var  a: Byte = 0;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1207 mod[compile-time] 0[Byte], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1208 mod[Word] 0[Byte], 32767[Word] -> [Word] Var $overflow on
  var  a: Byte = 0;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1209 mod[compile-time] 0[Byte], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1210 mod[Word] 0[Byte], 32768[Word] -> [Word] Var $overflow on
  var  a: Byte = 0;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1211 mod[compile-time] 0[Byte], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:1212 mod[Word] 0[Byte], 65535[Word] -> [Word] Var $overflow on
  var  a: Byte = 0;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1213 mod[compile-time] 0[Byte], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:1214 mod[Word] 1[Byte], 0[Word] -> [Word] Var $overflow on
  var  a: Byte = 1;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1215 mod[compile-time] 1[Byte], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:1216 mod[Word] 1[Byte], 255[Word] -> [Word] Var $overflow on
  var  a: Byte = 1;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:1217 mod[compile-time] 1[Byte], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow on
code auto:1218 mod[Word] 1[Byte], 32767[Word] -> [Word] Var $overflow on
  var  a: Byte = 1;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:1219 mod[compile-time] 1[Byte], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1220 mod[Word] 1[Byte], 32768[Word] -> [Word] Var $overflow on
  var  a: Byte = 1;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:1221 mod[compile-time] 1[Byte], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 32768;
endcode
varvalue r 1

$overflow on
code auto:1222 mod[Word] 1[Byte], 65535[Word] -> [Word] Var $overflow on
  var  a: Byte = 1;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:1223 mod[compile-time] 1[Byte], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 65535;
endcode
varvalue r 1

$overflow on
code auto:1224 mod[Word] 127[Byte], 0[Word] -> [Word] Var $overflow on
  var  a: Byte = 127;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1225 mod[compile-time] 127[Byte], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:1226 mod[Word] 127[Byte], 255[Word] -> [Word] Var $overflow on
  var  a: Byte = 127;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:1227 mod[compile-time] 127[Byte], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow on
code auto:1228 mod[Word] 127[Byte], 32767[Word] -> [Word] Var $overflow on
  var  a: Byte = 127;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:1229 mod[compile-time] 127[Byte], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow on
code auto:1230 mod[Word] 127[Byte], 32768[Word] -> [Word] Var $overflow on
  var  a: Byte = 127;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:1231 mod[compile-time] 127[Byte], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 32768;
endcode
varvalue r 127

$overflow on
code auto:1232 mod[Word] 127[Byte], 65535[Word] -> [Word] Var $overflow on
  var  a: Byte = 127;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:1233 mod[compile-time] 127[Byte], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 65535;
endcode
varvalue r 127

$overflow on
code auto:1234 mod[Word] 128[Byte], 0[Word] -> [Word] Var $overflow on
  var  a: Byte = 128;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1235 mod[compile-time] 128[Byte], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:1236 mod[Word] 128[Byte], 255[Word] -> [Word] Var $overflow on
  var  a: Byte = 128;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:1237 mod[compile-time] 128[Byte], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 255;
endcode
varvalue r 128

$overflow on
code auto:1238 mod[Word] 128[Byte], 32767[Word] -> [Word] Var $overflow on
  var  a: Byte = 128;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:1239 mod[compile-time] 128[Byte], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 32767;
endcode
varvalue r 128

$overflow on
code auto:1240 mod[Word] 128[Byte], 32768[Word] -> [Word] Var $overflow on
  var  a: Byte = 128;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:1241 mod[compile-time] 128[Byte], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 32768;
endcode
varvalue r 128

$overflow on
code auto:1242 mod[Word] 128[Byte], 65535[Word] -> [Word] Var $overflow on
  var  a: Byte = 128;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:1243 mod[compile-time] 128[Byte], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 65535;
endcode
varvalue r 128

$overflow on
code auto:1244 mod[Word] 255[Byte], 0[Word] -> [Word] Var $overflow on
  var  a: Byte = 255;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1245 mod[compile-time] 255[Byte], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1246 mod[Word] 255[Byte], 255[Word] -> [Word] Var $overflow on
  var  a: Byte = 255;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1247 mod[compile-time] 255[Byte], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1248 mod[Word] 255[Byte], 32767[Word] -> [Word] Var $overflow on
  var  a: Byte = 255;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 255

code auto:1249 mod[compile-time] 255[Byte], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow on
code auto:1250 mod[Word] 255[Byte], 32768[Word] -> [Word] Var $overflow on
  var  a: Byte = 255;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 255

code auto:1251 mod[compile-time] 255[Byte], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 32768;
endcode
varvalue r 255

$overflow on
code auto:1252 mod[Word] 255[Byte], 65535[Word] -> [Word] Var $overflow on
  var  a: Byte = 255;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 255

code auto:1253 mod[compile-time] 255[Byte], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 65535;
endcode
varvalue r 255

$overflow on
code auto:1254 mod[Pointer] 0[Byte], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 0;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1255 mod[compile-time] 0[Byte], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1256 mod[Pointer] 0[Byte], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 0;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1257 mod[compile-time] 0[Byte], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1258 mod[Pointer] 0[Byte], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 0;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1259 mod[compile-time] 0[Byte], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1260 mod[Pointer] 0[Byte], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 0;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1261 mod[compile-time] 0[Byte], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:1262 mod[Pointer] 0[Byte], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 0;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1263 mod[compile-time] 0[Byte], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:1264 mod[Pointer] 1[Byte], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 1;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1265 mod[compile-time] 1[Byte], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:1266 mod[Pointer] 1[Byte], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 1;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1267 mod[compile-time] 1[Byte], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow on
code auto:1268 mod[Pointer] 1[Byte], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 1;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1269 mod[compile-time] 1[Byte], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1270 mod[Pointer] 1[Byte], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 1;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1271 mod[compile-time] 1[Byte], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 32768;
endcode
varvalue r 1

$overflow on
code auto:1272 mod[Pointer] 1[Byte], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 1;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1273 mod[compile-time] 1[Byte], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 1 mod 65535;
endcode
varvalue r 1

$overflow on
code auto:1274 mod[Pointer] 127[Byte], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 127;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1275 mod[compile-time] 127[Byte], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:1276 mod[Pointer] 127[Byte], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 127;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1277 mod[compile-time] 127[Byte], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow on
code auto:1278 mod[Pointer] 127[Byte], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 127;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1279 mod[compile-time] 127[Byte], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow on
code auto:1280 mod[Pointer] 127[Byte], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 127;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1281 mod[compile-time] 127[Byte], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 32768;
endcode
varvalue r 127

$overflow on
code auto:1282 mod[Pointer] 127[Byte], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 127;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1283 mod[compile-time] 127[Byte], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 127 mod 65535;
endcode
varvalue r 127

$overflow on
code auto:1284 mod[Pointer] 128[Byte], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 128;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1285 mod[compile-time] 128[Byte], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:1286 mod[Pointer] 128[Byte], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 128;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 128

code auto:1287 mod[compile-time] 128[Byte], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 128 mod 255;
endcode
varvalue r 128

$overflow on
code auto:1288 mod[Pointer] 128[Byte], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 128;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 128

code auto:1289 mod[compile-time] 128[Byte], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 128 mod 32767;
endcode
varvalue r 128

$overflow on
code auto:1290 mod[Pointer] 128[Byte], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 128;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 128

code auto:1291 mod[compile-time] 128[Byte], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 128 mod 32768;
endcode
varvalue r 128

$overflow on
code auto:1292 mod[Pointer] 128[Byte], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 128;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 128

code auto:1293 mod[compile-time] 128[Byte], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 128 mod 65535;
endcode
varvalue r 128

$overflow on
code auto:1294 mod[Pointer] 255[Byte], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 255;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1295 mod[compile-time] 255[Byte], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1296 mod[Pointer] 255[Byte], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 255;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1297 mod[compile-time] 255[Byte], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1298 mod[Pointer] 255[Byte], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 255;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1299 mod[compile-time] 255[Byte], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow on
code auto:1300 mod[Pointer] 255[Byte], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 255;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1301 mod[compile-time] 255[Byte], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 32768;
endcode
varvalue r 255

$overflow on
code auto:1302 mod[Pointer] 255[Byte], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Byte = 255;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1303 mod[compile-time] 255[Byte], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 65535;
endcode
varvalue r 255

$overflow on
code auto:1304 mod[Integer] 0[Word], -128[Int8] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1305 mod[compile-time] 0[Word], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1306 mod[Integer] 0[Word], -127[Int8] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1307 mod[compile-time] 0[Word], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -127;
endcode
varvalue r 0

$overflow on
code auto:1308 mod[Integer] 0[Word], -1[Int8] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1309 mod[compile-time] 0[Word], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1310 mod[Integer] 0[Word], 0[Int8] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1311 mod[compile-time] 0[Word], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1312 mod[Integer] 0[Word], 1[Int8] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1313 mod[compile-time] 0[Word], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1314 mod[Integer] 0[Word], 127[Int8] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1315 mod[compile-time] 0[Word], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1316 mod[Integer] 255[Word], -128[Int8] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1317 mod[compile-time] 255[Word], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1318 mod[Integer] 255[Word], -127[Int8] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1319 mod[compile-time] 255[Word], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -127;
endcode
varvalue r 1

$overflow on
code auto:1320 mod[Integer] 255[Word], -1[Int8] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1321 mod[compile-time] 255[Word], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1322 mod[Integer] 255[Word], 0[Int8] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1323 mod[compile-time] 255[Word], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1324 mod[Integer] 255[Word], 1[Int8] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1325 mod[compile-time] 255[Word], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1326 mod[Integer] 255[Word], 127[Int8] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1327 mod[compile-time] 255[Word], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1328 mod[Integer] 32767[Word], -128[Int8] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1329 mod[compile-time] 32767[Word], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1330 mod[Integer] 32767[Word], -127[Int8] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1331 mod[compile-time] 32767[Word], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -127;
endcode
varvalue r 1

$overflow on
code auto:1332 mod[Integer] 32767[Word], -1[Int8] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1333 mod[compile-time] 32767[Word], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1334 mod[Integer] 32767[Word], 0[Int8] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1335 mod[compile-time] 32767[Word], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:1336 mod[Integer] 32767[Word], 1[Int8] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1337 mod[compile-time] 32767[Word], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1338 mod[Integer] 32767[Word], 127[Int8] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1339 mod[compile-time] 32767[Word], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1340 mod[Integer] 32768[Word], -128[Int8] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1341 mod[compile-time] 32768[Word], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1342 mod[Integer] 32768[Word], -127[Int8] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 2

code auto:1343 mod[compile-time] 32768[Word], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod -127;
endcode
varvalue r 2

$overflow on
code auto:1344 mod[Integer] 32768[Word], -1[Int8] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1345 mod[compile-time] 32768[Word], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1346 mod[Integer] 32768[Word], 0[Int8] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1347 mod[compile-time] 32768[Word], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:1348 mod[Integer] 32768[Word], 1[Int8] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1349 mod[compile-time] 32768[Word], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1350 mod[Integer] 32768[Word], 127[Int8] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 2

code auto:1351 mod[compile-time] 32768[Word], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 127;
endcode
varvalue r 2

$overflow on
code auto:1352 mod[Integer] 65535[Word], -128[Int8] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1353 mod[compile-time] 65535[Word], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1354 mod[Integer] 65535[Word], -127[Int8] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 3

code auto:1355 mod[compile-time] 65535[Word], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod -127;
endcode
varvalue r 3

$overflow on
code auto:1356 mod[Integer] 65535[Word], -1[Int8] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1357 mod[compile-time] 65535[Word], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1358 mod[Integer] 65535[Word], 0[Int8] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1359 mod[compile-time] 65535[Word], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:1360 mod[Integer] 65535[Word], 1[Int8] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1361 mod[compile-time] 65535[Word], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1362 mod[Integer] 65535[Word], 127[Int8] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 3

code auto:1363 mod[compile-time] 65535[Word], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 127;
endcode
varvalue r 3

$overflow on
code auto:1364 mod[Integer] 0[Word], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1365 mod[compile-time] 0[Word], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -32768;
endcode
varvalue r 0

$overflow on
code auto:1366 mod[Integer] 0[Word], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1367 mod[compile-time] 0[Word], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -32767;
endcode
varvalue r 0

$overflow on
code auto:1368 mod[Integer] 0[Word], -129[Integer] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1369 mod[compile-time] 0[Word], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -129;
endcode
varvalue r 0

$overflow on
code auto:1370 mod[Integer] 0[Word], -128[Integer] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1371 mod[compile-time] 0[Word], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1372 mod[Integer] 0[Word], -1[Integer] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1373 mod[compile-time] 0[Word], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1374 mod[Integer] 0[Word], 0[Integer] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1375 mod[compile-time] 0[Word], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1376 mod[Integer] 0[Word], 1[Integer] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1377 mod[compile-time] 0[Word], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1378 mod[Integer] 0[Word], 127[Integer] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1379 mod[compile-time] 0[Word], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1380 mod[Integer] 0[Word], 128[Integer] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1381 mod[compile-time] 0[Word], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow on
code auto:1382 mod[Integer] 0[Word], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1383 mod[compile-time] 0[Word], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1384 mod[Integer] 255[Word], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 255

code auto:1385 mod[compile-time] 255[Word], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -32768;
endcode
varvalue r 255

$overflow on
code auto:1386 mod[Integer] 255[Word], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 255

code auto:1387 mod[compile-time] 255[Word], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -32767;
endcode
varvalue r 255

$overflow on
code auto:1388 mod[Integer] 255[Word], -129[Integer] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 126

code auto:1389 mod[compile-time] 255[Word], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -129;
endcode
varvalue r 126

$overflow on
code auto:1390 mod[Integer] 255[Word], -128[Integer] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1391 mod[compile-time] 255[Word], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1392 mod[Integer] 255[Word], -1[Integer] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1393 mod[compile-time] 255[Word], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1394 mod[Integer] 255[Word], 0[Integer] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1395 mod[compile-time] 255[Word], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1396 mod[Integer] 255[Word], 1[Integer] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1397 mod[compile-time] 255[Word], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1398 mod[Integer] 255[Word], 127[Integer] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1399 mod[compile-time] 255[Word], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1400 mod[Integer] 255[Word], 128[Integer] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1401 mod[compile-time] 255[Word], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1402 mod[Integer] 255[Word], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 255

code auto:1403 mod[compile-time] 255[Word], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow on
code auto:1404 mod[Integer] 32767[Word], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1405 mod[compile-time] 32767[Word], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -32768;
endcode
varvalue r 32767

$overflow on
code auto:1406 mod[Integer] 32767[Word], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1407 mod[compile-time] 32767[Word], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -32767;
endcode
varvalue r 0

$overflow on
code auto:1408 mod[Integer] 32767[Word], -129[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1409 mod[compile-time] 32767[Word], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -129;
endcode
varvalue r 1

$overflow on
code auto:1410 mod[Integer] 32767[Word], -128[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1411 mod[compile-time] 32767[Word], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1412 mod[Integer] 32767[Word], -1[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1413 mod[compile-time] 32767[Word], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1414 mod[Integer] 32767[Word], 0[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1415 mod[compile-time] 32767[Word], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:1416 mod[Integer] 32767[Word], 1[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1417 mod[compile-time] 32767[Word], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1418 mod[Integer] 32767[Word], 127[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1419 mod[compile-time] 32767[Word], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1420 mod[Integer] 32767[Word], 128[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1421 mod[compile-time] 32767[Word], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1422 mod[Integer] 32767[Word], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1423 mod[compile-time] 32767[Word], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1424 mod[Integer] 32768[Word], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1425 mod[compile-time] 32768[Word], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod -32768;
endcode
varvalue r 0

$overflow on
code auto:1426 mod[Integer] 32768[Word], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1427 mod[compile-time] 32768[Word], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod -32767;
endcode
varvalue r 1

$overflow on
code auto:1428 mod[Integer] 32768[Word], -129[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 2

code auto:1429 mod[compile-time] 32768[Word], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod -129;
endcode
varvalue r 2

$overflow on
code auto:1430 mod[Integer] 32768[Word], -128[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1431 mod[compile-time] 32768[Word], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1432 mod[Integer] 32768[Word], -1[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1433 mod[compile-time] 32768[Word], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1434 mod[Integer] 32768[Word], 0[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1435 mod[compile-time] 32768[Word], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:1436 mod[Integer] 32768[Word], 1[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1437 mod[compile-time] 32768[Word], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1438 mod[Integer] 32768[Word], 127[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 2

code auto:1439 mod[compile-time] 32768[Word], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 127;
endcode
varvalue r 2

$overflow on
code auto:1440 mod[Integer] 32768[Word], 128[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1441 mod[compile-time] 32768[Word], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 128;
endcode
varvalue r 0

$overflow on
code auto:1442 mod[Integer] 32768[Word], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1443 mod[compile-time] 32768[Word], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1444 mod[Integer] 65535[Word], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1445 mod[compile-time] 65535[Word], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod -32768;
endcode
varvalue r 32767

$overflow on
code auto:1446 mod[Integer] 65535[Word], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1447 mod[compile-time] 65535[Word], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod -32767;
endcode
varvalue r 1

$overflow on
code auto:1448 mod[Integer] 65535[Word], -129[Integer] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 3

code auto:1449 mod[compile-time] 65535[Word], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod -129;
endcode
varvalue r 3

$overflow on
code auto:1450 mod[Integer] 65535[Word], -128[Integer] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1451 mod[compile-time] 65535[Word], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1452 mod[Integer] 65535[Word], -1[Integer] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1453 mod[compile-time] 65535[Word], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1454 mod[Integer] 65535[Word], 0[Integer] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1455 mod[compile-time] 65535[Word], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:1456 mod[Integer] 65535[Word], 1[Integer] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1457 mod[compile-time] 65535[Word], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1458 mod[Integer] 65535[Word], 127[Integer] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 3

code auto:1459 mod[compile-time] 65535[Word], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 127;
endcode
varvalue r 3

$overflow on
code auto:1460 mod[Integer] 65535[Word], 128[Integer] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:1461 mod[compile-time] 65535[Word], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1462 mod[Integer] 65535[Word], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:1463 mod[compile-time] 65535[Word], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1464 mod[Word] 0[Word], 0[Byte] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1465 mod[compile-time] 0[Word], 0[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1466 mod[Word] 0[Word], 1[Byte] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1467 mod[compile-time] 0[Word], 1[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1468 mod[Word] 0[Word], 127[Byte] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1469 mod[compile-time] 0[Word], 127[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1470 mod[Word] 0[Word], 128[Byte] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1471 mod[compile-time] 0[Word], 128[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow on
code auto:1472 mod[Word] 0[Word], 255[Byte] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1473 mod[compile-time] 0[Word], 255[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1474 mod[Word] 255[Word], 0[Byte] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1475 mod[compile-time] 255[Word], 0[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1476 mod[Word] 255[Word], 1[Byte] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1477 mod[compile-time] 255[Word], 1[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1478 mod[Word] 255[Word], 127[Byte] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:1479 mod[compile-time] 255[Word], 127[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1480 mod[Word] 255[Word], 128[Byte] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:1481 mod[compile-time] 255[Word], 128[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1482 mod[Word] 255[Word], 255[Byte] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1483 mod[compile-time] 255[Word], 255[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1484 mod[Word] 32767[Word], 0[Byte] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1485 mod[compile-time] 32767[Word], 0[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:1486 mod[Word] 32767[Word], 1[Byte] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1487 mod[compile-time] 32767[Word], 1[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1488 mod[Word] 32767[Word], 127[Byte] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:1489 mod[compile-time] 32767[Word], 127[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1490 mod[Word] 32767[Word], 128[Byte] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:1491 mod[compile-time] 32767[Word], 128[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1492 mod[Word] 32767[Word], 255[Byte] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:1493 mod[compile-time] 32767[Word], 255[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow on
code auto:1494 mod[Word] 32768[Word], 0[Byte] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1495 mod[compile-time] 32768[Word], 0[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:1496 mod[Word] 32768[Word], 1[Byte] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1497 mod[compile-time] 32768[Word], 1[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1498 mod[Word] 32768[Word], 127[Byte] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 2

code auto:1499 mod[compile-time] 32768[Word], 127[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 127;
endcode
varvalue r 2

$overflow on
code auto:1500 mod[Word] 32768[Word], 128[Byte] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1501 mod[compile-time] 32768[Word], 128[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 128;
endcode
varvalue r 0

$overflow on
code auto:1502 mod[Word] 32768[Word], 255[Byte] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:1503 mod[compile-time] 32768[Word], 255[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 255;
endcode
varvalue r 128

$overflow on
code auto:1504 mod[Word] 65535[Word], 0[Byte] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1505 mod[compile-time] 65535[Word], 0[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:1506 mod[Word] 65535[Word], 1[Byte] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1507 mod[compile-time] 65535[Word], 1[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1508 mod[Word] 65535[Word], 127[Byte] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 3

code auto:1509 mod[compile-time] 65535[Word], 127[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 127;
endcode
varvalue r 3

$overflow on
code auto:1510 mod[Word] 65535[Word], 128[Byte] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:1511 mod[compile-time] 65535[Word], 128[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1512 mod[Word] 65535[Word], 255[Byte] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1513 mod[compile-time] 65535[Word], 255[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1514 mod[Word] 0[Word], 0[Word] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1515 mod[compile-time] 0[Word], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1516 mod[Word] 0[Word], 255[Word] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1517 mod[compile-time] 0[Word], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1518 mod[Word] 0[Word], 32767[Word] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1519 mod[compile-time] 0[Word], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1520 mod[Word] 0[Word], 32768[Word] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1521 mod[compile-time] 0[Word], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:1522 mod[Word] 0[Word], 65535[Word] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1523 mod[compile-time] 0[Word], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:1524 mod[Word] 255[Word], 0[Word] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1525 mod[compile-time] 255[Word], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1526 mod[Word] 255[Word], 255[Word] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1527 mod[compile-time] 255[Word], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1528 mod[Word] 255[Word], 32767[Word] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 255

code auto:1529 mod[compile-time] 255[Word], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow on
code auto:1530 mod[Word] 255[Word], 32768[Word] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 255

code auto:1531 mod[compile-time] 255[Word], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 32768;
endcode
varvalue r 255

$overflow on
code auto:1532 mod[Word] 255[Word], 65535[Word] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 255

code auto:1533 mod[compile-time] 255[Word], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 65535;
endcode
varvalue r 255

$overflow on
code auto:1534 mod[Word] 32767[Word], 0[Word] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1535 mod[compile-time] 32767[Word], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:1536 mod[Word] 32767[Word], 255[Word] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:1537 mod[compile-time] 32767[Word], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow on
code auto:1538 mod[Word] 32767[Word], 32767[Word] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1539 mod[compile-time] 32767[Word], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1540 mod[Word] 32767[Word], 32768[Word] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32767

code auto:1541 mod[compile-time] 32767[Word], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 32768;
endcode
varvalue r 32767

$overflow on
code auto:1542 mod[Word] 32767[Word], 65535[Word] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32767

code auto:1543 mod[compile-time] 32767[Word], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 65535;
endcode
varvalue r 32767

$overflow on
code auto:1544 mod[Word] 32768[Word], 0[Word] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1545 mod[compile-time] 32768[Word], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:1546 mod[Word] 32768[Word], 255[Word] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:1547 mod[compile-time] 32768[Word], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 255;
endcode
varvalue r 128

$overflow on
code auto:1548 mod[Word] 32768[Word], 32767[Word] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:1549 mod[compile-time] 32768[Word], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1550 mod[Word] 32768[Word], 32768[Word] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1551 mod[compile-time] 32768[Word], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:1552 mod[Word] 32768[Word], 65535[Word] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32768

code auto:1553 mod[compile-time] 32768[Word], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 65535;
endcode
varvalue r 32768

$overflow on
code auto:1554 mod[Word] 65535[Word], 0[Word] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1555 mod[compile-time] 65535[Word], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:1556 mod[Word] 65535[Word], 255[Word] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1557 mod[compile-time] 65535[Word], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1558 mod[Word] 65535[Word], 32767[Word] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:1559 mod[compile-time] 65535[Word], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1560 mod[Word] 65535[Word], 32768[Word] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32767

code auto:1561 mod[compile-time] 65535[Word], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 32768;
endcode
varvalue r 32767

$overflow on
code auto:1562 mod[Word] 65535[Word], 65535[Word] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:1563 mod[compile-time] 65535[Word], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:1564 mod[Pointer] 0[Word], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 0;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1565 mod[compile-time] 0[Word], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1566 mod[Pointer] 0[Word], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 0;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1567 mod[compile-time] 0[Word], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1568 mod[Pointer] 0[Word], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 0;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1569 mod[compile-time] 0[Word], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1570 mod[Pointer] 0[Word], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 0;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1571 mod[compile-time] 0[Word], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:1572 mod[Pointer] 0[Word], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 0;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1573 mod[compile-time] 0[Word], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:1574 mod[Pointer] 255[Word], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 255;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1575 mod[compile-time] 255[Word], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1576 mod[Pointer] 255[Word], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 255;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1577 mod[compile-time] 255[Word], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1578 mod[Pointer] 255[Word], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 255;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1579 mod[compile-time] 255[Word], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow on
code auto:1580 mod[Pointer] 255[Word], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 255;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1581 mod[compile-time] 255[Word], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 32768;
endcode
varvalue r 255

$overflow on
code auto:1582 mod[Pointer] 255[Word], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 255;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1583 mod[compile-time] 255[Word], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 65535;
endcode
varvalue r 255

$overflow on
code auto:1584 mod[Pointer] 32767[Word], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 32767;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1585 mod[compile-time] 32767[Word], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:1586 mod[Pointer] 32767[Word], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 32767;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1587 mod[compile-time] 32767[Word], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow on
code auto:1588 mod[Pointer] 32767[Word], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 32767;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1589 mod[compile-time] 32767[Word], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1590 mod[Pointer] 32767[Word], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 32767;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1591 mod[compile-time] 32767[Word], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 32768;
endcode
varvalue r 32767

$overflow on
code auto:1592 mod[Pointer] 32767[Word], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 32767;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1593 mod[compile-time] 32767[Word], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 65535;
endcode
varvalue r 32767

$overflow on
code auto:1594 mod[Pointer] 32768[Word], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 32768;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1595 mod[compile-time] 32768[Word], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:1596 mod[Pointer] 32768[Word], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 32768;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 128

code auto:1597 mod[compile-time] 32768[Word], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 255;
endcode
varvalue r 128

$overflow on
code auto:1598 mod[Pointer] 32768[Word], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 32768;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1599 mod[compile-time] 32768[Word], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1600 mod[Pointer] 32768[Word], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 32768;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1601 mod[compile-time] 32768[Word], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:1602 mod[Pointer] 32768[Word], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 32768;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32768

code auto:1603 mod[compile-time] 32768[Word], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 65535;
endcode
varvalue r 32768

$overflow on
code auto:1604 mod[Pointer] 65535[Word], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 65535;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1605 mod[compile-time] 65535[Word], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:1606 mod[Pointer] 65535[Word], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 65535;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1607 mod[compile-time] 65535[Word], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1608 mod[Pointer] 65535[Word], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 65535;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1609 mod[compile-time] 65535[Word], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1610 mod[Pointer] 65535[Word], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 65535;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1611 mod[compile-time] 65535[Word], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 32768;
endcode
varvalue r 32767

$overflow on
code auto:1612 mod[Pointer] 65535[Word], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Word = 65535;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1613 mod[compile-time] 65535[Word], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:1614 mod[Pointer] 0[Pointer], -128[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Int8 = -128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1615 mod[compile-time] 0[Pointer], -128[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1616 mod[Pointer] 0[Pointer], -127[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Int8 = -127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1617 mod[compile-time] 0[Pointer], -127[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod -127;
endcode
varvalue r 0

$overflow on
code auto:1618 mod[Pointer] 0[Pointer], -1[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Int8 = -1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1619 mod[compile-time] 0[Pointer], -1[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1620 mod[Pointer] 0[Pointer], 0[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Int8 = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1621 mod[compile-time] 0[Pointer], 0[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1622 mod[Pointer] 0[Pointer], 1[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Int8 = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1623 mod[compile-time] 0[Pointer], 1[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1624 mod[Pointer] 0[Pointer], 127[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Int8 = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1625 mod[compile-time] 0[Pointer], 127[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1626 mod[Pointer] 255[Pointer], -128[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Int8 = -128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1627 mod[compile-time] 255[Pointer], -128[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1628 mod[Pointer] 255[Pointer], -127[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Int8 = -127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1629 mod[compile-time] 255[Pointer], -127[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod -127;
endcode
varvalue r 1

$overflow on
code auto:1630 mod[Pointer] 255[Pointer], -1[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Int8 = -1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1631 mod[compile-time] 255[Pointer], -1[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1632 mod[Pointer] 255[Pointer], 0[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Int8 = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1633 mod[compile-time] 255[Pointer], 0[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1634 mod[Pointer] 255[Pointer], 1[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Int8 = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1635 mod[compile-time] 255[Pointer], 1[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1636 mod[Pointer] 255[Pointer], 127[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Int8 = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1637 mod[compile-time] 255[Pointer], 127[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1638 mod[Pointer] 32767[Pointer], -128[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Int8 = -128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1639 mod[compile-time] 32767[Pointer], -128[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1640 mod[Pointer] 32767[Pointer], -127[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Int8 = -127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1641 mod[compile-time] 32767[Pointer], -127[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod -127;
endcode
varvalue r 1

$overflow on
code auto:1642 mod[Pointer] 32767[Pointer], -1[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Int8 = -1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1643 mod[compile-time] 32767[Pointer], -1[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1644 mod[Pointer] 32767[Pointer], 0[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Int8 = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1645 mod[compile-time] 32767[Pointer], 0[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:1646 mod[Pointer] 32767[Pointer], 1[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Int8 = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1647 mod[compile-time] 32767[Pointer], 1[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1648 mod[Pointer] 32767[Pointer], 127[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Int8 = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1649 mod[compile-time] 32767[Pointer], 127[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1650 mod[Pointer] 32768[Pointer], -128[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Int8 = -128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1651 mod[compile-time] 32768[Pointer], -128[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1652 mod[Pointer] 32768[Pointer], -127[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Int8 = -127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 2

code auto:1653 mod[compile-time] 32768[Pointer], -127[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod -127;
endcode
varvalue r 2

$overflow on
code auto:1654 mod[Pointer] 32768[Pointer], -1[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Int8 = -1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1655 mod[compile-time] 32768[Pointer], -1[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1656 mod[Pointer] 32768[Pointer], 0[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Int8 = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1657 mod[compile-time] 32768[Pointer], 0[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:1658 mod[Pointer] 32768[Pointer], 1[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Int8 = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1659 mod[compile-time] 32768[Pointer], 1[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1660 mod[Pointer] 32768[Pointer], 127[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Int8 = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 2

code auto:1661 mod[compile-time] 32768[Pointer], 127[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 127;
endcode
varvalue r 2

$overflow on
code auto:1662 mod[Pointer] 65535[Pointer], -128[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Int8 = -128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1663 mod[compile-time] 65535[Pointer], -128[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1664 mod[Pointer] 65535[Pointer], -127[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Int8 = -127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 3

code auto:1665 mod[compile-time] 65535[Pointer], -127[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod -127;
endcode
varvalue r 3

$overflow on
code auto:1666 mod[Pointer] 65535[Pointer], -1[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Int8 = -1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1667 mod[compile-time] 65535[Pointer], -1[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1668 mod[Pointer] 65535[Pointer], 0[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Int8 = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1669 mod[compile-time] 65535[Pointer], 0[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:1670 mod[Pointer] 65535[Pointer], 1[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Int8 = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1671 mod[compile-time] 65535[Pointer], 1[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1672 mod[Pointer] 65535[Pointer], 127[Int8] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Int8 = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 3

code auto:1673 mod[compile-time] 65535[Pointer], 127[Int8] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 127;
endcode
varvalue r 3

$overflow on
code auto:1674 mod[Pointer] 0[Pointer], -32768[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Integer = -32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1675 mod[compile-time] 0[Pointer], -32768[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod -32768;
endcode
varvalue r 0

$overflow on
code auto:1676 mod[Pointer] 0[Pointer], -32767[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Integer = -32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1677 mod[compile-time] 0[Pointer], -32767[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod -32767;
endcode
varvalue r 0

$overflow on
code auto:1678 mod[Pointer] 0[Pointer], -129[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Integer = -129;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1679 mod[compile-time] 0[Pointer], -129[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod -129;
endcode
varvalue r 0

$overflow on
code auto:1680 mod[Pointer] 0[Pointer], -128[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Integer = -128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1681 mod[compile-time] 0[Pointer], -128[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1682 mod[Pointer] 0[Pointer], -1[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Integer = -1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1683 mod[compile-time] 0[Pointer], -1[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1684 mod[Pointer] 0[Pointer], 0[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Integer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1685 mod[compile-time] 0[Pointer], 0[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1686 mod[Pointer] 0[Pointer], 1[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Integer = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1687 mod[compile-time] 0[Pointer], 1[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1688 mod[Pointer] 0[Pointer], 127[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Integer = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1689 mod[compile-time] 0[Pointer], 127[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1690 mod[Pointer] 0[Pointer], 128[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Integer = 128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1691 mod[compile-time] 0[Pointer], 128[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow on
code auto:1692 mod[Pointer] 0[Pointer], 32767[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Integer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1693 mod[compile-time] 0[Pointer], 32767[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1694 mod[Pointer] 255[Pointer], -32768[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Integer = -32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1695 mod[compile-time] 255[Pointer], -32768[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod -32768;
endcode
varvalue r 255

$overflow on
code auto:1696 mod[Pointer] 255[Pointer], -32767[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Integer = -32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1697 mod[compile-time] 255[Pointer], -32767[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod -32767;
endcode
varvalue r 255

$overflow on
code auto:1698 mod[Pointer] 255[Pointer], -129[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Integer = -129;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 126

code auto:1699 mod[compile-time] 255[Pointer], -129[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod -129;
endcode
varvalue r 126

$overflow on
code auto:1700 mod[Pointer] 255[Pointer], -128[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Integer = -128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1701 mod[compile-time] 255[Pointer], -128[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1702 mod[Pointer] 255[Pointer], -1[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Integer = -1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1703 mod[compile-time] 255[Pointer], -1[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1704 mod[Pointer] 255[Pointer], 0[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Integer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1705 mod[compile-time] 255[Pointer], 0[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1706 mod[Pointer] 255[Pointer], 1[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Integer = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1707 mod[compile-time] 255[Pointer], 1[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1708 mod[Pointer] 255[Pointer], 127[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Integer = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1709 mod[compile-time] 255[Pointer], 127[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1710 mod[Pointer] 255[Pointer], 128[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Integer = 128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1711 mod[compile-time] 255[Pointer], 128[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1712 mod[Pointer] 255[Pointer], 32767[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Integer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1713 mod[compile-time] 255[Pointer], 32767[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow on
code auto:1714 mod[Pointer] 32767[Pointer], -32768[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Integer = -32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1715 mod[compile-time] 32767[Pointer], -32768[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod -32768;
endcode
varvalue r 32767

$overflow on
code auto:1716 mod[Pointer] 32767[Pointer], -32767[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Integer = -32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1717 mod[compile-time] 32767[Pointer], -32767[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod -32767;
endcode
varvalue r 0

$overflow on
code auto:1718 mod[Pointer] 32767[Pointer], -129[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Integer = -129;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1719 mod[compile-time] 32767[Pointer], -129[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod -129;
endcode
varvalue r 1

$overflow on
code auto:1720 mod[Pointer] 32767[Pointer], -128[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Integer = -128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1721 mod[compile-time] 32767[Pointer], -128[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1722 mod[Pointer] 32767[Pointer], -1[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Integer = -1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1723 mod[compile-time] 32767[Pointer], -1[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1724 mod[Pointer] 32767[Pointer], 0[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Integer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1725 mod[compile-time] 32767[Pointer], 0[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:1726 mod[Pointer] 32767[Pointer], 1[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Integer = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1727 mod[compile-time] 32767[Pointer], 1[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1728 mod[Pointer] 32767[Pointer], 127[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Integer = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1729 mod[compile-time] 32767[Pointer], 127[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1730 mod[Pointer] 32767[Pointer], 128[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Integer = 128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1731 mod[compile-time] 32767[Pointer], 128[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1732 mod[Pointer] 32767[Pointer], 32767[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Integer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1733 mod[compile-time] 32767[Pointer], 32767[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1734 mod[Pointer] 32768[Pointer], -32768[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Integer = -32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1735 mod[compile-time] 32768[Pointer], -32768[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod -32768;
endcode
varvalue r 0

$overflow on
code auto:1736 mod[Pointer] 32768[Pointer], -32767[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Integer = -32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1737 mod[compile-time] 32768[Pointer], -32767[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod -32767;
endcode
varvalue r 1

$overflow on
code auto:1738 mod[Pointer] 32768[Pointer], -129[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Integer = -129;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 2

code auto:1739 mod[compile-time] 32768[Pointer], -129[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod -129;
endcode
varvalue r 2

$overflow on
code auto:1740 mod[Pointer] 32768[Pointer], -128[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Integer = -128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1741 mod[compile-time] 32768[Pointer], -128[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1742 mod[Pointer] 32768[Pointer], -1[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Integer = -1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1743 mod[compile-time] 32768[Pointer], -1[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1744 mod[Pointer] 32768[Pointer], 0[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Integer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1745 mod[compile-time] 32768[Pointer], 0[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:1746 mod[Pointer] 32768[Pointer], 1[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Integer = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1747 mod[compile-time] 32768[Pointer], 1[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1748 mod[Pointer] 32768[Pointer], 127[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Integer = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 2

code auto:1749 mod[compile-time] 32768[Pointer], 127[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 127;
endcode
varvalue r 2

$overflow on
code auto:1750 mod[Pointer] 32768[Pointer], 128[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Integer = 128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1751 mod[compile-time] 32768[Pointer], 128[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 128;
endcode
varvalue r 0

$overflow on
code auto:1752 mod[Pointer] 32768[Pointer], 32767[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Integer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1753 mod[compile-time] 32768[Pointer], 32767[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1754 mod[Pointer] 65535[Pointer], -32768[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Integer = -32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1755 mod[compile-time] 65535[Pointer], -32768[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod -32768;
endcode
varvalue r 32767

$overflow on
code auto:1756 mod[Pointer] 65535[Pointer], -32767[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Integer = -32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1757 mod[compile-time] 65535[Pointer], -32767[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod -32767;
endcode
varvalue r 1

$overflow on
code auto:1758 mod[Pointer] 65535[Pointer], -129[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Integer = -129;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 3

code auto:1759 mod[compile-time] 65535[Pointer], -129[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod -129;
endcode
varvalue r 3

$overflow on
code auto:1760 mod[Pointer] 65535[Pointer], -128[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Integer = -128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1761 mod[compile-time] 65535[Pointer], -128[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1762 mod[Pointer] 65535[Pointer], -1[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Integer = -1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1763 mod[compile-time] 65535[Pointer], -1[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1764 mod[Pointer] 65535[Pointer], 0[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Integer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1765 mod[compile-time] 65535[Pointer], 0[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:1766 mod[Pointer] 65535[Pointer], 1[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Integer = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1767 mod[compile-time] 65535[Pointer], 1[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1768 mod[Pointer] 65535[Pointer], 127[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Integer = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 3

code auto:1769 mod[compile-time] 65535[Pointer], 127[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 127;
endcode
varvalue r 3

$overflow on
code auto:1770 mod[Pointer] 65535[Pointer], 128[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Integer = 128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1771 mod[compile-time] 65535[Pointer], 128[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1772 mod[Pointer] 65535[Pointer], 32767[Integer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Integer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1773 mod[compile-time] 65535[Pointer], 32767[Integer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1774 mod[Pointer] 0[Pointer], 0[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Byte = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1775 mod[compile-time] 0[Pointer], 0[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1776 mod[Pointer] 0[Pointer], 1[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Byte = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1777 mod[compile-time] 0[Pointer], 1[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1778 mod[Pointer] 0[Pointer], 127[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Byte = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1779 mod[compile-time] 0[Pointer], 127[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1780 mod[Pointer] 0[Pointer], 128[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Byte = 128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1781 mod[compile-time] 0[Pointer], 128[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow on
code auto:1782 mod[Pointer] 0[Pointer], 255[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Byte = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1783 mod[compile-time] 0[Pointer], 255[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1784 mod[Pointer] 255[Pointer], 0[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Byte = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1785 mod[compile-time] 255[Pointer], 0[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1786 mod[Pointer] 255[Pointer], 1[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Byte = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1787 mod[compile-time] 255[Pointer], 1[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1788 mod[Pointer] 255[Pointer], 127[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Byte = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1789 mod[compile-time] 255[Pointer], 127[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1790 mod[Pointer] 255[Pointer], 128[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Byte = 128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1791 mod[compile-time] 255[Pointer], 128[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1792 mod[Pointer] 255[Pointer], 255[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Byte = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1793 mod[compile-time] 255[Pointer], 255[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1794 mod[Pointer] 32767[Pointer], 0[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Byte = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1795 mod[compile-time] 32767[Pointer], 0[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:1796 mod[Pointer] 32767[Pointer], 1[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Byte = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1797 mod[compile-time] 32767[Pointer], 1[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1798 mod[Pointer] 32767[Pointer], 127[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Byte = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1799 mod[compile-time] 32767[Pointer], 127[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1800 mod[Pointer] 32767[Pointer], 128[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Byte = 128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1801 mod[compile-time] 32767[Pointer], 128[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1802 mod[Pointer] 32767[Pointer], 255[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Byte = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1803 mod[compile-time] 32767[Pointer], 255[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow on
code auto:1804 mod[Pointer] 32768[Pointer], 0[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Byte = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1805 mod[compile-time] 32768[Pointer], 0[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:1806 mod[Pointer] 32768[Pointer], 1[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Byte = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1807 mod[compile-time] 32768[Pointer], 1[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1808 mod[Pointer] 32768[Pointer], 127[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Byte = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 2

code auto:1809 mod[compile-time] 32768[Pointer], 127[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 127;
endcode
varvalue r 2

$overflow on
code auto:1810 mod[Pointer] 32768[Pointer], 128[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Byte = 128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1811 mod[compile-time] 32768[Pointer], 128[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 128;
endcode
varvalue r 0

$overflow on
code auto:1812 mod[Pointer] 32768[Pointer], 255[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Byte = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 128

code auto:1813 mod[compile-time] 32768[Pointer], 255[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 255;
endcode
varvalue r 128

$overflow on
code auto:1814 mod[Pointer] 65535[Pointer], 0[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Byte = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1815 mod[compile-time] 65535[Pointer], 0[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:1816 mod[Pointer] 65535[Pointer], 1[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Byte = 1;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1817 mod[compile-time] 65535[Pointer], 1[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1818 mod[Pointer] 65535[Pointer], 127[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Byte = 127;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 3

code auto:1819 mod[compile-time] 65535[Pointer], 127[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 127;
endcode
varvalue r 3

$overflow on
code auto:1820 mod[Pointer] 65535[Pointer], 128[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Byte = 128;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1821 mod[compile-time] 65535[Pointer], 128[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 128;
endcode
varvalue r 127

$overflow on
code auto:1822 mod[Pointer] 65535[Pointer], 255[Byte] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Byte = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1823 mod[compile-time] 65535[Pointer], 255[Byte] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1824 mod[Pointer] 0[Pointer], 0[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Word = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1825 mod[compile-time] 0[Pointer], 0[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1826 mod[Pointer] 0[Pointer], 255[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Word = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1827 mod[compile-time] 0[Pointer], 255[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1828 mod[Pointer] 0[Pointer], 32767[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Word = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1829 mod[compile-time] 0[Pointer], 32767[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1830 mod[Pointer] 0[Pointer], 32768[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Word = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1831 mod[compile-time] 0[Pointer], 32768[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:1832 mod[Pointer] 0[Pointer], 65535[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Word = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1833 mod[compile-time] 0[Pointer], 65535[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:1834 mod[Pointer] 255[Pointer], 0[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Word = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1835 mod[compile-time] 255[Pointer], 0[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1836 mod[Pointer] 255[Pointer], 255[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Word = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1837 mod[compile-time] 255[Pointer], 255[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1838 mod[Pointer] 255[Pointer], 32767[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Word = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1839 mod[compile-time] 255[Pointer], 32767[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow on
code auto:1840 mod[Pointer] 255[Pointer], 32768[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Word = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1841 mod[compile-time] 255[Pointer], 32768[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 32768;
endcode
varvalue r 255

$overflow on
code auto:1842 mod[Pointer] 255[Pointer], 65535[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Word = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1843 mod[compile-time] 255[Pointer], 65535[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 65535;
endcode
varvalue r 255

$overflow on
code auto:1844 mod[Pointer] 32767[Pointer], 0[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Word = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1845 mod[compile-time] 32767[Pointer], 0[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:1846 mod[Pointer] 32767[Pointer], 255[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Word = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1847 mod[compile-time] 32767[Pointer], 255[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow on
code auto:1848 mod[Pointer] 32767[Pointer], 32767[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Word = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1849 mod[compile-time] 32767[Pointer], 32767[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1850 mod[Pointer] 32767[Pointer], 32768[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Word = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1851 mod[compile-time] 32767[Pointer], 32768[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 32768;
endcode
varvalue r 32767

$overflow on
code auto:1852 mod[Pointer] 32767[Pointer], 65535[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Word = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1853 mod[compile-time] 32767[Pointer], 65535[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 65535;
endcode
varvalue r 32767

$overflow on
code auto:1854 mod[Pointer] 32768[Pointer], 0[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Word = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1855 mod[compile-time] 32768[Pointer], 0[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:1856 mod[Pointer] 32768[Pointer], 255[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Word = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 128

code auto:1857 mod[compile-time] 32768[Pointer], 255[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 255;
endcode
varvalue r 128

$overflow on
code auto:1858 mod[Pointer] 32768[Pointer], 32767[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Word = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1859 mod[compile-time] 32768[Pointer], 32767[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1860 mod[Pointer] 32768[Pointer], 32768[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Word = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1861 mod[compile-time] 32768[Pointer], 32768[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:1862 mod[Pointer] 32768[Pointer], 65535[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Word = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32768

code auto:1863 mod[compile-time] 32768[Pointer], 65535[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 65535;
endcode
varvalue r 32768

$overflow on
code auto:1864 mod[Pointer] 65535[Pointer], 0[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Word = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1865 mod[compile-time] 65535[Pointer], 0[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:1866 mod[Pointer] 65535[Pointer], 255[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Word = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1867 mod[compile-time] 65535[Pointer], 255[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1868 mod[Pointer] 65535[Pointer], 32767[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Word = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1869 mod[compile-time] 65535[Pointer], 32767[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1870 mod[Pointer] 65535[Pointer], 32768[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Word = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1871 mod[compile-time] 65535[Pointer], 32768[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 32768;
endcode
varvalue r 32767

$overflow on
code auto:1872 mod[Pointer] 65535[Pointer], 65535[Word] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Word = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1873 mod[compile-time] 65535[Pointer], 65535[Word] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:1874 mod[Pointer] 0[Pointer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1875 mod[compile-time] 0[Pointer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1876 mod[Pointer] 0[Pointer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1877 mod[compile-time] 0[Pointer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1878 mod[Pointer] 0[Pointer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1879 mod[compile-time] 0[Pointer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1880 mod[Pointer] 0[Pointer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1881 mod[compile-time] 0[Pointer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:1882 mod[Pointer] 0[Pointer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1883 mod[compile-time] 0[Pointer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:1884 mod[Pointer] 255[Pointer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1885 mod[compile-time] 255[Pointer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:1886 mod[Pointer] 255[Pointer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1887 mod[compile-time] 255[Pointer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1888 mod[Pointer] 255[Pointer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1889 mod[compile-time] 255[Pointer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow on
code auto:1890 mod[Pointer] 255[Pointer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1891 mod[compile-time] 255[Pointer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 32768;
endcode
varvalue r 255

$overflow on
code auto:1892 mod[Pointer] 255[Pointer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 255

code auto:1893 mod[compile-time] 255[Pointer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 255 mod 65535;
endcode
varvalue r 255

$overflow on
code auto:1894 mod[Pointer] 32767[Pointer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1895 mod[compile-time] 32767[Pointer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:1896 mod[Pointer] 32767[Pointer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 127

code auto:1897 mod[compile-time] 32767[Pointer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow on
code auto:1898 mod[Pointer] 32767[Pointer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1899 mod[compile-time] 32767[Pointer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:1900 mod[Pointer] 32767[Pointer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1901 mod[compile-time] 32767[Pointer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 32768;
endcode
varvalue r 32767

$overflow on
code auto:1902 mod[Pointer] 32767[Pointer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1903 mod[compile-time] 32767[Pointer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32767 mod 65535;
endcode
varvalue r 32767

$overflow on
code auto:1904 mod[Pointer] 32768[Pointer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1905 mod[compile-time] 32768[Pointer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:1906 mod[Pointer] 32768[Pointer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 128

code auto:1907 mod[compile-time] 32768[Pointer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 255;
endcode
varvalue r 128

$overflow on
code auto:1908 mod[Pointer] 32768[Pointer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1909 mod[compile-time] 32768[Pointer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1910 mod[Pointer] 32768[Pointer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1911 mod[compile-time] 32768[Pointer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:1912 mod[Pointer] 32768[Pointer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32768

code auto:1913 mod[compile-time] 32768[Pointer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 32768 mod 65535;
endcode
varvalue r 32768

$overflow on
code auto:1914 mod[Pointer] 65535[Pointer], 0[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 0;
  var  r: Pointer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1915 mod[compile-time] 65535[Pointer], 0[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:1916 mod[Pointer] 65535[Pointer], 255[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 255;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1917 mod[compile-time] 65535[Pointer], 255[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow on
code auto:1918 mod[Pointer] 65535[Pointer], 32767[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 32767;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 1

code auto:1919 mod[compile-time] 65535[Pointer], 32767[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:1920 mod[Pointer] 65535[Pointer], 32768[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 32768;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 32767

code auto:1921 mod[compile-time] 65535[Pointer], 32768[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 32768;
endcode
varvalue r 32767

$overflow on
code auto:1922 mod[Pointer] 65535[Pointer], 65535[Pointer] -> [Pointer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 65535;
  var  r: Pointer;
  r := a mod b;
endcode
varvalue r 0

code auto:1923 mod[compile-time] 65535[Pointer], 65535[Pointer] -> [Pointer] Both immediate $overflow on
  var  r: Pointer;
  r := 65535 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:1924 mod[Integer] -128[Int8], -128[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1925 mod[compile-time] -128[Int8], -128[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1926 mod[Integer] -128[Int8], -127[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:1927 mod[compile-time] -128[Int8], -127[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod -127;
endcode
varvalue r -1

$overflow on
code auto:1928 mod[Integer] -128[Int8], -1[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1929 mod[compile-time] -128[Int8], -1[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1930 mod[Integer] -128[Int8], 0[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1931 mod[compile-time] -128[Int8], 0[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:1932 mod[Integer] -128[Int8], 1[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1933 mod[compile-time] -128[Int8], 1[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1934 mod[Integer] -128[Int8], 127[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:1935 mod[compile-time] -128[Int8], 127[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod 127;
endcode
varvalue r -1

$overflow on
code auto:1936 mod[Integer] -127[Int8], -128[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -127

code auto:1937 mod[compile-time] -127[Int8], -128[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -127 mod -128;
endcode
varvalue r -127

$overflow on
code auto:1938 mod[Integer] -127[Int8], -127[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1939 mod[compile-time] -127[Int8], -127[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -127 mod -127;
endcode
varvalue r 0

$overflow on
code auto:1940 mod[Integer] -127[Int8], -1[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1941 mod[compile-time] -127[Int8], -1[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -127 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1942 mod[Integer] -127[Int8], 0[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1943 mod[compile-time] -127[Int8], 0[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -127 mod 0;
endcode
compile error

$overflow on
code auto:1944 mod[Integer] -127[Int8], 1[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1945 mod[compile-time] -127[Int8], 1[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1946 mod[Integer] -127[Int8], 127[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1947 mod[compile-time] -127[Int8], 127[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1948 mod[Integer] -1[Int8], -128[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:1949 mod[compile-time] -1[Int8], -128[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod -128;
endcode
varvalue r -1

$overflow on
code auto:1950 mod[Integer] -1[Int8], -127[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:1951 mod[compile-time] -1[Int8], -127[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod -127;
endcode
varvalue r -1

$overflow on
code auto:1952 mod[Integer] -1[Int8], -1[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1953 mod[compile-time] -1[Int8], -1[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1954 mod[Integer] -1[Int8], 0[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1955 mod[compile-time] -1[Int8], 0[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:1956 mod[Integer] -1[Int8], 1[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1957 mod[compile-time] -1[Int8], 1[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1958 mod[Integer] -1[Int8], 127[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:1959 mod[compile-time] -1[Int8], 127[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod 127;
endcode
varvalue r -1

$overflow on
code auto:1960 mod[Integer] 0[Int8], -128[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1961 mod[compile-time] 0[Int8], -128[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow on
code auto:1962 mod[Integer] 0[Int8], -127[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1963 mod[compile-time] 0[Int8], -127[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod -127;
endcode
varvalue r 0

$overflow on
code auto:1964 mod[Integer] 0[Int8], -1[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1965 mod[compile-time] 0[Int8], -1[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1966 mod[Integer] 0[Int8], 0[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1967 mod[compile-time] 0[Int8], 0[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:1968 mod[Integer] 0[Int8], 1[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1969 mod[compile-time] 0[Int8], 1[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1970 mod[Integer] 0[Int8], 127[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1971 mod[compile-time] 0[Int8], 127[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:1972 mod[Integer] 1[Int8], -128[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:1973 mod[compile-time] 1[Int8], -128[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow on
code auto:1974 mod[Integer] 1[Int8], -127[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:1975 mod[compile-time] 1[Int8], -127[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod -127;
endcode
varvalue r 1

$overflow on
code auto:1976 mod[Integer] 1[Int8], -1[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1977 mod[compile-time] 1[Int8], -1[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1978 mod[Integer] 1[Int8], 0[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1979 mod[compile-time] 1[Int8], 0[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:1980 mod[Integer] 1[Int8], 1[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1981 mod[compile-time] 1[Int8], 1[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1982 mod[Integer] 1[Int8], 127[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:1983 mod[compile-time] 1[Int8], 127[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow on
code auto:1984 mod[Integer] 127[Int8], -128[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:1985 mod[compile-time] 127[Int8], -128[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow on
code auto:1986 mod[Integer] 127[Int8], -127[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1987 mod[compile-time] 127[Int8], -127[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod -127;
endcode
varvalue r 0

$overflow on
code auto:1988 mod[Integer] 127[Int8], -1[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1989 mod[compile-time] 127[Int8], -1[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow on
code auto:1990 mod[Integer] 127[Int8], 0[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:1991 mod[compile-time] 127[Int8], 0[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:1992 mod[Integer] 127[Int8], 1[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1993 mod[compile-time] 127[Int8], 1[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:1994 mod[Integer] 127[Int8], 127[Int8] -> [Int8] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:1995 mod[compile-time] 127[Int8], 127[Int8] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:1996 mod[Integer] -128[Int8], -128[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:1997 mod[compile-time] -128[Int8], -128[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -128 mod -128;
endcode
runtime noerror

$overflow on
code auto:1998 mod[Integer] -128[Int8], -128[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:1999 mod[compile-time] -128[Int8], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -128;
endcode
varvalue r 0

$overflow off
code auto:2000 mod[Integer] -128[Int8], -127[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2001 mod[compile-time] -128[Int8], -127[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -128 mod -127;
endcode
runtime noerror

$overflow on
code auto:2002 mod[Integer] -128[Int8], -127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2003 mod[compile-time] -128[Int8], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -127;
endcode
varvalue r -1

$overflow off
code auto:2004 mod[Integer] -128[Int8], -1[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2005 mod[compile-time] -128[Int8], -1[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -128 mod -1;
endcode
runtime noerror

$overflow on
code auto:2006 mod[Integer] -128[Int8], -1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2007 mod[compile-time] -128[Int8], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2008 mod[Integer] -128[Int8], 0[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2009 mod[compile-time] -128[Int8], 0[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:2010 mod[Integer] -128[Int8], 0[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2011 mod[compile-time] -128[Int8], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 0;
endcode
compile error

$overflow off
code auto:2012 mod[Integer] -128[Int8], 1[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2013 mod[compile-time] -128[Int8], 1[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -128 mod 1;
endcode
runtime noerror

$overflow on
code auto:2014 mod[Integer] -128[Int8], 1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2015 mod[compile-time] -128[Int8], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2016 mod[Integer] -128[Int8], 127[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2017 mod[compile-time] -128[Int8], 127[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -128 mod 127;
endcode
runtime noerror

$overflow on
code auto:2018 mod[Integer] -128[Int8], 127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2019 mod[compile-time] -128[Int8], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 127;
endcode
varvalue r -1

$overflow off
code auto:2020 mod[Integer] -127[Int8], -128[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2021 mod[compile-time] -127[Int8], -128[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -127 mod -128;
endcode
runtime noerror

$overflow on
code auto:2022 mod[Integer] -127[Int8], -128[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:2023 mod[compile-time] -127[Int8], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod -128;
endcode
varvalue r -127

$overflow off
code auto:2024 mod[Integer] -127[Int8], -127[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2025 mod[compile-time] -127[Int8], -127[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -127 mod -127;
endcode
runtime noerror

$overflow on
code auto:2026 mod[Integer] -127[Int8], -127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2027 mod[compile-time] -127[Int8], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod -127;
endcode
varvalue r 0

$overflow off
code auto:2028 mod[Integer] -127[Int8], -1[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2029 mod[compile-time] -127[Int8], -1[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -127 mod -1;
endcode
runtime noerror

$overflow on
code auto:2030 mod[Integer] -127[Int8], -1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2031 mod[compile-time] -127[Int8], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2032 mod[Integer] -127[Int8], 0[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2033 mod[compile-time] -127[Int8], 0[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -127 mod 0;
endcode
compile error

$overflow on
code auto:2034 mod[Integer] -127[Int8], 0[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2035 mod[compile-time] -127[Int8], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 0;
endcode
compile error

$overflow off
code auto:2036 mod[Integer] -127[Int8], 1[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2037 mod[compile-time] -127[Int8], 1[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -127 mod 1;
endcode
runtime noerror

$overflow on
code auto:2038 mod[Integer] -127[Int8], 1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2039 mod[compile-time] -127[Int8], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2040 mod[Integer] -127[Int8], 127[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2041 mod[compile-time] -127[Int8], 127[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -127 mod 127;
endcode
runtime noerror

$overflow on
code auto:2042 mod[Integer] -127[Int8], 127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2043 mod[compile-time] -127[Int8], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:2044 mod[Integer] -1[Int8], -128[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2045 mod[compile-time] -1[Int8], -128[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -1 mod -128;
endcode
runtime noerror

$overflow on
code auto:2046 mod[Integer] -1[Int8], -128[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2047 mod[compile-time] -1[Int8], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -128;
endcode
varvalue r -1

$overflow off
code auto:2048 mod[Integer] -1[Int8], -127[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2049 mod[compile-time] -1[Int8], -127[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -1 mod -127;
endcode
runtime noerror

$overflow on
code auto:2050 mod[Integer] -1[Int8], -127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2051 mod[compile-time] -1[Int8], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -127;
endcode
varvalue r -1

$overflow off
code auto:2052 mod[Integer] -1[Int8], -1[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2053 mod[compile-time] -1[Int8], -1[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -1 mod -1;
endcode
runtime noerror

$overflow on
code auto:2054 mod[Integer] -1[Int8], -1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2055 mod[compile-time] -1[Int8], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2056 mod[Integer] -1[Int8], 0[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2057 mod[compile-time] -1[Int8], 0[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:2058 mod[Integer] -1[Int8], 0[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2059 mod[compile-time] -1[Int8], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 0;
endcode
compile error

$overflow off
code auto:2060 mod[Integer] -1[Int8], 1[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2061 mod[compile-time] -1[Int8], 1[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -1 mod 1;
endcode
runtime noerror

$overflow on
code auto:2062 mod[Integer] -1[Int8], 1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2063 mod[compile-time] -1[Int8], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2064 mod[Integer] -1[Int8], 127[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2065 mod[compile-time] -1[Int8], 127[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := -1 mod 127;
endcode
runtime noerror

$overflow on
code auto:2066 mod[Integer] -1[Int8], 127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2067 mod[compile-time] -1[Int8], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 127;
endcode
varvalue r -1

$overflow off
code auto:2068 mod[Integer] 0[Int8], -128[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2069 mod[compile-time] 0[Int8], -128[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod -128;
endcode
runtime noerror

$overflow on
code auto:2070 mod[Integer] 0[Int8], -128[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2071 mod[compile-time] 0[Int8], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow off
code auto:2072 mod[Integer] 0[Int8], -127[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2073 mod[compile-time] 0[Int8], -127[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod -127;
endcode
runtime noerror

$overflow on
code auto:2074 mod[Integer] 0[Int8], -127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2075 mod[compile-time] 0[Int8], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -127;
endcode
varvalue r 0

$overflow off
code auto:2076 mod[Integer] 0[Int8], -1[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2077 mod[compile-time] 0[Int8], -1[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod -1;
endcode
runtime noerror

$overflow on
code auto:2078 mod[Integer] 0[Int8], -1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2079 mod[compile-time] 0[Int8], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2080 mod[Integer] 0[Int8], 0[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2081 mod[compile-time] 0[Int8], 0[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:2082 mod[Integer] 0[Int8], 0[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2083 mod[compile-time] 0[Int8], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:2084 mod[Integer] 0[Int8], 1[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2085 mod[compile-time] 0[Int8], 1[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 1;
endcode
runtime noerror

$overflow on
code auto:2086 mod[Integer] 0[Int8], 1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2087 mod[compile-time] 0[Int8], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2088 mod[Integer] 0[Int8], 127[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2089 mod[compile-time] 0[Int8], 127[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 127;
endcode
runtime noerror

$overflow on
code auto:2090 mod[Integer] 0[Int8], 127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2091 mod[compile-time] 0[Int8], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow off
code auto:2092 mod[Integer] 1[Int8], -128[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2093 mod[compile-time] 1[Int8], -128[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 1 mod -128;
endcode
runtime noerror

$overflow on
code auto:2094 mod[Integer] 1[Int8], -128[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:2095 mod[compile-time] 1[Int8], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow off
code auto:2096 mod[Integer] 1[Int8], -127[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2097 mod[compile-time] 1[Int8], -127[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 1 mod -127;
endcode
runtime noerror

$overflow on
code auto:2098 mod[Integer] 1[Int8], -127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:2099 mod[compile-time] 1[Int8], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -127;
endcode
varvalue r 1

$overflow off
code auto:2100 mod[Integer] 1[Int8], -1[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2101 mod[compile-time] 1[Int8], -1[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 1 mod -1;
endcode
runtime noerror

$overflow on
code auto:2102 mod[Integer] 1[Int8], -1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2103 mod[compile-time] 1[Int8], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2104 mod[Integer] 1[Int8], 0[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2105 mod[compile-time] 1[Int8], 0[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:2106 mod[Integer] 1[Int8], 0[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2107 mod[compile-time] 1[Int8], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow off
code auto:2108 mod[Integer] 1[Int8], 1[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2109 mod[compile-time] 1[Int8], 1[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 1 mod 1;
endcode
runtime noerror

$overflow on
code auto:2110 mod[Integer] 1[Int8], 1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2111 mod[compile-time] 1[Int8], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2112 mod[Integer] 1[Int8], 127[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2113 mod[compile-time] 1[Int8], 127[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 1 mod 127;
endcode
runtime noerror

$overflow on
code auto:2114 mod[Integer] 1[Int8], 127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:2115 mod[compile-time] 1[Int8], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow off
code auto:2116 mod[Integer] 127[Int8], -128[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2117 mod[compile-time] 127[Int8], -128[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 127 mod -128;
endcode
runtime noerror

$overflow on
code auto:2118 mod[Integer] 127[Int8], -128[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:2119 mod[compile-time] 127[Int8], -128[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow off
code auto:2120 mod[Integer] 127[Int8], -127[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2121 mod[compile-time] 127[Int8], -127[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 127 mod -127;
endcode
runtime noerror

$overflow on
code auto:2122 mod[Integer] 127[Int8], -127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2123 mod[compile-time] 127[Int8], -127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -127;
endcode
varvalue r 0

$overflow off
code auto:2124 mod[Integer] 127[Int8], -1[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2125 mod[compile-time] 127[Int8], -1[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 127 mod -1;
endcode
runtime noerror

$overflow on
code auto:2126 mod[Integer] 127[Int8], -1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2127 mod[compile-time] 127[Int8], -1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2128 mod[Integer] 127[Int8], 0[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2129 mod[compile-time] 127[Int8], 0[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:2130 mod[Integer] 127[Int8], 0[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2131 mod[compile-time] 127[Int8], 0[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow off
code auto:2132 mod[Integer] 127[Int8], 1[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2133 mod[compile-time] 127[Int8], 1[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 127 mod 1;
endcode
runtime noerror

$overflow on
code auto:2134 mod[Integer] 127[Int8], 1[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2135 mod[compile-time] 127[Int8], 1[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2136 mod[Integer] 127[Int8], 127[Int8] -> [Integer] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:2137 mod[compile-time] 127[Int8], 127[Int8] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 127 mod 127;
endcode
runtime noerror

$overflow on
code auto:2138 mod[Integer] 127[Int8], 127[Int8] -> [Integer] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2139 mod[compile-time] 127[Int8], 127[Int8] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:2140 mod[Integer] -128[Int8], -128[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2141 mod[compile-time] -128[Int8], -128[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod -128;
endcode
runtime noerror

$overflow on
code auto:2142 mod[Integer] -128[Int8], -128[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2143 mod[compile-time] -128[Int8], -128[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod -128;
endcode
varvalue r 0

$overflow off
code auto:2144 mod[Integer] -128[Int8], -127[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = -127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2145 mod[compile-time] -128[Int8], -127[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod -127;
endcode
compile error

$overflow on
code auto:2146 mod[Integer] -128[Int8], -127[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -127;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:2147 mod[compile-time] -128[Int8], -127[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod -127;
endcode
compile error

$overflow off
code auto:2148 mod[Integer] -128[Int8], -1[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2149 mod[compile-time] -128[Int8], -1[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod -1;
endcode
runtime noerror

$overflow on
code auto:2150 mod[Integer] -128[Int8], -1[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2151 mod[compile-time] -128[Int8], -1[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2152 mod[Integer] -128[Int8], 0[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2153 mod[compile-time] -128[Int8], 0[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:2154 mod[Integer] -128[Int8], 0[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2155 mod[compile-time] -128[Int8], 0[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod 0;
endcode
compile error

$overflow off
code auto:2156 mod[Integer] -128[Int8], 1[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2157 mod[compile-time] -128[Int8], 1[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod 1;
endcode
runtime noerror

$overflow on
code auto:2158 mod[Integer] -128[Int8], 1[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2159 mod[compile-time] -128[Int8], 1[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2160 mod[Integer] -128[Int8], 127[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2161 mod[compile-time] -128[Int8], 127[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod 127;
endcode
compile error

$overflow on
code auto:2162 mod[Integer] -128[Int8], 127[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:2163 mod[compile-time] -128[Int8], 127[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod 127;
endcode
compile error

$overflow off
code auto:2164 mod[Integer] -127[Int8], -128[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2165 mod[compile-time] -127[Int8], -128[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -127 mod -128;
endcode
compile error

$overflow on
code auto:2166 mod[Integer] -127[Int8], -128[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:2167 mod[compile-time] -127[Int8], -128[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -127 mod -128;
endcode
compile error

$overflow off
code auto:2168 mod[Integer] -127[Int8], -127[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = -127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2169 mod[compile-time] -127[Int8], -127[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -127 mod -127;
endcode
runtime noerror

$overflow on
code auto:2170 mod[Integer] -127[Int8], -127[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2171 mod[compile-time] -127[Int8], -127[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -127 mod -127;
endcode
varvalue r 0

$overflow off
code auto:2172 mod[Integer] -127[Int8], -1[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2173 mod[compile-time] -127[Int8], -1[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -127 mod -1;
endcode
runtime noerror

$overflow on
code auto:2174 mod[Integer] -127[Int8], -1[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2175 mod[compile-time] -127[Int8], -1[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -127 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2176 mod[Integer] -127[Int8], 0[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2177 mod[compile-time] -127[Int8], 0[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -127 mod 0;
endcode
compile error

$overflow on
code auto:2178 mod[Integer] -127[Int8], 0[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2179 mod[compile-time] -127[Int8], 0[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -127 mod 0;
endcode
compile error

$overflow off
code auto:2180 mod[Integer] -127[Int8], 1[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2181 mod[compile-time] -127[Int8], 1[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -127 mod 1;
endcode
runtime noerror

$overflow on
code auto:2182 mod[Integer] -127[Int8], 1[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2183 mod[compile-time] -127[Int8], 1[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -127 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2184 mod[Integer] -127[Int8], 127[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2185 mod[compile-time] -127[Int8], 127[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -127 mod 127;
endcode
runtime noerror

$overflow on
code auto:2186 mod[Integer] -127[Int8], 127[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2187 mod[compile-time] -127[Int8], 127[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:2188 mod[Integer] -1[Int8], -128[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2189 mod[compile-time] -1[Int8], -128[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod -128;
endcode
compile error

$overflow on
code auto:2190 mod[Integer] -1[Int8], -128[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:2191 mod[compile-time] -1[Int8], -128[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod -128;
endcode
compile error

$overflow off
code auto:2192 mod[Integer] -1[Int8], -127[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = -127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2193 mod[compile-time] -1[Int8], -127[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod -127;
endcode
compile error

$overflow on
code auto:2194 mod[Integer] -1[Int8], -127[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -127;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:2195 mod[compile-time] -1[Int8], -127[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod -127;
endcode
compile error

$overflow off
code auto:2196 mod[Integer] -1[Int8], -1[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2197 mod[compile-time] -1[Int8], -1[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod -1;
endcode
runtime noerror

$overflow on
code auto:2198 mod[Integer] -1[Int8], -1[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2199 mod[compile-time] -1[Int8], -1[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2200 mod[Integer] -1[Int8], 0[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2201 mod[compile-time] -1[Int8], 0[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:2202 mod[Integer] -1[Int8], 0[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2203 mod[compile-time] -1[Int8], 0[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod 0;
endcode
compile error

$overflow off
code auto:2204 mod[Integer] -1[Int8], 1[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2205 mod[compile-time] -1[Int8], 1[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod 1;
endcode
runtime noerror

$overflow on
code auto:2206 mod[Integer] -1[Int8], 1[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2207 mod[compile-time] -1[Int8], 1[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2208 mod[Integer] -1[Int8], 127[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2209 mod[compile-time] -1[Int8], 127[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod 127;
endcode
compile error

$overflow on
code auto:2210 mod[Integer] -1[Int8], 127[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:2211 mod[compile-time] -1[Int8], 127[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod 127;
endcode
compile error

$overflow off
code auto:2212 mod[Integer] 0[Int8], -128[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2213 mod[compile-time] 0[Int8], -128[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod -128;
endcode
runtime noerror

$overflow on
code auto:2214 mod[Integer] 0[Int8], -128[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2215 mod[compile-time] 0[Int8], -128[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow off
code auto:2216 mod[Integer] 0[Int8], -127[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = -127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2217 mod[compile-time] 0[Int8], -127[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod -127;
endcode
runtime noerror

$overflow on
code auto:2218 mod[Integer] 0[Int8], -127[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2219 mod[compile-time] 0[Int8], -127[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod -127;
endcode
varvalue r 0

$overflow off
code auto:2220 mod[Integer] 0[Int8], -1[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2221 mod[compile-time] 0[Int8], -1[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod -1;
endcode
runtime noerror

$overflow on
code auto:2222 mod[Integer] 0[Int8], -1[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2223 mod[compile-time] 0[Int8], -1[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2224 mod[Integer] 0[Int8], 0[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2225 mod[compile-time] 0[Int8], 0[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:2226 mod[Integer] 0[Int8], 0[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2227 mod[compile-time] 0[Int8], 0[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:2228 mod[Integer] 0[Int8], 1[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2229 mod[compile-time] 0[Int8], 1[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 1;
endcode
runtime noerror

$overflow on
code auto:2230 mod[Integer] 0[Int8], 1[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2231 mod[compile-time] 0[Int8], 1[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2232 mod[Integer] 0[Int8], 127[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2233 mod[compile-time] 0[Int8], 127[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 127;
endcode
runtime noerror

$overflow on
code auto:2234 mod[Integer] 0[Int8], 127[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2235 mod[compile-time] 0[Int8], 127[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow off
code auto:2236 mod[Integer] 1[Int8], -128[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2237 mod[compile-time] 1[Int8], -128[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod -128;
endcode
runtime noerror

$overflow on
code auto:2238 mod[Integer] 1[Int8], -128[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:2239 mod[compile-time] 1[Int8], -128[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow off
code auto:2240 mod[Integer] 1[Int8], -127[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = -127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2241 mod[compile-time] 1[Int8], -127[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod -127;
endcode
runtime noerror

$overflow on
code auto:2242 mod[Integer] 1[Int8], -127[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:2243 mod[compile-time] 1[Int8], -127[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod -127;
endcode
varvalue r 1

$overflow off
code auto:2244 mod[Integer] 1[Int8], -1[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2245 mod[compile-time] 1[Int8], -1[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod -1;
endcode
runtime noerror

$overflow on
code auto:2246 mod[Integer] 1[Int8], -1[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2247 mod[compile-time] 1[Int8], -1[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2248 mod[Integer] 1[Int8], 0[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2249 mod[compile-time] 1[Int8], 0[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:2250 mod[Integer] 1[Int8], 0[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2251 mod[compile-time] 1[Int8], 0[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 0;
endcode
compile error

$overflow off
code auto:2252 mod[Integer] 1[Int8], 1[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2253 mod[compile-time] 1[Int8], 1[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod 1;
endcode
runtime noerror

$overflow on
code auto:2254 mod[Integer] 1[Int8], 1[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2255 mod[compile-time] 1[Int8], 1[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2256 mod[Integer] 1[Int8], 127[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2257 mod[compile-time] 1[Int8], 127[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod 127;
endcode
runtime noerror

$overflow on
code auto:2258 mod[Integer] 1[Int8], 127[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:2259 mod[compile-time] 1[Int8], 127[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow off
code auto:2260 mod[Integer] 127[Int8], -128[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2261 mod[compile-time] 127[Int8], -128[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod -128;
endcode
runtime noerror

$overflow on
code auto:2262 mod[Integer] 127[Int8], -128[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:2263 mod[compile-time] 127[Int8], -128[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow off
code auto:2264 mod[Integer] 127[Int8], -127[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = -127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2265 mod[compile-time] 127[Int8], -127[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod -127;
endcode
runtime noerror

$overflow on
code auto:2266 mod[Integer] 127[Int8], -127[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2267 mod[compile-time] 127[Int8], -127[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod -127;
endcode
varvalue r 0

$overflow off
code auto:2268 mod[Integer] 127[Int8], -1[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2269 mod[compile-time] 127[Int8], -1[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod -1;
endcode
runtime noerror

$overflow on
code auto:2270 mod[Integer] 127[Int8], -1[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2271 mod[compile-time] 127[Int8], -1[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2272 mod[Integer] 127[Int8], 0[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2273 mod[compile-time] 127[Int8], 0[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:2274 mod[Integer] 127[Int8], 0[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2275 mod[compile-time] 127[Int8], 0[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 0;
endcode
compile error

$overflow off
code auto:2276 mod[Integer] 127[Int8], 1[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2277 mod[compile-time] 127[Int8], 1[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod 1;
endcode
runtime noerror

$overflow on
code auto:2278 mod[Integer] 127[Int8], 1[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2279 mod[compile-time] 127[Int8], 1[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2280 mod[Integer] 127[Int8], 127[Int8] -> [Byte] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:2281 mod[compile-time] 127[Int8], 127[Int8] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod 127;
endcode
runtime noerror

$overflow on
code auto:2282 mod[Integer] 127[Int8], 127[Int8] -> [Byte] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:2283 mod[compile-time] 127[Int8], 127[Int8] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:2284 mod[Integer] -128[Int8], -128[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2285 mod[compile-time] -128[Int8], -128[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod -128;
endcode
runtime noerror

$overflow on
code auto:2286 mod[Integer] -128[Int8], -128[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2287 mod[compile-time] -128[Int8], -128[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod -128;
endcode
varvalue r 0

$overflow off
code auto:2288 mod[Integer] -128[Int8], -127[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = -127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2289 mod[compile-time] -128[Int8], -127[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod -127;
endcode
compile error

$overflow on
code auto:2290 mod[Integer] -128[Int8], -127[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -127;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:2291 mod[compile-time] -128[Int8], -127[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod -127;
endcode
compile error

$overflow off
code auto:2292 mod[Integer] -128[Int8], -1[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2293 mod[compile-time] -128[Int8], -1[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod -1;
endcode
runtime noerror

$overflow on
code auto:2294 mod[Integer] -128[Int8], -1[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2295 mod[compile-time] -128[Int8], -1[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2296 mod[Integer] -128[Int8], 0[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2297 mod[compile-time] -128[Int8], 0[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:2298 mod[Integer] -128[Int8], 0[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2299 mod[compile-time] -128[Int8], 0[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod 0;
endcode
compile error

$overflow off
code auto:2300 mod[Integer] -128[Int8], 1[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2301 mod[compile-time] -128[Int8], 1[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod 1;
endcode
runtime noerror

$overflow on
code auto:2302 mod[Integer] -128[Int8], 1[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2303 mod[compile-time] -128[Int8], 1[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2304 mod[Integer] -128[Int8], 127[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -128;
  var  b: Int8 = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2305 mod[compile-time] -128[Int8], 127[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod 127;
endcode
compile error

$overflow on
code auto:2306 mod[Integer] -128[Int8], 127[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -128;
  var  b: Int8 = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:2307 mod[compile-time] -128[Int8], 127[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod 127;
endcode
compile error

$overflow off
code auto:2308 mod[Integer] -127[Int8], -128[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2309 mod[compile-time] -127[Int8], -128[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -127 mod -128;
endcode
compile error

$overflow on
code auto:2310 mod[Integer] -127[Int8], -128[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:2311 mod[compile-time] -127[Int8], -128[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -127 mod -128;
endcode
compile error

$overflow off
code auto:2312 mod[Integer] -127[Int8], -127[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = -127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2313 mod[compile-time] -127[Int8], -127[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -127 mod -127;
endcode
runtime noerror

$overflow on
code auto:2314 mod[Integer] -127[Int8], -127[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2315 mod[compile-time] -127[Int8], -127[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -127 mod -127;
endcode
varvalue r 0

$overflow off
code auto:2316 mod[Integer] -127[Int8], -1[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2317 mod[compile-time] -127[Int8], -1[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -127 mod -1;
endcode
runtime noerror

$overflow on
code auto:2318 mod[Integer] -127[Int8], -1[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2319 mod[compile-time] -127[Int8], -1[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -127 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2320 mod[Integer] -127[Int8], 0[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2321 mod[compile-time] -127[Int8], 0[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -127 mod 0;
endcode
compile error

$overflow on
code auto:2322 mod[Integer] -127[Int8], 0[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2323 mod[compile-time] -127[Int8], 0[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -127 mod 0;
endcode
compile error

$overflow off
code auto:2324 mod[Integer] -127[Int8], 1[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2325 mod[compile-time] -127[Int8], 1[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -127 mod 1;
endcode
runtime noerror

$overflow on
code auto:2326 mod[Integer] -127[Int8], 1[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2327 mod[compile-time] -127[Int8], 1[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -127 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2328 mod[Integer] -127[Int8], 127[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -127;
  var  b: Int8 = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2329 mod[compile-time] -127[Int8], 127[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -127 mod 127;
endcode
runtime noerror

$overflow on
code auto:2330 mod[Integer] -127[Int8], 127[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -127;
  var  b: Int8 = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2331 mod[compile-time] -127[Int8], 127[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:2332 mod[Integer] -1[Int8], -128[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2333 mod[compile-time] -1[Int8], -128[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod -128;
endcode
compile error

$overflow on
code auto:2334 mod[Integer] -1[Int8], -128[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:2335 mod[compile-time] -1[Int8], -128[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod -128;
endcode
compile error

$overflow off
code auto:2336 mod[Integer] -1[Int8], -127[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = -127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2337 mod[compile-time] -1[Int8], -127[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod -127;
endcode
compile error

$overflow on
code auto:2338 mod[Integer] -1[Int8], -127[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -127;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:2339 mod[compile-time] -1[Int8], -127[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod -127;
endcode
compile error

$overflow off
code auto:2340 mod[Integer] -1[Int8], -1[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2341 mod[compile-time] -1[Int8], -1[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod -1;
endcode
runtime noerror

$overflow on
code auto:2342 mod[Integer] -1[Int8], -1[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2343 mod[compile-time] -1[Int8], -1[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2344 mod[Integer] -1[Int8], 0[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2345 mod[compile-time] -1[Int8], 0[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:2346 mod[Integer] -1[Int8], 0[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2347 mod[compile-time] -1[Int8], 0[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod 0;
endcode
compile error

$overflow off
code auto:2348 mod[Integer] -1[Int8], 1[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2349 mod[compile-time] -1[Int8], 1[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod 1;
endcode
runtime noerror

$overflow on
code auto:2350 mod[Integer] -1[Int8], 1[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2351 mod[compile-time] -1[Int8], 1[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2352 mod[Integer] -1[Int8], 127[Int8] -> [Word] Var $overflow off
  var  a: Int8 = -1;
  var  b: Int8 = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2353 mod[compile-time] -1[Int8], 127[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod 127;
endcode
compile error

$overflow on
code auto:2354 mod[Integer] -1[Int8], 127[Int8] -> [Word] Var $overflow on
  var  a: Int8 = -1;
  var  b: Int8 = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:2355 mod[compile-time] -1[Int8], 127[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod 127;
endcode
compile error

$overflow off
code auto:2356 mod[Integer] 0[Int8], -128[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2357 mod[compile-time] 0[Int8], -128[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod -128;
endcode
runtime noerror

$overflow on
code auto:2358 mod[Integer] 0[Int8], -128[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2359 mod[compile-time] 0[Int8], -128[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow off
code auto:2360 mod[Integer] 0[Int8], -127[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = -127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2361 mod[compile-time] 0[Int8], -127[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod -127;
endcode
runtime noerror

$overflow on
code auto:2362 mod[Integer] 0[Int8], -127[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2363 mod[compile-time] 0[Int8], -127[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod -127;
endcode
varvalue r 0

$overflow off
code auto:2364 mod[Integer] 0[Int8], -1[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2365 mod[compile-time] 0[Int8], -1[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod -1;
endcode
runtime noerror

$overflow on
code auto:2366 mod[Integer] 0[Int8], -1[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2367 mod[compile-time] 0[Int8], -1[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2368 mod[Integer] 0[Int8], 0[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2369 mod[compile-time] 0[Int8], 0[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:2370 mod[Integer] 0[Int8], 0[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2371 mod[compile-time] 0[Int8], 0[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:2372 mod[Integer] 0[Int8], 1[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2373 mod[compile-time] 0[Int8], 1[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 1;
endcode
runtime noerror

$overflow on
code auto:2374 mod[Integer] 0[Int8], 1[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2375 mod[compile-time] 0[Int8], 1[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2376 mod[Integer] 0[Int8], 127[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 0;
  var  b: Int8 = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2377 mod[compile-time] 0[Int8], 127[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 127;
endcode
runtime noerror

$overflow on
code auto:2378 mod[Integer] 0[Int8], 127[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 0;
  var  b: Int8 = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2379 mod[compile-time] 0[Int8], 127[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow off
code auto:2380 mod[Integer] 1[Int8], -128[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2381 mod[compile-time] 1[Int8], -128[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod -128;
endcode
runtime noerror

$overflow on
code auto:2382 mod[Integer] 1[Int8], -128[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:2383 mod[compile-time] 1[Int8], -128[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow off
code auto:2384 mod[Integer] 1[Int8], -127[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = -127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2385 mod[compile-time] 1[Int8], -127[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod -127;
endcode
runtime noerror

$overflow on
code auto:2386 mod[Integer] 1[Int8], -127[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:2387 mod[compile-time] 1[Int8], -127[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod -127;
endcode
varvalue r 1

$overflow off
code auto:2388 mod[Integer] 1[Int8], -1[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2389 mod[compile-time] 1[Int8], -1[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod -1;
endcode
runtime noerror

$overflow on
code auto:2390 mod[Integer] 1[Int8], -1[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2391 mod[compile-time] 1[Int8], -1[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2392 mod[Integer] 1[Int8], 0[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2393 mod[compile-time] 1[Int8], 0[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:2394 mod[Integer] 1[Int8], 0[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2395 mod[compile-time] 1[Int8], 0[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 0;
endcode
compile error

$overflow off
code auto:2396 mod[Integer] 1[Int8], 1[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2397 mod[compile-time] 1[Int8], 1[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 1;
endcode
runtime noerror

$overflow on
code auto:2398 mod[Integer] 1[Int8], 1[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2399 mod[compile-time] 1[Int8], 1[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2400 mod[Integer] 1[Int8], 127[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 1;
  var  b: Int8 = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2401 mod[compile-time] 1[Int8], 127[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 127;
endcode
runtime noerror

$overflow on
code auto:2402 mod[Integer] 1[Int8], 127[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 1;
  var  b: Int8 = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:2403 mod[compile-time] 1[Int8], 127[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow off
code auto:2404 mod[Integer] 127[Int8], -128[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2405 mod[compile-time] 127[Int8], -128[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod -128;
endcode
runtime noerror

$overflow on
code auto:2406 mod[Integer] 127[Int8], -128[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:2407 mod[compile-time] 127[Int8], -128[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow off
code auto:2408 mod[Integer] 127[Int8], -127[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = -127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2409 mod[compile-time] 127[Int8], -127[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod -127;
endcode
runtime noerror

$overflow on
code auto:2410 mod[Integer] 127[Int8], -127[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2411 mod[compile-time] 127[Int8], -127[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod -127;
endcode
varvalue r 0

$overflow off
code auto:2412 mod[Integer] 127[Int8], -1[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2413 mod[compile-time] 127[Int8], -1[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod -1;
endcode
runtime noerror

$overflow on
code auto:2414 mod[Integer] 127[Int8], -1[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2415 mod[compile-time] 127[Int8], -1[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2416 mod[Integer] 127[Int8], 0[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2417 mod[compile-time] 127[Int8], 0[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:2418 mod[Integer] 127[Int8], 0[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2419 mod[compile-time] 127[Int8], 0[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 0;
endcode
compile error

$overflow off
code auto:2420 mod[Integer] 127[Int8], 1[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2421 mod[compile-time] 127[Int8], 1[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 1;
endcode
runtime noerror

$overflow on
code auto:2422 mod[Integer] 127[Int8], 1[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2423 mod[compile-time] 127[Int8], 1[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2424 mod[Integer] 127[Int8], 127[Int8] -> [Word] Var $overflow off
  var  a: Int8 = 127;
  var  b: Int8 = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:2425 mod[compile-time] 127[Int8], 127[Int8] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 127;
endcode
runtime noerror

$overflow on
code auto:2426 mod[Integer] 127[Int8], 127[Int8] -> [Word] Var $overflow on
  var  a: Int8 = 127;
  var  b: Int8 = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:2427 mod[compile-time] 127[Int8], 127[Int8] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:2428 mod[Integer] -32768[Integer], -32768[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2429 mod[compile-time] -32768[Integer], -32768[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32768 mod -32768;
endcode
runtime noerror

$overflow on
code auto:2430 mod[Integer] -32768[Integer], -32768[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2431 mod[compile-time] -32768[Integer], -32768[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32768 mod -32768;
endcode
varvalue r 0

$overflow off
code auto:2432 mod[Integer] -32768[Integer], -32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2433 mod[compile-time] -32768[Integer], -32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32768 mod -32767;
endcode
runtime noerror

$overflow on
code auto:2434 mod[Integer] -32768[Integer], -32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2435 mod[compile-time] -32768[Integer], -32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32768 mod -32767;
endcode
varvalue r -1

$overflow off
code auto:2436 mod[Integer] -32768[Integer], -129[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2437 mod[compile-time] -32768[Integer], -129[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32768 mod -129;
endcode
runtime noerror

$overflow on
code auto:2438 mod[Integer] -32768[Integer], -129[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -2

code auto:2439 mod[compile-time] -32768[Integer], -129[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32768 mod -129;
endcode
varvalue r -2

$overflow off
code auto:2440 mod[Integer] -32768[Integer], -128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2441 mod[compile-time] -32768[Integer], -128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32768 mod -128;
endcode
runtime noerror

$overflow on
code auto:2442 mod[Integer] -32768[Integer], -128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2443 mod[compile-time] -32768[Integer], -128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32768 mod -128;
endcode
varvalue r 0

$overflow off
code auto:2444 mod[Integer] -32768[Integer], -1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2445 mod[compile-time] -32768[Integer], -1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32768 mod -1;
endcode
runtime noerror

$overflow on
code auto:2446 mod[Integer] -32768[Integer], -1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2447 mod[compile-time] -32768[Integer], -1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32768 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2448 mod[Integer] -32768[Integer], 0[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2449 mod[compile-time] -32768[Integer], 0[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32768 mod 0;
endcode
compile error

$overflow on
code auto:2450 mod[Integer] -32768[Integer], 0[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2451 mod[compile-time] -32768[Integer], 0[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32768 mod 0;
endcode
compile error

$overflow off
code auto:2452 mod[Integer] -32768[Integer], 1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2453 mod[compile-time] -32768[Integer], 1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32768 mod 1;
endcode
runtime noerror

$overflow on
code auto:2454 mod[Integer] -32768[Integer], 1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2455 mod[compile-time] -32768[Integer], 1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32768 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2456 mod[Integer] -32768[Integer], 127[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2457 mod[compile-time] -32768[Integer], 127[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32768 mod 127;
endcode
runtime noerror

$overflow on
code auto:2458 mod[Integer] -32768[Integer], 127[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -2

code auto:2459 mod[compile-time] -32768[Integer], 127[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32768 mod 127;
endcode
varvalue r -2

$overflow off
code auto:2460 mod[Integer] -32768[Integer], 128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2461 mod[compile-time] -32768[Integer], 128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32768 mod 128;
endcode
runtime noerror

$overflow on
code auto:2462 mod[Integer] -32768[Integer], 128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2463 mod[compile-time] -32768[Integer], 128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32768 mod 128;
endcode
varvalue r 0

$overflow off
code auto:2464 mod[Integer] -32768[Integer], 32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2465 mod[compile-time] -32768[Integer], 32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32768 mod 32767;
endcode
runtime noerror

$overflow on
code auto:2466 mod[Integer] -32768[Integer], 32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2467 mod[compile-time] -32768[Integer], 32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32768 mod 32767;
endcode
varvalue r -1

$overflow off
code auto:2468 mod[Integer] -32767[Integer], -32768[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2469 mod[compile-time] -32767[Integer], -32768[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32767 mod -32768;
endcode
compile error

$overflow on
code auto:2470 mod[Integer] -32767[Integer], -32768[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:2471 mod[compile-time] -32767[Integer], -32768[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32767 mod -32768;
endcode
compile error

$overflow off
code auto:2472 mod[Integer] -32767[Integer], -32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2473 mod[compile-time] -32767[Integer], -32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32767 mod -32767;
endcode
runtime noerror

$overflow on
code auto:2474 mod[Integer] -32767[Integer], -32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2475 mod[compile-time] -32767[Integer], -32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32767 mod -32767;
endcode
varvalue r 0

$overflow off
code auto:2476 mod[Integer] -32767[Integer], -129[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2477 mod[compile-time] -32767[Integer], -129[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32767 mod -129;
endcode
runtime noerror

$overflow on
code auto:2478 mod[Integer] -32767[Integer], -129[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2479 mod[compile-time] -32767[Integer], -129[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32767 mod -129;
endcode
varvalue r -1

$overflow off
code auto:2480 mod[Integer] -32767[Integer], -128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2481 mod[compile-time] -32767[Integer], -128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32767 mod -128;
endcode
runtime noerror

$overflow on
code auto:2482 mod[Integer] -32767[Integer], -128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -127

code auto:2483 mod[compile-time] -32767[Integer], -128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32767 mod -128;
endcode
varvalue r -127

$overflow off
code auto:2484 mod[Integer] -32767[Integer], -1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2485 mod[compile-time] -32767[Integer], -1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32767 mod -1;
endcode
runtime noerror

$overflow on
code auto:2486 mod[Integer] -32767[Integer], -1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2487 mod[compile-time] -32767[Integer], -1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32767 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2488 mod[Integer] -32767[Integer], 0[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2489 mod[compile-time] -32767[Integer], 0[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32767 mod 0;
endcode
compile error

$overflow on
code auto:2490 mod[Integer] -32767[Integer], 0[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2491 mod[compile-time] -32767[Integer], 0[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32767 mod 0;
endcode
compile error

$overflow off
code auto:2492 mod[Integer] -32767[Integer], 1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2493 mod[compile-time] -32767[Integer], 1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32767 mod 1;
endcode
runtime noerror

$overflow on
code auto:2494 mod[Integer] -32767[Integer], 1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2495 mod[compile-time] -32767[Integer], 1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32767 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2496 mod[Integer] -32767[Integer], 127[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2497 mod[compile-time] -32767[Integer], 127[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32767 mod 127;
endcode
runtime noerror

$overflow on
code auto:2498 mod[Integer] -32767[Integer], 127[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2499 mod[compile-time] -32767[Integer], 127[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32767 mod 127;
endcode
varvalue r -1

$overflow off
code auto:2500 mod[Integer] -32767[Integer], 128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2501 mod[compile-time] -32767[Integer], 128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32767 mod 128;
endcode
runtime noerror

$overflow on
code auto:2502 mod[Integer] -32767[Integer], 128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -127

code auto:2503 mod[compile-time] -32767[Integer], 128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32767 mod 128;
endcode
varvalue r -127

$overflow off
code auto:2504 mod[Integer] -32767[Integer], 32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2505 mod[compile-time] -32767[Integer], 32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:2506 mod[Integer] -32767[Integer], 32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2507 mod[compile-time] -32767[Integer], 32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:2508 mod[Integer] -129[Integer], -32768[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2509 mod[compile-time] -129[Integer], -32768[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -129 mod -32768;
endcode
compile error

$overflow on
code auto:2510 mod[Integer] -129[Integer], -32768[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:2511 mod[compile-time] -129[Integer], -32768[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -129 mod -32768;
endcode
compile error

$overflow off
code auto:2512 mod[Integer] -129[Integer], -32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2513 mod[compile-time] -129[Integer], -32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -129 mod -32767;
endcode
compile error

$overflow on
code auto:2514 mod[Integer] -129[Integer], -32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:2515 mod[compile-time] -129[Integer], -32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -129 mod -32767;
endcode
compile error

$overflow off
code auto:2516 mod[Integer] -129[Integer], -129[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2517 mod[compile-time] -129[Integer], -129[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -129 mod -129;
endcode
runtime noerror

$overflow on
code auto:2518 mod[Integer] -129[Integer], -129[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2519 mod[compile-time] -129[Integer], -129[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -129 mod -129;
endcode
varvalue r 0

$overflow off
code auto:2520 mod[Integer] -129[Integer], -128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2521 mod[compile-time] -129[Integer], -128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -129 mod -128;
endcode
runtime noerror

$overflow on
code auto:2522 mod[Integer] -129[Integer], -128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2523 mod[compile-time] -129[Integer], -128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -129 mod -128;
endcode
varvalue r -1

$overflow off
code auto:2524 mod[Integer] -129[Integer], -1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2525 mod[compile-time] -129[Integer], -1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -129 mod -1;
endcode
runtime noerror

$overflow on
code auto:2526 mod[Integer] -129[Integer], -1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2527 mod[compile-time] -129[Integer], -1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -129 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2528 mod[Integer] -129[Integer], 0[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2529 mod[compile-time] -129[Integer], 0[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -129 mod 0;
endcode
compile error

$overflow on
code auto:2530 mod[Integer] -129[Integer], 0[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2531 mod[compile-time] -129[Integer], 0[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -129 mod 0;
endcode
compile error

$overflow off
code auto:2532 mod[Integer] -129[Integer], 1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2533 mod[compile-time] -129[Integer], 1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -129 mod 1;
endcode
runtime noerror

$overflow on
code auto:2534 mod[Integer] -129[Integer], 1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2535 mod[compile-time] -129[Integer], 1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -129 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2536 mod[Integer] -129[Integer], 127[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2537 mod[compile-time] -129[Integer], 127[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -129 mod 127;
endcode
runtime noerror

$overflow on
code auto:2538 mod[Integer] -129[Integer], 127[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -2

code auto:2539 mod[compile-time] -129[Integer], 127[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -129 mod 127;
endcode
varvalue r -2

$overflow off
code auto:2540 mod[Integer] -129[Integer], 128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2541 mod[compile-time] -129[Integer], 128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -129 mod 128;
endcode
runtime noerror

$overflow on
code auto:2542 mod[Integer] -129[Integer], 128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2543 mod[compile-time] -129[Integer], 128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -129 mod 128;
endcode
varvalue r -1

$overflow off
code auto:2544 mod[Integer] -129[Integer], 32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2545 mod[compile-time] -129[Integer], 32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -129 mod 32767;
endcode
compile error

$overflow on
code auto:2546 mod[Integer] -129[Integer], 32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:2547 mod[compile-time] -129[Integer], 32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -129 mod 32767;
endcode
compile error

$overflow off
code auto:2548 mod[Integer] -128[Integer], -32768[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2549 mod[compile-time] -128[Integer], -32768[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -128 mod -32768;
endcode
runtime noerror

$overflow on
code auto:2550 mod[Integer] -128[Integer], -32768[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -128

code auto:2551 mod[compile-time] -128[Integer], -32768[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod -32768;
endcode
varvalue r -128

$overflow off
code auto:2552 mod[Integer] -128[Integer], -32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2553 mod[compile-time] -128[Integer], -32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -128 mod -32767;
endcode
runtime noerror

$overflow on
code auto:2554 mod[Integer] -128[Integer], -32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -128

code auto:2555 mod[compile-time] -128[Integer], -32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod -32767;
endcode
varvalue r -128

$overflow off
code auto:2556 mod[Integer] -128[Integer], -129[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2557 mod[compile-time] -128[Integer], -129[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -128 mod -129;
endcode
runtime noerror

$overflow on
code auto:2558 mod[Integer] -128[Integer], -129[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -128

code auto:2559 mod[compile-time] -128[Integer], -129[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod -129;
endcode
varvalue r -128

$overflow off
code auto:2560 mod[Integer] -128[Integer], -128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2561 mod[compile-time] -128[Integer], -128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -128 mod -128;
endcode
runtime noerror

$overflow on
code auto:2562 mod[Integer] -128[Integer], -128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2563 mod[compile-time] -128[Integer], -128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod -128;
endcode
varvalue r 0

$overflow off
code auto:2564 mod[Integer] -128[Integer], -1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2565 mod[compile-time] -128[Integer], -1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -128 mod -1;
endcode
runtime noerror

$overflow on
code auto:2566 mod[Integer] -128[Integer], -1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2567 mod[compile-time] -128[Integer], -1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2568 mod[Integer] -128[Integer], 0[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2569 mod[compile-time] -128[Integer], 0[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:2570 mod[Integer] -128[Integer], 0[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2571 mod[compile-time] -128[Integer], 0[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod 0;
endcode
compile error

$overflow off
code auto:2572 mod[Integer] -128[Integer], 1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2573 mod[compile-time] -128[Integer], 1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -128 mod 1;
endcode
runtime noerror

$overflow on
code auto:2574 mod[Integer] -128[Integer], 1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2575 mod[compile-time] -128[Integer], 1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2576 mod[Integer] -128[Integer], 127[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2577 mod[compile-time] -128[Integer], 127[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -128 mod 127;
endcode
runtime noerror

$overflow on
code auto:2578 mod[Integer] -128[Integer], 127[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2579 mod[compile-time] -128[Integer], 127[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod 127;
endcode
varvalue r -1

$overflow off
code auto:2580 mod[Integer] -128[Integer], 128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2581 mod[compile-time] -128[Integer], 128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -128 mod 128;
endcode
runtime noerror

$overflow on
code auto:2582 mod[Integer] -128[Integer], 128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2583 mod[compile-time] -128[Integer], 128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod 128;
endcode
varvalue r 0

$overflow off
code auto:2584 mod[Integer] -128[Integer], 32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2585 mod[compile-time] -128[Integer], 32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -128 mod 32767;
endcode
runtime noerror

$overflow on
code auto:2586 mod[Integer] -128[Integer], 32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -128

code auto:2587 mod[compile-time] -128[Integer], 32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -128 mod 32767;
endcode
varvalue r -128

$overflow off
code auto:2588 mod[Integer] -1[Integer], -32768[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2589 mod[compile-time] -1[Integer], -32768[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -1 mod -32768;
endcode
runtime noerror

$overflow on
code auto:2590 mod[Integer] -1[Integer], -32768[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2591 mod[compile-time] -1[Integer], -32768[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod -32768;
endcode
varvalue r -1

$overflow off
code auto:2592 mod[Integer] -1[Integer], -32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2593 mod[compile-time] -1[Integer], -32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -1 mod -32767;
endcode
runtime noerror

$overflow on
code auto:2594 mod[Integer] -1[Integer], -32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2595 mod[compile-time] -1[Integer], -32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod -32767;
endcode
varvalue r -1

$overflow off
code auto:2596 mod[Integer] -1[Integer], -129[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2597 mod[compile-time] -1[Integer], -129[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -1 mod -129;
endcode
runtime noerror

$overflow on
code auto:2598 mod[Integer] -1[Integer], -129[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2599 mod[compile-time] -1[Integer], -129[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod -129;
endcode
varvalue r -1

$overflow off
code auto:2600 mod[Integer] -1[Integer], -128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2601 mod[compile-time] -1[Integer], -128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -1 mod -128;
endcode
runtime noerror

$overflow on
code auto:2602 mod[Integer] -1[Integer], -128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2603 mod[compile-time] -1[Integer], -128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod -128;
endcode
varvalue r -1

$overflow off
code auto:2604 mod[Integer] -1[Integer], -1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2605 mod[compile-time] -1[Integer], -1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -1 mod -1;
endcode
runtime noerror

$overflow on
code auto:2606 mod[Integer] -1[Integer], -1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2607 mod[compile-time] -1[Integer], -1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2608 mod[Integer] -1[Integer], 0[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2609 mod[compile-time] -1[Integer], 0[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:2610 mod[Integer] -1[Integer], 0[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2611 mod[compile-time] -1[Integer], 0[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod 0;
endcode
compile error

$overflow off
code auto:2612 mod[Integer] -1[Integer], 1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2613 mod[compile-time] -1[Integer], 1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -1 mod 1;
endcode
runtime noerror

$overflow on
code auto:2614 mod[Integer] -1[Integer], 1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2615 mod[compile-time] -1[Integer], 1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2616 mod[Integer] -1[Integer], 127[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2617 mod[compile-time] -1[Integer], 127[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -1 mod 127;
endcode
runtime noerror

$overflow on
code auto:2618 mod[Integer] -1[Integer], 127[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2619 mod[compile-time] -1[Integer], 127[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod 127;
endcode
varvalue r -1

$overflow off
code auto:2620 mod[Integer] -1[Integer], 128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2621 mod[compile-time] -1[Integer], 128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -1 mod 128;
endcode
runtime noerror

$overflow on
code auto:2622 mod[Integer] -1[Integer], 128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2623 mod[compile-time] -1[Integer], 128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod 128;
endcode
varvalue r -1

$overflow off
code auto:2624 mod[Integer] -1[Integer], 32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2625 mod[compile-time] -1[Integer], 32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := -1 mod 32767;
endcode
runtime noerror

$overflow on
code auto:2626 mod[Integer] -1[Integer], 32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r -1

code auto:2627 mod[compile-time] -1[Integer], 32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := -1 mod 32767;
endcode
varvalue r -1

$overflow off
code auto:2628 mod[Integer] 0[Integer], -32768[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2629 mod[compile-time] 0[Integer], -32768[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod -32768;
endcode
runtime noerror

$overflow on
code auto:2630 mod[Integer] 0[Integer], -32768[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2631 mod[compile-time] 0[Integer], -32768[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod -32768;
endcode
varvalue r 0

$overflow off
code auto:2632 mod[Integer] 0[Integer], -32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2633 mod[compile-time] 0[Integer], -32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod -32767;
endcode
runtime noerror

$overflow on
code auto:2634 mod[Integer] 0[Integer], -32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2635 mod[compile-time] 0[Integer], -32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod -32767;
endcode
varvalue r 0

$overflow off
code auto:2636 mod[Integer] 0[Integer], -129[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2637 mod[compile-time] 0[Integer], -129[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod -129;
endcode
runtime noerror

$overflow on
code auto:2638 mod[Integer] 0[Integer], -129[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2639 mod[compile-time] 0[Integer], -129[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod -129;
endcode
varvalue r 0

$overflow off
code auto:2640 mod[Integer] 0[Integer], -128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2641 mod[compile-time] 0[Integer], -128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod -128;
endcode
runtime noerror

$overflow on
code auto:2642 mod[Integer] 0[Integer], -128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2643 mod[compile-time] 0[Integer], -128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow off
code auto:2644 mod[Integer] 0[Integer], -1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2645 mod[compile-time] 0[Integer], -1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod -1;
endcode
runtime noerror

$overflow on
code auto:2646 mod[Integer] 0[Integer], -1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2647 mod[compile-time] 0[Integer], -1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2648 mod[Integer] 0[Integer], 0[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2649 mod[compile-time] 0[Integer], 0[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:2650 mod[Integer] 0[Integer], 0[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2651 mod[compile-time] 0[Integer], 0[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:2652 mod[Integer] 0[Integer], 1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2653 mod[compile-time] 0[Integer], 1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 1;
endcode
runtime noerror

$overflow on
code auto:2654 mod[Integer] 0[Integer], 1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2655 mod[compile-time] 0[Integer], 1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2656 mod[Integer] 0[Integer], 127[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2657 mod[compile-time] 0[Integer], 127[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 127;
endcode
runtime noerror

$overflow on
code auto:2658 mod[Integer] 0[Integer], 127[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2659 mod[compile-time] 0[Integer], 127[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow off
code auto:2660 mod[Integer] 0[Integer], 128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2661 mod[compile-time] 0[Integer], 128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 128;
endcode
runtime noerror

$overflow on
code auto:2662 mod[Integer] 0[Integer], 128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2663 mod[compile-time] 0[Integer], 128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow off
code auto:2664 mod[Integer] 0[Integer], 32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2665 mod[compile-time] 0[Integer], 32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 32767;
endcode
runtime noerror

$overflow on
code auto:2666 mod[Integer] 0[Integer], 32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2667 mod[compile-time] 0[Integer], 32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:2668 mod[Integer] 1[Integer], -32768[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2669 mod[compile-time] 1[Integer], -32768[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod -32768;
endcode
runtime noerror

$overflow on
code auto:2670 mod[Integer] 1[Integer], -32768[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:2671 mod[compile-time] 1[Integer], -32768[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod -32768;
endcode
varvalue r 1

$overflow off
code auto:2672 mod[Integer] 1[Integer], -32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2673 mod[compile-time] 1[Integer], -32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod -32767;
endcode
runtime noerror

$overflow on
code auto:2674 mod[Integer] 1[Integer], -32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:2675 mod[compile-time] 1[Integer], -32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod -32767;
endcode
varvalue r 1

$overflow off
code auto:2676 mod[Integer] 1[Integer], -129[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2677 mod[compile-time] 1[Integer], -129[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod -129;
endcode
runtime noerror

$overflow on
code auto:2678 mod[Integer] 1[Integer], -129[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:2679 mod[compile-time] 1[Integer], -129[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod -129;
endcode
varvalue r 1

$overflow off
code auto:2680 mod[Integer] 1[Integer], -128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2681 mod[compile-time] 1[Integer], -128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod -128;
endcode
runtime noerror

$overflow on
code auto:2682 mod[Integer] 1[Integer], -128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:2683 mod[compile-time] 1[Integer], -128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow off
code auto:2684 mod[Integer] 1[Integer], -1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2685 mod[compile-time] 1[Integer], -1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod -1;
endcode
runtime noerror

$overflow on
code auto:2686 mod[Integer] 1[Integer], -1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2687 mod[compile-time] 1[Integer], -1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2688 mod[Integer] 1[Integer], 0[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2689 mod[compile-time] 1[Integer], 0[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:2690 mod[Integer] 1[Integer], 0[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2691 mod[compile-time] 1[Integer], 0[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 0;
endcode
compile error

$overflow off
code auto:2692 mod[Integer] 1[Integer], 1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2693 mod[compile-time] 1[Integer], 1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod 1;
endcode
runtime noerror

$overflow on
code auto:2694 mod[Integer] 1[Integer], 1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2695 mod[compile-time] 1[Integer], 1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2696 mod[Integer] 1[Integer], 127[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2697 mod[compile-time] 1[Integer], 127[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod 127;
endcode
runtime noerror

$overflow on
code auto:2698 mod[Integer] 1[Integer], 127[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:2699 mod[compile-time] 1[Integer], 127[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow off
code auto:2700 mod[Integer] 1[Integer], 128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2701 mod[compile-time] 1[Integer], 128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod 128;
endcode
runtime noerror

$overflow on
code auto:2702 mod[Integer] 1[Integer], 128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:2703 mod[compile-time] 1[Integer], 128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow off
code auto:2704 mod[Integer] 1[Integer], 32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2705 mod[compile-time] 1[Integer], 32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod 32767;
endcode
runtime noerror

$overflow on
code auto:2706 mod[Integer] 1[Integer], 32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:2707 mod[compile-time] 1[Integer], 32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:2708 mod[Integer] 127[Integer], -32768[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2709 mod[compile-time] 127[Integer], -32768[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod -32768;
endcode
runtime noerror

$overflow on
code auto:2710 mod[Integer] 127[Integer], -32768[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:2711 mod[compile-time] 127[Integer], -32768[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod -32768;
endcode
varvalue r 127

$overflow off
code auto:2712 mod[Integer] 127[Integer], -32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2713 mod[compile-time] 127[Integer], -32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod -32767;
endcode
runtime noerror

$overflow on
code auto:2714 mod[Integer] 127[Integer], -32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:2715 mod[compile-time] 127[Integer], -32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod -32767;
endcode
varvalue r 127

$overflow off
code auto:2716 mod[Integer] 127[Integer], -129[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2717 mod[compile-time] 127[Integer], -129[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod -129;
endcode
runtime noerror

$overflow on
code auto:2718 mod[Integer] 127[Integer], -129[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:2719 mod[compile-time] 127[Integer], -129[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod -129;
endcode
varvalue r 127

$overflow off
code auto:2720 mod[Integer] 127[Integer], -128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2721 mod[compile-time] 127[Integer], -128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod -128;
endcode
runtime noerror

$overflow on
code auto:2722 mod[Integer] 127[Integer], -128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:2723 mod[compile-time] 127[Integer], -128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow off
code auto:2724 mod[Integer] 127[Integer], -1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2725 mod[compile-time] 127[Integer], -1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod -1;
endcode
runtime noerror

$overflow on
code auto:2726 mod[Integer] 127[Integer], -1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2727 mod[compile-time] 127[Integer], -1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2728 mod[Integer] 127[Integer], 0[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2729 mod[compile-time] 127[Integer], 0[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:2730 mod[Integer] 127[Integer], 0[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2731 mod[compile-time] 127[Integer], 0[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 0;
endcode
compile error

$overflow off
code auto:2732 mod[Integer] 127[Integer], 1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2733 mod[compile-time] 127[Integer], 1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod 1;
endcode
runtime noerror

$overflow on
code auto:2734 mod[Integer] 127[Integer], 1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2735 mod[compile-time] 127[Integer], 1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2736 mod[Integer] 127[Integer], 127[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2737 mod[compile-time] 127[Integer], 127[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod 127;
endcode
runtime noerror

$overflow on
code auto:2738 mod[Integer] 127[Integer], 127[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2739 mod[compile-time] 127[Integer], 127[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:2740 mod[Integer] 127[Integer], 128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2741 mod[compile-time] 127[Integer], 128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod 128;
endcode
runtime noerror

$overflow on
code auto:2742 mod[Integer] 127[Integer], 128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:2743 mod[compile-time] 127[Integer], 128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow off
code auto:2744 mod[Integer] 127[Integer], 32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2745 mod[compile-time] 127[Integer], 32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod 32767;
endcode
runtime noerror

$overflow on
code auto:2746 mod[Integer] 127[Integer], 32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:2747 mod[compile-time] 127[Integer], 32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow off
code auto:2748 mod[Integer] 128[Integer], -32768[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2749 mod[compile-time] 128[Integer], -32768[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod -32768;
endcode
compile error

$overflow on
code auto:2750 mod[Integer] 128[Integer], -32768[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:2751 mod[compile-time] 128[Integer], -32768[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod -32768;
endcode
compile error

$overflow off
code auto:2752 mod[Integer] 128[Integer], -32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2753 mod[compile-time] 128[Integer], -32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod -32767;
endcode
compile error

$overflow on
code auto:2754 mod[Integer] 128[Integer], -32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:2755 mod[compile-time] 128[Integer], -32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod -32767;
endcode
compile error

$overflow off
code auto:2756 mod[Integer] 128[Integer], -129[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2757 mod[compile-time] 128[Integer], -129[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod -129;
endcode
compile error

$overflow on
code auto:2758 mod[Integer] 128[Integer], -129[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:2759 mod[compile-time] 128[Integer], -129[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod -129;
endcode
compile error

$overflow off
code auto:2760 mod[Integer] 128[Integer], -128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2761 mod[compile-time] 128[Integer], -128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod -128;
endcode
runtime noerror

$overflow on
code auto:2762 mod[Integer] 128[Integer], -128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2763 mod[compile-time] 128[Integer], -128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod -128;
endcode
varvalue r 0

$overflow off
code auto:2764 mod[Integer] 128[Integer], -1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2765 mod[compile-time] 128[Integer], -1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod -1;
endcode
runtime noerror

$overflow on
code auto:2766 mod[Integer] 128[Integer], -1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2767 mod[compile-time] 128[Integer], -1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2768 mod[Integer] 128[Integer], 0[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2769 mod[compile-time] 128[Integer], 0[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:2770 mod[Integer] 128[Integer], 0[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2771 mod[compile-time] 128[Integer], 0[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod 0;
endcode
compile error

$overflow off
code auto:2772 mod[Integer] 128[Integer], 1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2773 mod[compile-time] 128[Integer], 1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod 1;
endcode
runtime noerror

$overflow on
code auto:2774 mod[Integer] 128[Integer], 1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2775 mod[compile-time] 128[Integer], 1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2776 mod[Integer] 128[Integer], 127[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2777 mod[compile-time] 128[Integer], 127[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod 127;
endcode
runtime noerror

$overflow on
code auto:2778 mod[Integer] 128[Integer], 127[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:2779 mod[compile-time] 128[Integer], 127[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow off
code auto:2780 mod[Integer] 128[Integer], 128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2781 mod[compile-time] 128[Integer], 128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod 128;
endcode
runtime noerror

$overflow on
code auto:2782 mod[Integer] 128[Integer], 128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2783 mod[compile-time] 128[Integer], 128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod 128;
endcode
varvalue r 0

$overflow off
code auto:2784 mod[Integer] 128[Integer], 32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2785 mod[compile-time] 128[Integer], 32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod 32767;
endcode
compile error

$overflow on
code auto:2786 mod[Integer] 128[Integer], 32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:2787 mod[compile-time] 128[Integer], 32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod 32767;
endcode
compile error

$overflow off
code auto:2788 mod[Integer] 32767[Integer], -32768[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2789 mod[compile-time] 32767[Integer], -32768[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod -32768;
endcode
compile error

$overflow on
code auto:2790 mod[Integer] 32767[Integer], -32768[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:2791 mod[compile-time] 32767[Integer], -32768[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod -32768;
endcode
compile error

$overflow off
code auto:2792 mod[Integer] 32767[Integer], -32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2793 mod[compile-time] 32767[Integer], -32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod -32767;
endcode
runtime noerror

$overflow on
code auto:2794 mod[Integer] 32767[Integer], -32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2795 mod[compile-time] 32767[Integer], -32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod -32767;
endcode
varvalue r 0

$overflow off
code auto:2796 mod[Integer] 32767[Integer], -129[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2797 mod[compile-time] 32767[Integer], -129[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod -129;
endcode
runtime noerror

$overflow on
code auto:2798 mod[Integer] 32767[Integer], -129[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -129;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:2799 mod[compile-time] 32767[Integer], -129[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod -129;
endcode
varvalue r 1

$overflow off
code auto:2800 mod[Integer] 32767[Integer], -128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2801 mod[compile-time] 32767[Integer], -128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod -128;
endcode
runtime noerror

$overflow on
code auto:2802 mod[Integer] 32767[Integer], -128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:2803 mod[compile-time] 32767[Integer], -128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod -128;
endcode
varvalue r 127

$overflow off
code auto:2804 mod[Integer] 32767[Integer], -1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2805 mod[compile-time] 32767[Integer], -1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod -1;
endcode
runtime noerror

$overflow on
code auto:2806 mod[Integer] 32767[Integer], -1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2807 mod[compile-time] 32767[Integer], -1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod -1;
endcode
varvalue r 0

$overflow off
code auto:2808 mod[Integer] 32767[Integer], 0[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2809 mod[compile-time] 32767[Integer], 0[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:2810 mod[Integer] 32767[Integer], 0[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2811 mod[compile-time] 32767[Integer], 0[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 0;
endcode
compile error

$overflow off
code auto:2812 mod[Integer] 32767[Integer], 1[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2813 mod[compile-time] 32767[Integer], 1[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 1;
endcode
runtime noerror

$overflow on
code auto:2814 mod[Integer] 32767[Integer], 1[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2815 mod[compile-time] 32767[Integer], 1[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow off
code auto:2816 mod[Integer] 32767[Integer], 127[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2817 mod[compile-time] 32767[Integer], 127[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 127;
endcode
runtime noerror

$overflow on
code auto:2818 mod[Integer] 32767[Integer], 127[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:2819 mod[compile-time] 32767[Integer], 127[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow off
code auto:2820 mod[Integer] 32767[Integer], 128[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2821 mod[compile-time] 32767[Integer], 128[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 128;
endcode
runtime noerror

$overflow on
code auto:2822 mod[Integer] 32767[Integer], 128[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:2823 mod[compile-time] 32767[Integer], 128[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 128;
endcode
varvalue r 127

$overflow off
code auto:2824 mod[Integer] 32767[Integer], 32767[Integer] -> [Int8] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:2825 mod[compile-time] 32767[Integer], 32767[Integer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:2826 mod[Integer] 32767[Integer], 32767[Integer] -> [Int8] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:2827 mod[compile-time] 32767[Integer], 32767[Integer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:2828 mod[Integer] -32768[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2829 mod[compile-time] -32768[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -32768;
endcode
varvalue r 0

$overflow on
code auto:2830 mod[Integer] -32768[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2831 mod[compile-time] -32768[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -32767;
endcode
varvalue r -1

$overflow on
code auto:2832 mod[Integer] -32768[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -2

code auto:2833 mod[compile-time] -32768[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -129;
endcode
varvalue r -2

$overflow on
code auto:2834 mod[Integer] -32768[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2835 mod[compile-time] -32768[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -128;
endcode
varvalue r 0

$overflow on
code auto:2836 mod[Integer] -32768[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2837 mod[compile-time] -32768[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod -1;
endcode
varvalue r 0

$overflow on
code auto:2838 mod[Integer] -32768[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2839 mod[compile-time] -32768[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 0;
endcode
compile error

$overflow on
code auto:2840 mod[Integer] -32768[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2841 mod[compile-time] -32768[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 1;
endcode
varvalue r 0

$overflow on
code auto:2842 mod[Integer] -32768[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -2

code auto:2843 mod[compile-time] -32768[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 127;
endcode
varvalue r -2

$overflow on
code auto:2844 mod[Integer] -32768[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2845 mod[compile-time] -32768[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 128;
endcode
varvalue r 0

$overflow on
code auto:2846 mod[Integer] -32768[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2847 mod[compile-time] -32768[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32768 mod 32767;
endcode
varvalue r -1

$overflow on
code auto:2848 mod[Integer] -32767[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -32767

code auto:2849 mod[compile-time] -32767[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -32768;
endcode
varvalue r -32767

$overflow on
code auto:2850 mod[Integer] -32767[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2851 mod[compile-time] -32767[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -32767;
endcode
varvalue r 0

$overflow on
code auto:2852 mod[Integer] -32767[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2853 mod[compile-time] -32767[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -129;
endcode
varvalue r -1

$overflow on
code auto:2854 mod[Integer] -32767[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:2855 mod[compile-time] -32767[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -128;
endcode
varvalue r -127

$overflow on
code auto:2856 mod[Integer] -32767[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2857 mod[compile-time] -32767[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod -1;
endcode
varvalue r 0

$overflow on
code auto:2858 mod[Integer] -32767[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2859 mod[compile-time] -32767[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 0;
endcode
compile error

$overflow on
code auto:2860 mod[Integer] -32767[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2861 mod[compile-time] -32767[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:2862 mod[Integer] -32767[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2863 mod[compile-time] -32767[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 127;
endcode
varvalue r -1

$overflow on
code auto:2864 mod[Integer] -32767[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -127

code auto:2865 mod[compile-time] -32767[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 128;
endcode
varvalue r -127

$overflow on
code auto:2866 mod[Integer] -32767[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2867 mod[compile-time] -32767[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:2868 mod[Integer] -129[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -129

code auto:2869 mod[compile-time] -129[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -32768;
endcode
varvalue r -129

$overflow on
code auto:2870 mod[Integer] -129[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -129

code auto:2871 mod[compile-time] -129[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -32767;
endcode
varvalue r -129

$overflow on
code auto:2872 mod[Integer] -129[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2873 mod[compile-time] -129[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -129;
endcode
varvalue r 0

$overflow on
code auto:2874 mod[Integer] -129[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2875 mod[compile-time] -129[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -128;
endcode
varvalue r -1

$overflow on
code auto:2876 mod[Integer] -129[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2877 mod[compile-time] -129[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod -1;
endcode
varvalue r 0

$overflow on
code auto:2878 mod[Integer] -129[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2879 mod[compile-time] -129[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 0;
endcode
compile error

$overflow on
code auto:2880 mod[Integer] -129[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2881 mod[compile-time] -129[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 1;
endcode
varvalue r 0

$overflow on
code auto:2882 mod[Integer] -129[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -2

code auto:2883 mod[compile-time] -129[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 127;
endcode
varvalue r -2

$overflow on
code auto:2884 mod[Integer] -129[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2885 mod[compile-time] -129[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 128;
endcode
varvalue r -1

$overflow on
code auto:2886 mod[Integer] -129[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -129

code auto:2887 mod[compile-time] -129[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -129 mod 32767;
endcode
varvalue r -129

$overflow on
code auto:2888 mod[Integer] -128[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:2889 mod[compile-time] -128[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -32768;
endcode
varvalue r -128

$overflow on
code auto:2890 mod[Integer] -128[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:2891 mod[compile-time] -128[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -32767;
endcode
varvalue r -128

$overflow on
code auto:2892 mod[Integer] -128[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:2893 mod[compile-time] -128[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -129;
endcode
varvalue r -128

$overflow on
code auto:2894 mod[Integer] -128[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2895 mod[compile-time] -128[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -128;
endcode
varvalue r 0

$overflow on
code auto:2896 mod[Integer] -128[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2897 mod[compile-time] -128[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod -1;
endcode
varvalue r 0

$overflow on
code auto:2898 mod[Integer] -128[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2899 mod[compile-time] -128[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:2900 mod[Integer] -128[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2901 mod[compile-time] -128[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:2902 mod[Integer] -128[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2903 mod[compile-time] -128[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 127;
endcode
varvalue r -1

$overflow on
code auto:2904 mod[Integer] -128[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2905 mod[compile-time] -128[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 128;
endcode
varvalue r 0

$overflow on
code auto:2906 mod[Integer] -128[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -128

code auto:2907 mod[compile-time] -128[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -128 mod 32767;
endcode
varvalue r -128

$overflow on
code auto:2908 mod[Integer] -1[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2909 mod[compile-time] -1[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -32768;
endcode
varvalue r -1

$overflow on
code auto:2910 mod[Integer] -1[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2911 mod[compile-time] -1[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -32767;
endcode
varvalue r -1

$overflow on
code auto:2912 mod[Integer] -1[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2913 mod[compile-time] -1[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -129;
endcode
varvalue r -1

$overflow on
code auto:2914 mod[Integer] -1[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2915 mod[compile-time] -1[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -128;
endcode
varvalue r -1

$overflow on
code auto:2916 mod[Integer] -1[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2917 mod[compile-time] -1[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:2918 mod[Integer] -1[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2919 mod[compile-time] -1[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:2920 mod[Integer] -1[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2921 mod[compile-time] -1[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:2922 mod[Integer] -1[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2923 mod[compile-time] -1[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 127;
endcode
varvalue r -1

$overflow on
code auto:2924 mod[Integer] -1[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2925 mod[compile-time] -1[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 128;
endcode
varvalue r -1

$overflow on
code auto:2926 mod[Integer] -1[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r -1

code auto:2927 mod[compile-time] -1[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := -1 mod 32767;
endcode
varvalue r -1

$overflow on
code auto:2928 mod[Integer] 0[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2929 mod[compile-time] 0[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -32768;
endcode
varvalue r 0

$overflow on
code auto:2930 mod[Integer] 0[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2931 mod[compile-time] 0[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -32767;
endcode
varvalue r 0

$overflow on
code auto:2932 mod[Integer] 0[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2933 mod[compile-time] 0[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -129;
endcode
varvalue r 0

$overflow on
code auto:2934 mod[Integer] 0[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2935 mod[compile-time] 0[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow on
code auto:2936 mod[Integer] 0[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2937 mod[compile-time] 0[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow on
code auto:2938 mod[Integer] 0[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2939 mod[compile-time] 0[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:2940 mod[Integer] 0[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2941 mod[compile-time] 0[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:2942 mod[Integer] 0[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2943 mod[compile-time] 0[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:2944 mod[Integer] 0[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2945 mod[compile-time] 0[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow on
code auto:2946 mod[Integer] 0[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2947 mod[compile-time] 0[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:2948 mod[Integer] 1[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:2949 mod[compile-time] 1[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -32768;
endcode
varvalue r 1

$overflow on
code auto:2950 mod[Integer] 1[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:2951 mod[compile-time] 1[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -32767;
endcode
varvalue r 1

$overflow on
code auto:2952 mod[Integer] 1[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:2953 mod[compile-time] 1[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -129;
endcode
varvalue r 1

$overflow on
code auto:2954 mod[Integer] 1[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:2955 mod[compile-time] 1[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow on
code auto:2956 mod[Integer] 1[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2957 mod[compile-time] 1[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow on
code auto:2958 mod[Integer] 1[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2959 mod[compile-time] 1[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:2960 mod[Integer] 1[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2961 mod[compile-time] 1[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:2962 mod[Integer] 1[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:2963 mod[compile-time] 1[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow on
code auto:2964 mod[Integer] 1[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:2965 mod[compile-time] 1[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow on
code auto:2966 mod[Integer] 1[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:2967 mod[compile-time] 1[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:2968 mod[Integer] 127[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:2969 mod[compile-time] 127[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -32768;
endcode
varvalue r 127

$overflow on
code auto:2970 mod[Integer] 127[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:2971 mod[compile-time] 127[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -32767;
endcode
varvalue r 127

$overflow on
code auto:2972 mod[Integer] 127[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:2973 mod[compile-time] 127[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -129;
endcode
varvalue r 127

$overflow on
code auto:2974 mod[Integer] 127[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:2975 mod[compile-time] 127[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow on
code auto:2976 mod[Integer] 127[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2977 mod[compile-time] 127[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow on
code auto:2978 mod[Integer] 127[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2979 mod[compile-time] 127[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:2980 mod[Integer] 127[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2981 mod[compile-time] 127[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:2982 mod[Integer] 127[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2983 mod[compile-time] 127[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:2984 mod[Integer] 127[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:2985 mod[compile-time] 127[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow on
code auto:2986 mod[Integer] 127[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:2987 mod[compile-time] 127[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow on
code auto:2988 mod[Integer] 128[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:2989 mod[compile-time] 128[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -32768;
endcode
varvalue r 128

$overflow on
code auto:2990 mod[Integer] 128[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:2991 mod[compile-time] 128[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -32767;
endcode
varvalue r 128

$overflow on
code auto:2992 mod[Integer] 128[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:2993 mod[compile-time] 128[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -129;
endcode
varvalue r 128

$overflow on
code auto:2994 mod[Integer] 128[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2995 mod[compile-time] 128[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -128;
endcode
varvalue r 0

$overflow on
code auto:2996 mod[Integer] 128[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:2997 mod[compile-time] 128[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod -1;
endcode
varvalue r 0

$overflow on
code auto:2998 mod[Integer] 128[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:2999 mod[compile-time] 128[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:3000 mod[Integer] 128[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3001 mod[compile-time] 128[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:3002 mod[Integer] 128[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:3003 mod[compile-time] 128[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow on
code auto:3004 mod[Integer] 128[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3005 mod[compile-time] 128[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 128;
endcode
varvalue r 0

$overflow on
code auto:3006 mod[Integer] 128[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:3007 mod[compile-time] 128[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 32767;
endcode
varvalue r 128

$overflow on
code auto:3008 mod[Integer] 32767[Integer], -32768[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 32767

code auto:3009 mod[compile-time] 32767[Integer], -32768[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -32768;
endcode
varvalue r 32767

$overflow on
code auto:3010 mod[Integer] 32767[Integer], -32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3011 mod[compile-time] 32767[Integer], -32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -32767;
endcode
varvalue r 0

$overflow on
code auto:3012 mod[Integer] 32767[Integer], -129[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -129;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:3013 mod[compile-time] 32767[Integer], -129[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -129;
endcode
varvalue r 1

$overflow on
code auto:3014 mod[Integer] 32767[Integer], -128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:3015 mod[compile-time] 32767[Integer], -128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -128;
endcode
varvalue r 127

$overflow on
code auto:3016 mod[Integer] 32767[Integer], -1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3017 mod[compile-time] 32767[Integer], -1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod -1;
endcode
varvalue r 0

$overflow on
code auto:3018 mod[Integer] 32767[Integer], 0[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3019 mod[compile-time] 32767[Integer], 0[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:3020 mod[Integer] 32767[Integer], 1[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3021 mod[compile-time] 32767[Integer], 1[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow on
code auto:3022 mod[Integer] 32767[Integer], 127[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:3023 mod[compile-time] 32767[Integer], 127[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow on
code auto:3024 mod[Integer] 32767[Integer], 128[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:3025 mod[compile-time] 32767[Integer], 128[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 128;
endcode
varvalue r 127

$overflow on
code auto:3026 mod[Integer] 32767[Integer], 32767[Integer] -> [Integer] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3027 mod[compile-time] 32767[Integer], 32767[Integer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:3028 mod[Integer] -32768[Integer], -32768[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3029 mod[compile-time] -32768[Integer], -32768[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32768 mod -32768;
endcode
runtime noerror

$overflow on
code auto:3030 mod[Integer] -32768[Integer], -32768[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3031 mod[compile-time] -32768[Integer], -32768[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32768 mod -32768;
endcode
varvalue r 0

$overflow off
code auto:3032 mod[Integer] -32768[Integer], -32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3033 mod[compile-time] -32768[Integer], -32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32768 mod -32767;
endcode
compile error

$overflow on
code auto:3034 mod[Integer] -32768[Integer], -32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3035 mod[compile-time] -32768[Integer], -32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32768 mod -32767;
endcode
compile error

$overflow off
code auto:3036 mod[Integer] -32768[Integer], -129[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3037 mod[compile-time] -32768[Integer], -129[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32768 mod -129;
endcode
compile error

$overflow on
code auto:3038 mod[Integer] -32768[Integer], -129[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3039 mod[compile-time] -32768[Integer], -129[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32768 mod -129;
endcode
compile error

$overflow off
code auto:3040 mod[Integer] -32768[Integer], -128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3041 mod[compile-time] -32768[Integer], -128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32768 mod -128;
endcode
runtime noerror

$overflow on
code auto:3042 mod[Integer] -32768[Integer], -128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3043 mod[compile-time] -32768[Integer], -128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32768 mod -128;
endcode
varvalue r 0

$overflow off
code auto:3044 mod[Integer] -32768[Integer], -1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3045 mod[compile-time] -32768[Integer], -1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32768 mod -1;
endcode
runtime noerror

$overflow on
code auto:3046 mod[Integer] -32768[Integer], -1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3047 mod[compile-time] -32768[Integer], -1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32768 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3048 mod[Integer] -32768[Integer], 0[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3049 mod[compile-time] -32768[Integer], 0[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32768 mod 0;
endcode
compile error

$overflow on
code auto:3050 mod[Integer] -32768[Integer], 0[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3051 mod[compile-time] -32768[Integer], 0[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32768 mod 0;
endcode
compile error

$overflow off
code auto:3052 mod[Integer] -32768[Integer], 1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3053 mod[compile-time] -32768[Integer], 1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32768 mod 1;
endcode
runtime noerror

$overflow on
code auto:3054 mod[Integer] -32768[Integer], 1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3055 mod[compile-time] -32768[Integer], 1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32768 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3056 mod[Integer] -32768[Integer], 127[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3057 mod[compile-time] -32768[Integer], 127[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32768 mod 127;
endcode
compile error

$overflow on
code auto:3058 mod[Integer] -32768[Integer], 127[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3059 mod[compile-time] -32768[Integer], 127[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32768 mod 127;
endcode
compile error

$overflow off
code auto:3060 mod[Integer] -32768[Integer], 128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3061 mod[compile-time] -32768[Integer], 128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32768 mod 128;
endcode
runtime noerror

$overflow on
code auto:3062 mod[Integer] -32768[Integer], 128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3063 mod[compile-time] -32768[Integer], 128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32768 mod 128;
endcode
varvalue r 0

$overflow off
code auto:3064 mod[Integer] -32768[Integer], 32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3065 mod[compile-time] -32768[Integer], 32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32768 mod 32767;
endcode
compile error

$overflow on
code auto:3066 mod[Integer] -32768[Integer], 32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3067 mod[compile-time] -32768[Integer], 32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32768 mod 32767;
endcode
compile error

$overflow off
code auto:3068 mod[Integer] -32767[Integer], -32768[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3069 mod[compile-time] -32767[Integer], -32768[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32767 mod -32768;
endcode
compile error

$overflow on
code auto:3070 mod[Integer] -32767[Integer], -32768[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3071 mod[compile-time] -32767[Integer], -32768[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32767 mod -32768;
endcode
compile error

$overflow off
code auto:3072 mod[Integer] -32767[Integer], -32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3073 mod[compile-time] -32767[Integer], -32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32767 mod -32767;
endcode
runtime noerror

$overflow on
code auto:3074 mod[Integer] -32767[Integer], -32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3075 mod[compile-time] -32767[Integer], -32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32767 mod -32767;
endcode
varvalue r 0

$overflow off
code auto:3076 mod[Integer] -32767[Integer], -129[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3077 mod[compile-time] -32767[Integer], -129[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32767 mod -129;
endcode
compile error

$overflow on
code auto:3078 mod[Integer] -32767[Integer], -129[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3079 mod[compile-time] -32767[Integer], -129[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32767 mod -129;
endcode
compile error

$overflow off
code auto:3080 mod[Integer] -32767[Integer], -128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3081 mod[compile-time] -32767[Integer], -128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32767 mod -128;
endcode
compile error

$overflow on
code auto:3082 mod[Integer] -32767[Integer], -128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3083 mod[compile-time] -32767[Integer], -128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32767 mod -128;
endcode
compile error

$overflow off
code auto:3084 mod[Integer] -32767[Integer], -1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3085 mod[compile-time] -32767[Integer], -1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32767 mod -1;
endcode
runtime noerror

$overflow on
code auto:3086 mod[Integer] -32767[Integer], -1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3087 mod[compile-time] -32767[Integer], -1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32767 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3088 mod[Integer] -32767[Integer], 0[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3089 mod[compile-time] -32767[Integer], 0[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32767 mod 0;
endcode
compile error

$overflow on
code auto:3090 mod[Integer] -32767[Integer], 0[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3091 mod[compile-time] -32767[Integer], 0[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32767 mod 0;
endcode
compile error

$overflow off
code auto:3092 mod[Integer] -32767[Integer], 1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3093 mod[compile-time] -32767[Integer], 1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32767 mod 1;
endcode
runtime noerror

$overflow on
code auto:3094 mod[Integer] -32767[Integer], 1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3095 mod[compile-time] -32767[Integer], 1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32767 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3096 mod[Integer] -32767[Integer], 127[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3097 mod[compile-time] -32767[Integer], 127[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32767 mod 127;
endcode
compile error

$overflow on
code auto:3098 mod[Integer] -32767[Integer], 127[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3099 mod[compile-time] -32767[Integer], 127[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32767 mod 127;
endcode
compile error

$overflow off
code auto:3100 mod[Integer] -32767[Integer], 128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3101 mod[compile-time] -32767[Integer], 128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32767 mod 128;
endcode
compile error

$overflow on
code auto:3102 mod[Integer] -32767[Integer], 128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3103 mod[compile-time] -32767[Integer], 128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32767 mod 128;
endcode
compile error

$overflow off
code auto:3104 mod[Integer] -32767[Integer], 32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3105 mod[compile-time] -32767[Integer], 32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:3106 mod[Integer] -32767[Integer], 32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3107 mod[compile-time] -32767[Integer], 32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:3108 mod[Integer] -129[Integer], -32768[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3109 mod[compile-time] -129[Integer], -32768[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -129 mod -32768;
endcode
compile error

$overflow on
code auto:3110 mod[Integer] -129[Integer], -32768[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3111 mod[compile-time] -129[Integer], -32768[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -129 mod -32768;
endcode
compile error

$overflow off
code auto:3112 mod[Integer] -129[Integer], -32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3113 mod[compile-time] -129[Integer], -32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -129 mod -32767;
endcode
compile error

$overflow on
code auto:3114 mod[Integer] -129[Integer], -32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3115 mod[compile-time] -129[Integer], -32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -129 mod -32767;
endcode
compile error

$overflow off
code auto:3116 mod[Integer] -129[Integer], -129[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3117 mod[compile-time] -129[Integer], -129[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -129 mod -129;
endcode
runtime noerror

$overflow on
code auto:3118 mod[Integer] -129[Integer], -129[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3119 mod[compile-time] -129[Integer], -129[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -129 mod -129;
endcode
varvalue r 0

$overflow off
code auto:3120 mod[Integer] -129[Integer], -128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3121 mod[compile-time] -129[Integer], -128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -129 mod -128;
endcode
compile error

$overflow on
code auto:3122 mod[Integer] -129[Integer], -128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3123 mod[compile-time] -129[Integer], -128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -129 mod -128;
endcode
compile error

$overflow off
code auto:3124 mod[Integer] -129[Integer], -1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3125 mod[compile-time] -129[Integer], -1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -129 mod -1;
endcode
runtime noerror

$overflow on
code auto:3126 mod[Integer] -129[Integer], -1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3127 mod[compile-time] -129[Integer], -1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -129 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3128 mod[Integer] -129[Integer], 0[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3129 mod[compile-time] -129[Integer], 0[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -129 mod 0;
endcode
compile error

$overflow on
code auto:3130 mod[Integer] -129[Integer], 0[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3131 mod[compile-time] -129[Integer], 0[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -129 mod 0;
endcode
compile error

$overflow off
code auto:3132 mod[Integer] -129[Integer], 1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3133 mod[compile-time] -129[Integer], 1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -129 mod 1;
endcode
runtime noerror

$overflow on
code auto:3134 mod[Integer] -129[Integer], 1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3135 mod[compile-time] -129[Integer], 1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -129 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3136 mod[Integer] -129[Integer], 127[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3137 mod[compile-time] -129[Integer], 127[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -129 mod 127;
endcode
compile error

$overflow on
code auto:3138 mod[Integer] -129[Integer], 127[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3139 mod[compile-time] -129[Integer], 127[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -129 mod 127;
endcode
compile error

$overflow off
code auto:3140 mod[Integer] -129[Integer], 128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3141 mod[compile-time] -129[Integer], 128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -129 mod 128;
endcode
compile error

$overflow on
code auto:3142 mod[Integer] -129[Integer], 128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3143 mod[compile-time] -129[Integer], 128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -129 mod 128;
endcode
compile error

$overflow off
code auto:3144 mod[Integer] -129[Integer], 32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3145 mod[compile-time] -129[Integer], 32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -129 mod 32767;
endcode
compile error

$overflow on
code auto:3146 mod[Integer] -129[Integer], 32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3147 mod[compile-time] -129[Integer], 32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -129 mod 32767;
endcode
compile error

$overflow off
code auto:3148 mod[Integer] -128[Integer], -32768[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3149 mod[compile-time] -128[Integer], -32768[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod -32768;
endcode
compile error

$overflow on
code auto:3150 mod[Integer] -128[Integer], -32768[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3151 mod[compile-time] -128[Integer], -32768[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod -32768;
endcode
compile error

$overflow off
code auto:3152 mod[Integer] -128[Integer], -32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3153 mod[compile-time] -128[Integer], -32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod -32767;
endcode
compile error

$overflow on
code auto:3154 mod[Integer] -128[Integer], -32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3155 mod[compile-time] -128[Integer], -32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod -32767;
endcode
compile error

$overflow off
code auto:3156 mod[Integer] -128[Integer], -129[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3157 mod[compile-time] -128[Integer], -129[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod -129;
endcode
compile error

$overflow on
code auto:3158 mod[Integer] -128[Integer], -129[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3159 mod[compile-time] -128[Integer], -129[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod -129;
endcode
compile error

$overflow off
code auto:3160 mod[Integer] -128[Integer], -128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3161 mod[compile-time] -128[Integer], -128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod -128;
endcode
runtime noerror

$overflow on
code auto:3162 mod[Integer] -128[Integer], -128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3163 mod[compile-time] -128[Integer], -128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod -128;
endcode
varvalue r 0

$overflow off
code auto:3164 mod[Integer] -128[Integer], -1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3165 mod[compile-time] -128[Integer], -1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod -1;
endcode
runtime noerror

$overflow on
code auto:3166 mod[Integer] -128[Integer], -1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3167 mod[compile-time] -128[Integer], -1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3168 mod[Integer] -128[Integer], 0[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3169 mod[compile-time] -128[Integer], 0[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:3170 mod[Integer] -128[Integer], 0[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3171 mod[compile-time] -128[Integer], 0[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod 0;
endcode
compile error

$overflow off
code auto:3172 mod[Integer] -128[Integer], 1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3173 mod[compile-time] -128[Integer], 1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod 1;
endcode
runtime noerror

$overflow on
code auto:3174 mod[Integer] -128[Integer], 1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3175 mod[compile-time] -128[Integer], 1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3176 mod[Integer] -128[Integer], 127[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3177 mod[compile-time] -128[Integer], 127[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod 127;
endcode
compile error

$overflow on
code auto:3178 mod[Integer] -128[Integer], 127[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3179 mod[compile-time] -128[Integer], 127[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod 127;
endcode
compile error

$overflow off
code auto:3180 mod[Integer] -128[Integer], 128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3181 mod[compile-time] -128[Integer], 128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod 128;
endcode
runtime noerror

$overflow on
code auto:3182 mod[Integer] -128[Integer], 128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3183 mod[compile-time] -128[Integer], 128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod 128;
endcode
varvalue r 0

$overflow off
code auto:3184 mod[Integer] -128[Integer], 32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3185 mod[compile-time] -128[Integer], 32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -128 mod 32767;
endcode
compile error

$overflow on
code auto:3186 mod[Integer] -128[Integer], 32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3187 mod[compile-time] -128[Integer], 32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -128 mod 32767;
endcode
compile error

$overflow off
code auto:3188 mod[Integer] -1[Integer], -32768[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3189 mod[compile-time] -1[Integer], -32768[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod -32768;
endcode
compile error

$overflow on
code auto:3190 mod[Integer] -1[Integer], -32768[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3191 mod[compile-time] -1[Integer], -32768[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod -32768;
endcode
compile error

$overflow off
code auto:3192 mod[Integer] -1[Integer], -32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3193 mod[compile-time] -1[Integer], -32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod -32767;
endcode
compile error

$overflow on
code auto:3194 mod[Integer] -1[Integer], -32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3195 mod[compile-time] -1[Integer], -32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod -32767;
endcode
compile error

$overflow off
code auto:3196 mod[Integer] -1[Integer], -129[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3197 mod[compile-time] -1[Integer], -129[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod -129;
endcode
compile error

$overflow on
code auto:3198 mod[Integer] -1[Integer], -129[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3199 mod[compile-time] -1[Integer], -129[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod -129;
endcode
compile error

$overflow off
code auto:3200 mod[Integer] -1[Integer], -128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3201 mod[compile-time] -1[Integer], -128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod -128;
endcode
compile error

$overflow on
code auto:3202 mod[Integer] -1[Integer], -128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3203 mod[compile-time] -1[Integer], -128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod -128;
endcode
compile error

$overflow off
code auto:3204 mod[Integer] -1[Integer], -1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3205 mod[compile-time] -1[Integer], -1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod -1;
endcode
runtime noerror

$overflow on
code auto:3206 mod[Integer] -1[Integer], -1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3207 mod[compile-time] -1[Integer], -1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3208 mod[Integer] -1[Integer], 0[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3209 mod[compile-time] -1[Integer], 0[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:3210 mod[Integer] -1[Integer], 0[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3211 mod[compile-time] -1[Integer], 0[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod 0;
endcode
compile error

$overflow off
code auto:3212 mod[Integer] -1[Integer], 1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3213 mod[compile-time] -1[Integer], 1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod 1;
endcode
runtime noerror

$overflow on
code auto:3214 mod[Integer] -1[Integer], 1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3215 mod[compile-time] -1[Integer], 1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3216 mod[Integer] -1[Integer], 127[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3217 mod[compile-time] -1[Integer], 127[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod 127;
endcode
compile error

$overflow on
code auto:3218 mod[Integer] -1[Integer], 127[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3219 mod[compile-time] -1[Integer], 127[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod 127;
endcode
compile error

$overflow off
code auto:3220 mod[Integer] -1[Integer], 128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3221 mod[compile-time] -1[Integer], 128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod 128;
endcode
compile error

$overflow on
code auto:3222 mod[Integer] -1[Integer], 128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3223 mod[compile-time] -1[Integer], 128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod 128;
endcode
compile error

$overflow off
code auto:3224 mod[Integer] -1[Integer], 32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3225 mod[compile-time] -1[Integer], 32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := -1 mod 32767;
endcode
compile error

$overflow on
code auto:3226 mod[Integer] -1[Integer], 32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3227 mod[compile-time] -1[Integer], 32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := -1 mod 32767;
endcode
compile error

$overflow off
code auto:3228 mod[Integer] 0[Integer], -32768[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3229 mod[compile-time] 0[Integer], -32768[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod -32768;
endcode
runtime noerror

$overflow on
code auto:3230 mod[Integer] 0[Integer], -32768[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3231 mod[compile-time] 0[Integer], -32768[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod -32768;
endcode
varvalue r 0

$overflow off
code auto:3232 mod[Integer] 0[Integer], -32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3233 mod[compile-time] 0[Integer], -32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod -32767;
endcode
runtime noerror

$overflow on
code auto:3234 mod[Integer] 0[Integer], -32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3235 mod[compile-time] 0[Integer], -32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod -32767;
endcode
varvalue r 0

$overflow off
code auto:3236 mod[Integer] 0[Integer], -129[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3237 mod[compile-time] 0[Integer], -129[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod -129;
endcode
runtime noerror

$overflow on
code auto:3238 mod[Integer] 0[Integer], -129[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3239 mod[compile-time] 0[Integer], -129[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod -129;
endcode
varvalue r 0

$overflow off
code auto:3240 mod[Integer] 0[Integer], -128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3241 mod[compile-time] 0[Integer], -128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod -128;
endcode
runtime noerror

$overflow on
code auto:3242 mod[Integer] 0[Integer], -128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3243 mod[compile-time] 0[Integer], -128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow off
code auto:3244 mod[Integer] 0[Integer], -1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3245 mod[compile-time] 0[Integer], -1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod -1;
endcode
runtime noerror

$overflow on
code auto:3246 mod[Integer] 0[Integer], -1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3247 mod[compile-time] 0[Integer], -1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3248 mod[Integer] 0[Integer], 0[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3249 mod[compile-time] 0[Integer], 0[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:3250 mod[Integer] 0[Integer], 0[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3251 mod[compile-time] 0[Integer], 0[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:3252 mod[Integer] 0[Integer], 1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3253 mod[compile-time] 0[Integer], 1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 1;
endcode
runtime noerror

$overflow on
code auto:3254 mod[Integer] 0[Integer], 1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3255 mod[compile-time] 0[Integer], 1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3256 mod[Integer] 0[Integer], 127[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3257 mod[compile-time] 0[Integer], 127[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 127;
endcode
runtime noerror

$overflow on
code auto:3258 mod[Integer] 0[Integer], 127[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3259 mod[compile-time] 0[Integer], 127[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow off
code auto:3260 mod[Integer] 0[Integer], 128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3261 mod[compile-time] 0[Integer], 128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 128;
endcode
runtime noerror

$overflow on
code auto:3262 mod[Integer] 0[Integer], 128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3263 mod[compile-time] 0[Integer], 128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow off
code auto:3264 mod[Integer] 0[Integer], 32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3265 mod[compile-time] 0[Integer], 32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 32767;
endcode
runtime noerror

$overflow on
code auto:3266 mod[Integer] 0[Integer], 32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3267 mod[compile-time] 0[Integer], 32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:3268 mod[Integer] 1[Integer], -32768[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3269 mod[compile-time] 1[Integer], -32768[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod -32768;
endcode
runtime noerror

$overflow on
code auto:3270 mod[Integer] 1[Integer], -32768[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:3271 mod[compile-time] 1[Integer], -32768[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod -32768;
endcode
varvalue r 1

$overflow off
code auto:3272 mod[Integer] 1[Integer], -32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3273 mod[compile-time] 1[Integer], -32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod -32767;
endcode
runtime noerror

$overflow on
code auto:3274 mod[Integer] 1[Integer], -32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:3275 mod[compile-time] 1[Integer], -32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod -32767;
endcode
varvalue r 1

$overflow off
code auto:3276 mod[Integer] 1[Integer], -129[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3277 mod[compile-time] 1[Integer], -129[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod -129;
endcode
runtime noerror

$overflow on
code auto:3278 mod[Integer] 1[Integer], -129[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:3279 mod[compile-time] 1[Integer], -129[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod -129;
endcode
varvalue r 1

$overflow off
code auto:3280 mod[Integer] 1[Integer], -128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3281 mod[compile-time] 1[Integer], -128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod -128;
endcode
runtime noerror

$overflow on
code auto:3282 mod[Integer] 1[Integer], -128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:3283 mod[compile-time] 1[Integer], -128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow off
code auto:3284 mod[Integer] 1[Integer], -1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3285 mod[compile-time] 1[Integer], -1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod -1;
endcode
runtime noerror

$overflow on
code auto:3286 mod[Integer] 1[Integer], -1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3287 mod[compile-time] 1[Integer], -1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3288 mod[Integer] 1[Integer], 0[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3289 mod[compile-time] 1[Integer], 0[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:3290 mod[Integer] 1[Integer], 0[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3291 mod[compile-time] 1[Integer], 0[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 0;
endcode
compile error

$overflow off
code auto:3292 mod[Integer] 1[Integer], 1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3293 mod[compile-time] 1[Integer], 1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod 1;
endcode
runtime noerror

$overflow on
code auto:3294 mod[Integer] 1[Integer], 1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3295 mod[compile-time] 1[Integer], 1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3296 mod[Integer] 1[Integer], 127[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3297 mod[compile-time] 1[Integer], 127[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod 127;
endcode
runtime noerror

$overflow on
code auto:3298 mod[Integer] 1[Integer], 127[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:3299 mod[compile-time] 1[Integer], 127[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow off
code auto:3300 mod[Integer] 1[Integer], 128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3301 mod[compile-time] 1[Integer], 128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod 128;
endcode
runtime noerror

$overflow on
code auto:3302 mod[Integer] 1[Integer], 128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:3303 mod[compile-time] 1[Integer], 128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow off
code auto:3304 mod[Integer] 1[Integer], 32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3305 mod[compile-time] 1[Integer], 32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 1 mod 32767;
endcode
runtime noerror

$overflow on
code auto:3306 mod[Integer] 1[Integer], 32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:3307 mod[compile-time] 1[Integer], 32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:3308 mod[Integer] 127[Integer], -32768[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3309 mod[compile-time] 127[Integer], -32768[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod -32768;
endcode
runtime noerror

$overflow on
code auto:3310 mod[Integer] 127[Integer], -32768[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:3311 mod[compile-time] 127[Integer], -32768[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod -32768;
endcode
varvalue r 127

$overflow off
code auto:3312 mod[Integer] 127[Integer], -32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3313 mod[compile-time] 127[Integer], -32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod -32767;
endcode
runtime noerror

$overflow on
code auto:3314 mod[Integer] 127[Integer], -32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:3315 mod[compile-time] 127[Integer], -32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod -32767;
endcode
varvalue r 127

$overflow off
code auto:3316 mod[Integer] 127[Integer], -129[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3317 mod[compile-time] 127[Integer], -129[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod -129;
endcode
runtime noerror

$overflow on
code auto:3318 mod[Integer] 127[Integer], -129[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:3319 mod[compile-time] 127[Integer], -129[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod -129;
endcode
varvalue r 127

$overflow off
code auto:3320 mod[Integer] 127[Integer], -128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3321 mod[compile-time] 127[Integer], -128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod -128;
endcode
runtime noerror

$overflow on
code auto:3322 mod[Integer] 127[Integer], -128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:3323 mod[compile-time] 127[Integer], -128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow off
code auto:3324 mod[Integer] 127[Integer], -1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3325 mod[compile-time] 127[Integer], -1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod -1;
endcode
runtime noerror

$overflow on
code auto:3326 mod[Integer] 127[Integer], -1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3327 mod[compile-time] 127[Integer], -1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3328 mod[Integer] 127[Integer], 0[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3329 mod[compile-time] 127[Integer], 0[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:3330 mod[Integer] 127[Integer], 0[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3331 mod[compile-time] 127[Integer], 0[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 0;
endcode
compile error

$overflow off
code auto:3332 mod[Integer] 127[Integer], 1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3333 mod[compile-time] 127[Integer], 1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod 1;
endcode
runtime noerror

$overflow on
code auto:3334 mod[Integer] 127[Integer], 1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3335 mod[compile-time] 127[Integer], 1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3336 mod[Integer] 127[Integer], 127[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3337 mod[compile-time] 127[Integer], 127[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod 127;
endcode
runtime noerror

$overflow on
code auto:3338 mod[Integer] 127[Integer], 127[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3339 mod[compile-time] 127[Integer], 127[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:3340 mod[Integer] 127[Integer], 128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3341 mod[compile-time] 127[Integer], 128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod 128;
endcode
runtime noerror

$overflow on
code auto:3342 mod[Integer] 127[Integer], 128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:3343 mod[compile-time] 127[Integer], 128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow off
code auto:3344 mod[Integer] 127[Integer], 32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3345 mod[compile-time] 127[Integer], 32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 127 mod 32767;
endcode
runtime noerror

$overflow on
code auto:3346 mod[Integer] 127[Integer], 32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:3347 mod[compile-time] 127[Integer], 32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow off
code auto:3348 mod[Integer] 128[Integer], -32768[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3349 mod[compile-time] 128[Integer], -32768[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 128 mod -32768;
endcode
runtime noerror

$overflow on
code auto:3350 mod[Integer] 128[Integer], -32768[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 128

code auto:3351 mod[compile-time] 128[Integer], -32768[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod -32768;
endcode
varvalue r 128

$overflow off
code auto:3352 mod[Integer] 128[Integer], -32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3353 mod[compile-time] 128[Integer], -32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 128 mod -32767;
endcode
runtime noerror

$overflow on
code auto:3354 mod[Integer] 128[Integer], -32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 128

code auto:3355 mod[compile-time] 128[Integer], -32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod -32767;
endcode
varvalue r 128

$overflow off
code auto:3356 mod[Integer] 128[Integer], -129[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3357 mod[compile-time] 128[Integer], -129[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 128 mod -129;
endcode
runtime noerror

$overflow on
code auto:3358 mod[Integer] 128[Integer], -129[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 128

code auto:3359 mod[compile-time] 128[Integer], -129[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod -129;
endcode
varvalue r 128

$overflow off
code auto:3360 mod[Integer] 128[Integer], -128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3361 mod[compile-time] 128[Integer], -128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 128 mod -128;
endcode
runtime noerror

$overflow on
code auto:3362 mod[Integer] 128[Integer], -128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3363 mod[compile-time] 128[Integer], -128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod -128;
endcode
varvalue r 0

$overflow off
code auto:3364 mod[Integer] 128[Integer], -1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3365 mod[compile-time] 128[Integer], -1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 128 mod -1;
endcode
runtime noerror

$overflow on
code auto:3366 mod[Integer] 128[Integer], -1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3367 mod[compile-time] 128[Integer], -1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3368 mod[Integer] 128[Integer], 0[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3369 mod[compile-time] 128[Integer], 0[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:3370 mod[Integer] 128[Integer], 0[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3371 mod[compile-time] 128[Integer], 0[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 0;
endcode
compile error

$overflow off
code auto:3372 mod[Integer] 128[Integer], 1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3373 mod[compile-time] 128[Integer], 1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 128 mod 1;
endcode
runtime noerror

$overflow on
code auto:3374 mod[Integer] 128[Integer], 1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3375 mod[compile-time] 128[Integer], 1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3376 mod[Integer] 128[Integer], 127[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3377 mod[compile-time] 128[Integer], 127[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 128 mod 127;
endcode
runtime noerror

$overflow on
code auto:3378 mod[Integer] 128[Integer], 127[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:3379 mod[compile-time] 128[Integer], 127[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow off
code auto:3380 mod[Integer] 128[Integer], 128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3381 mod[compile-time] 128[Integer], 128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 128 mod 128;
endcode
runtime noerror

$overflow on
code auto:3382 mod[Integer] 128[Integer], 128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3383 mod[compile-time] 128[Integer], 128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 128;
endcode
varvalue r 0

$overflow off
code auto:3384 mod[Integer] 128[Integer], 32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3385 mod[compile-time] 128[Integer], 32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 128 mod 32767;
endcode
runtime noerror

$overflow on
code auto:3386 mod[Integer] 128[Integer], 32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 128

code auto:3387 mod[compile-time] 128[Integer], 32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 32767;
endcode
varvalue r 128

$overflow off
code auto:3388 mod[Integer] 32767[Integer], -32768[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3389 mod[compile-time] 32767[Integer], -32768[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod -32768;
endcode
compile error

$overflow on
code auto:3390 mod[Integer] 32767[Integer], -32768[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:3391 mod[compile-time] 32767[Integer], -32768[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod -32768;
endcode
compile error

$overflow off
code auto:3392 mod[Integer] 32767[Integer], -32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3393 mod[compile-time] 32767[Integer], -32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod -32767;
endcode
runtime noerror

$overflow on
code auto:3394 mod[Integer] 32767[Integer], -32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3395 mod[compile-time] 32767[Integer], -32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod -32767;
endcode
varvalue r 0

$overflow off
code auto:3396 mod[Integer] 32767[Integer], -129[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3397 mod[compile-time] 32767[Integer], -129[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod -129;
endcode
runtime noerror

$overflow on
code auto:3398 mod[Integer] 32767[Integer], -129[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -129;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:3399 mod[compile-time] 32767[Integer], -129[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod -129;
endcode
varvalue r 1

$overflow off
code auto:3400 mod[Integer] 32767[Integer], -128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3401 mod[compile-time] 32767[Integer], -128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod -128;
endcode
runtime noerror

$overflow on
code auto:3402 mod[Integer] 32767[Integer], -128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:3403 mod[compile-time] 32767[Integer], -128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod -128;
endcode
varvalue r 127

$overflow off
code auto:3404 mod[Integer] 32767[Integer], -1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3405 mod[compile-time] 32767[Integer], -1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod -1;
endcode
runtime noerror

$overflow on
code auto:3406 mod[Integer] 32767[Integer], -1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3407 mod[compile-time] 32767[Integer], -1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3408 mod[Integer] 32767[Integer], 0[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3409 mod[compile-time] 32767[Integer], 0[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:3410 mod[Integer] 32767[Integer], 0[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3411 mod[compile-time] 32767[Integer], 0[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 0;
endcode
compile error

$overflow off
code auto:3412 mod[Integer] 32767[Integer], 1[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3413 mod[compile-time] 32767[Integer], 1[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 1;
endcode
runtime noerror

$overflow on
code auto:3414 mod[Integer] 32767[Integer], 1[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3415 mod[compile-time] 32767[Integer], 1[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3416 mod[Integer] 32767[Integer], 127[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3417 mod[compile-time] 32767[Integer], 127[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 127;
endcode
runtime noerror

$overflow on
code auto:3418 mod[Integer] 32767[Integer], 127[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:3419 mod[compile-time] 32767[Integer], 127[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow off
code auto:3420 mod[Integer] 32767[Integer], 128[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3421 mod[compile-time] 32767[Integer], 128[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 128;
endcode
runtime noerror

$overflow on
code auto:3422 mod[Integer] 32767[Integer], 128[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:3423 mod[compile-time] 32767[Integer], 128[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 128;
endcode
varvalue r 127

$overflow off
code auto:3424 mod[Integer] 32767[Integer], 32767[Integer] -> [Byte] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:3425 mod[compile-time] 32767[Integer], 32767[Integer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:3426 mod[Integer] 32767[Integer], 32767[Integer] -> [Byte] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:3427 mod[compile-time] 32767[Integer], 32767[Integer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:3428 mod[Integer] -32768[Integer], -32768[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3429 mod[compile-time] -32768[Integer], -32768[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32768 mod -32768;
endcode
runtime noerror

$overflow on
code auto:3430 mod[Integer] -32768[Integer], -32768[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3431 mod[compile-time] -32768[Integer], -32768[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32768 mod -32768;
endcode
varvalue r 0

$overflow off
code auto:3432 mod[Integer] -32768[Integer], -32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3433 mod[compile-time] -32768[Integer], -32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32768 mod -32767;
endcode
compile error

$overflow on
code auto:3434 mod[Integer] -32768[Integer], -32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3435 mod[compile-time] -32768[Integer], -32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32768 mod -32767;
endcode
compile error

$overflow off
code auto:3436 mod[Integer] -32768[Integer], -129[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3437 mod[compile-time] -32768[Integer], -129[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32768 mod -129;
endcode
compile error

$overflow on
code auto:3438 mod[Integer] -32768[Integer], -129[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3439 mod[compile-time] -32768[Integer], -129[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32768 mod -129;
endcode
compile error

$overflow off
code auto:3440 mod[Integer] -32768[Integer], -128[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3441 mod[compile-time] -32768[Integer], -128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32768 mod -128;
endcode
runtime noerror

$overflow on
code auto:3442 mod[Integer] -32768[Integer], -128[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3443 mod[compile-time] -32768[Integer], -128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32768 mod -128;
endcode
varvalue r 0

$overflow off
code auto:3444 mod[Integer] -32768[Integer], -1[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3445 mod[compile-time] -32768[Integer], -1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32768 mod -1;
endcode
runtime noerror

$overflow on
code auto:3446 mod[Integer] -32768[Integer], -1[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3447 mod[compile-time] -32768[Integer], -1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32768 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3448 mod[Integer] -32768[Integer], 0[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3449 mod[compile-time] -32768[Integer], 0[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32768 mod 0;
endcode
compile error

$overflow on
code auto:3450 mod[Integer] -32768[Integer], 0[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3451 mod[compile-time] -32768[Integer], 0[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32768 mod 0;
endcode
compile error

$overflow off
code auto:3452 mod[Integer] -32768[Integer], 1[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3453 mod[compile-time] -32768[Integer], 1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32768 mod 1;
endcode
runtime noerror

$overflow on
code auto:3454 mod[Integer] -32768[Integer], 1[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3455 mod[compile-time] -32768[Integer], 1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32768 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3456 mod[Integer] -32768[Integer], 127[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3457 mod[compile-time] -32768[Integer], 127[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32768 mod 127;
endcode
compile error

$overflow on
code auto:3458 mod[Integer] -32768[Integer], 127[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3459 mod[compile-time] -32768[Integer], 127[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32768 mod 127;
endcode
compile error

$overflow off
code auto:3460 mod[Integer] -32768[Integer], 128[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3461 mod[compile-time] -32768[Integer], 128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32768 mod 128;
endcode
runtime noerror

$overflow on
code auto:3462 mod[Integer] -32768[Integer], 128[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3463 mod[compile-time] -32768[Integer], 128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32768 mod 128;
endcode
varvalue r 0

$overflow off
code auto:3464 mod[Integer] -32768[Integer], 32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32768;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3465 mod[compile-time] -32768[Integer], 32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32768 mod 32767;
endcode
compile error

$overflow on
code auto:3466 mod[Integer] -32768[Integer], 32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32768;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3467 mod[compile-time] -32768[Integer], 32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32768 mod 32767;
endcode
compile error

$overflow off
code auto:3468 mod[Integer] -32767[Integer], -32768[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3469 mod[compile-time] -32767[Integer], -32768[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32767 mod -32768;
endcode
compile error

$overflow on
code auto:3470 mod[Integer] -32767[Integer], -32768[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3471 mod[compile-time] -32767[Integer], -32768[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32767 mod -32768;
endcode
compile error

$overflow off
code auto:3472 mod[Integer] -32767[Integer], -32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3473 mod[compile-time] -32767[Integer], -32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32767 mod -32767;
endcode
runtime noerror

$overflow on
code auto:3474 mod[Integer] -32767[Integer], -32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3475 mod[compile-time] -32767[Integer], -32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32767 mod -32767;
endcode
varvalue r 0

$overflow off
code auto:3476 mod[Integer] -32767[Integer], -129[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3477 mod[compile-time] -32767[Integer], -129[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32767 mod -129;
endcode
compile error

$overflow on
code auto:3478 mod[Integer] -32767[Integer], -129[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3479 mod[compile-time] -32767[Integer], -129[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32767 mod -129;
endcode
compile error

$overflow off
code auto:3480 mod[Integer] -32767[Integer], -128[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3481 mod[compile-time] -32767[Integer], -128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32767 mod -128;
endcode
compile error

$overflow on
code auto:3482 mod[Integer] -32767[Integer], -128[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3483 mod[compile-time] -32767[Integer], -128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32767 mod -128;
endcode
compile error

$overflow off
code auto:3484 mod[Integer] -32767[Integer], -1[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3485 mod[compile-time] -32767[Integer], -1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32767 mod -1;
endcode
runtime noerror

$overflow on
code auto:3486 mod[Integer] -32767[Integer], -1[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3487 mod[compile-time] -32767[Integer], -1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32767 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3488 mod[Integer] -32767[Integer], 0[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3489 mod[compile-time] -32767[Integer], 0[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32767 mod 0;
endcode
compile error

$overflow on
code auto:3490 mod[Integer] -32767[Integer], 0[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3491 mod[compile-time] -32767[Integer], 0[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32767 mod 0;
endcode
compile error

$overflow off
code auto:3492 mod[Integer] -32767[Integer], 1[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3493 mod[compile-time] -32767[Integer], 1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32767 mod 1;
endcode
runtime noerror

$overflow on
code auto:3494 mod[Integer] -32767[Integer], 1[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3495 mod[compile-time] -32767[Integer], 1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32767 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3496 mod[Integer] -32767[Integer], 127[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3497 mod[compile-time] -32767[Integer], 127[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32767 mod 127;
endcode
compile error

$overflow on
code auto:3498 mod[Integer] -32767[Integer], 127[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3499 mod[compile-time] -32767[Integer], 127[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32767 mod 127;
endcode
compile error

$overflow off
code auto:3500 mod[Integer] -32767[Integer], 128[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3501 mod[compile-time] -32767[Integer], 128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32767 mod 128;
endcode
compile error

$overflow on
code auto:3502 mod[Integer] -32767[Integer], 128[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3503 mod[compile-time] -32767[Integer], 128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32767 mod 128;
endcode
compile error

$overflow off
code auto:3504 mod[Integer] -32767[Integer], 32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = -32767;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3505 mod[compile-time] -32767[Integer], 32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:3506 mod[Integer] -32767[Integer], 32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = -32767;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3507 mod[compile-time] -32767[Integer], 32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:3508 mod[Integer] -129[Integer], -32768[Integer] -> [Word] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3509 mod[compile-time] -129[Integer], -32768[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -129 mod -32768;
endcode
compile error

$overflow on
code auto:3510 mod[Integer] -129[Integer], -32768[Integer] -> [Word] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3511 mod[compile-time] -129[Integer], -32768[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -129 mod -32768;
endcode
compile error

$overflow off
code auto:3512 mod[Integer] -129[Integer], -32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3513 mod[compile-time] -129[Integer], -32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -129 mod -32767;
endcode
compile error

$overflow on
code auto:3514 mod[Integer] -129[Integer], -32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3515 mod[compile-time] -129[Integer], -32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -129 mod -32767;
endcode
compile error

$overflow off
code auto:3516 mod[Integer] -129[Integer], -129[Integer] -> [Word] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3517 mod[compile-time] -129[Integer], -129[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -129 mod -129;
endcode
runtime noerror

$overflow on
code auto:3518 mod[Integer] -129[Integer], -129[Integer] -> [Word] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3519 mod[compile-time] -129[Integer], -129[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -129 mod -129;
endcode
varvalue r 0

$overflow off
code auto:3520 mod[Integer] -129[Integer], -128[Integer] -> [Word] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3521 mod[compile-time] -129[Integer], -128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -129 mod -128;
endcode
compile error

$overflow on
code auto:3522 mod[Integer] -129[Integer], -128[Integer] -> [Word] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3523 mod[compile-time] -129[Integer], -128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -129 mod -128;
endcode
compile error

$overflow off
code auto:3524 mod[Integer] -129[Integer], -1[Integer] -> [Word] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3525 mod[compile-time] -129[Integer], -1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -129 mod -1;
endcode
runtime noerror

$overflow on
code auto:3526 mod[Integer] -129[Integer], -1[Integer] -> [Word] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3527 mod[compile-time] -129[Integer], -1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -129 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3528 mod[Integer] -129[Integer], 0[Integer] -> [Word] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3529 mod[compile-time] -129[Integer], 0[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -129 mod 0;
endcode
compile error

$overflow on
code auto:3530 mod[Integer] -129[Integer], 0[Integer] -> [Word] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3531 mod[compile-time] -129[Integer], 0[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -129 mod 0;
endcode
compile error

$overflow off
code auto:3532 mod[Integer] -129[Integer], 1[Integer] -> [Word] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3533 mod[compile-time] -129[Integer], 1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -129 mod 1;
endcode
runtime noerror

$overflow on
code auto:3534 mod[Integer] -129[Integer], 1[Integer] -> [Word] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3535 mod[compile-time] -129[Integer], 1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -129 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3536 mod[Integer] -129[Integer], 127[Integer] -> [Word] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3537 mod[compile-time] -129[Integer], 127[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -129 mod 127;
endcode
compile error

$overflow on
code auto:3538 mod[Integer] -129[Integer], 127[Integer] -> [Word] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3539 mod[compile-time] -129[Integer], 127[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -129 mod 127;
endcode
compile error

$overflow off
code auto:3540 mod[Integer] -129[Integer], 128[Integer] -> [Word] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3541 mod[compile-time] -129[Integer], 128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -129 mod 128;
endcode
compile error

$overflow on
code auto:3542 mod[Integer] -129[Integer], 128[Integer] -> [Word] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3543 mod[compile-time] -129[Integer], 128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -129 mod 128;
endcode
compile error

$overflow off
code auto:3544 mod[Integer] -129[Integer], 32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = -129;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3545 mod[compile-time] -129[Integer], 32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -129 mod 32767;
endcode
compile error

$overflow on
code auto:3546 mod[Integer] -129[Integer], 32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = -129;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3547 mod[compile-time] -129[Integer], 32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -129 mod 32767;
endcode
compile error

$overflow off
code auto:3548 mod[Integer] -128[Integer], -32768[Integer] -> [Word] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3549 mod[compile-time] -128[Integer], -32768[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod -32768;
endcode
compile error

$overflow on
code auto:3550 mod[Integer] -128[Integer], -32768[Integer] -> [Word] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3551 mod[compile-time] -128[Integer], -32768[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod -32768;
endcode
compile error

$overflow off
code auto:3552 mod[Integer] -128[Integer], -32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3553 mod[compile-time] -128[Integer], -32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod -32767;
endcode
compile error

$overflow on
code auto:3554 mod[Integer] -128[Integer], -32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3555 mod[compile-time] -128[Integer], -32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod -32767;
endcode
compile error

$overflow off
code auto:3556 mod[Integer] -128[Integer], -129[Integer] -> [Word] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3557 mod[compile-time] -128[Integer], -129[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod -129;
endcode
compile error

$overflow on
code auto:3558 mod[Integer] -128[Integer], -129[Integer] -> [Word] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3559 mod[compile-time] -128[Integer], -129[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod -129;
endcode
compile error

$overflow off
code auto:3560 mod[Integer] -128[Integer], -128[Integer] -> [Word] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3561 mod[compile-time] -128[Integer], -128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod -128;
endcode
runtime noerror

$overflow on
code auto:3562 mod[Integer] -128[Integer], -128[Integer] -> [Word] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3563 mod[compile-time] -128[Integer], -128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod -128;
endcode
varvalue r 0

$overflow off
code auto:3564 mod[Integer] -128[Integer], -1[Integer] -> [Word] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3565 mod[compile-time] -128[Integer], -1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod -1;
endcode
runtime noerror

$overflow on
code auto:3566 mod[Integer] -128[Integer], -1[Integer] -> [Word] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3567 mod[compile-time] -128[Integer], -1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3568 mod[Integer] -128[Integer], 0[Integer] -> [Word] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3569 mod[compile-time] -128[Integer], 0[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod 0;
endcode
compile error

$overflow on
code auto:3570 mod[Integer] -128[Integer], 0[Integer] -> [Word] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3571 mod[compile-time] -128[Integer], 0[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod 0;
endcode
compile error

$overflow off
code auto:3572 mod[Integer] -128[Integer], 1[Integer] -> [Word] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3573 mod[compile-time] -128[Integer], 1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod 1;
endcode
runtime noerror

$overflow on
code auto:3574 mod[Integer] -128[Integer], 1[Integer] -> [Word] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3575 mod[compile-time] -128[Integer], 1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3576 mod[Integer] -128[Integer], 127[Integer] -> [Word] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3577 mod[compile-time] -128[Integer], 127[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod 127;
endcode
compile error

$overflow on
code auto:3578 mod[Integer] -128[Integer], 127[Integer] -> [Word] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3579 mod[compile-time] -128[Integer], 127[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod 127;
endcode
compile error

$overflow off
code auto:3580 mod[Integer] -128[Integer], 128[Integer] -> [Word] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3581 mod[compile-time] -128[Integer], 128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod 128;
endcode
runtime noerror

$overflow on
code auto:3582 mod[Integer] -128[Integer], 128[Integer] -> [Word] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3583 mod[compile-time] -128[Integer], 128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod 128;
endcode
varvalue r 0

$overflow off
code auto:3584 mod[Integer] -128[Integer], 32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = -128;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3585 mod[compile-time] -128[Integer], 32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -128 mod 32767;
endcode
compile error

$overflow on
code auto:3586 mod[Integer] -128[Integer], 32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = -128;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3587 mod[compile-time] -128[Integer], 32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -128 mod 32767;
endcode
compile error

$overflow off
code auto:3588 mod[Integer] -1[Integer], -32768[Integer] -> [Word] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3589 mod[compile-time] -1[Integer], -32768[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod -32768;
endcode
compile error

$overflow on
code auto:3590 mod[Integer] -1[Integer], -32768[Integer] -> [Word] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3591 mod[compile-time] -1[Integer], -32768[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod -32768;
endcode
compile error

$overflow off
code auto:3592 mod[Integer] -1[Integer], -32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3593 mod[compile-time] -1[Integer], -32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod -32767;
endcode
compile error

$overflow on
code auto:3594 mod[Integer] -1[Integer], -32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3595 mod[compile-time] -1[Integer], -32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod -32767;
endcode
compile error

$overflow off
code auto:3596 mod[Integer] -1[Integer], -129[Integer] -> [Word] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3597 mod[compile-time] -1[Integer], -129[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod -129;
endcode
compile error

$overflow on
code auto:3598 mod[Integer] -1[Integer], -129[Integer] -> [Word] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3599 mod[compile-time] -1[Integer], -129[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod -129;
endcode
compile error

$overflow off
code auto:3600 mod[Integer] -1[Integer], -128[Integer] -> [Word] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3601 mod[compile-time] -1[Integer], -128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod -128;
endcode
compile error

$overflow on
code auto:3602 mod[Integer] -1[Integer], -128[Integer] -> [Word] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3603 mod[compile-time] -1[Integer], -128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod -128;
endcode
compile error

$overflow off
code auto:3604 mod[Integer] -1[Integer], -1[Integer] -> [Word] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3605 mod[compile-time] -1[Integer], -1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod -1;
endcode
runtime noerror

$overflow on
code auto:3606 mod[Integer] -1[Integer], -1[Integer] -> [Word] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3607 mod[compile-time] -1[Integer], -1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3608 mod[Integer] -1[Integer], 0[Integer] -> [Word] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3609 mod[compile-time] -1[Integer], 0[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod 0;
endcode
compile error

$overflow on
code auto:3610 mod[Integer] -1[Integer], 0[Integer] -> [Word] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3611 mod[compile-time] -1[Integer], 0[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod 0;
endcode
compile error

$overflow off
code auto:3612 mod[Integer] -1[Integer], 1[Integer] -> [Word] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3613 mod[compile-time] -1[Integer], 1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod 1;
endcode
runtime noerror

$overflow on
code auto:3614 mod[Integer] -1[Integer], 1[Integer] -> [Word] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3615 mod[compile-time] -1[Integer], 1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3616 mod[Integer] -1[Integer], 127[Integer] -> [Word] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3617 mod[compile-time] -1[Integer], 127[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod 127;
endcode
compile error

$overflow on
code auto:3618 mod[Integer] -1[Integer], 127[Integer] -> [Word] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3619 mod[compile-time] -1[Integer], 127[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod 127;
endcode
compile error

$overflow off
code auto:3620 mod[Integer] -1[Integer], 128[Integer] -> [Word] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3621 mod[compile-time] -1[Integer], 128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod 128;
endcode
compile error

$overflow on
code auto:3622 mod[Integer] -1[Integer], 128[Integer] -> [Word] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3623 mod[compile-time] -1[Integer], 128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod 128;
endcode
compile error

$overflow off
code auto:3624 mod[Integer] -1[Integer], 32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = -1;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3625 mod[compile-time] -1[Integer], 32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := -1 mod 32767;
endcode
compile error

$overflow on
code auto:3626 mod[Integer] -1[Integer], 32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = -1;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime overflow

code auto:3627 mod[compile-time] -1[Integer], 32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := -1 mod 32767;
endcode
compile error

$overflow off
code auto:3628 mod[Integer] 0[Integer], -32768[Integer] -> [Word] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3629 mod[compile-time] 0[Integer], -32768[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod -32768;
endcode
runtime noerror

$overflow on
code auto:3630 mod[Integer] 0[Integer], -32768[Integer] -> [Word] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3631 mod[compile-time] 0[Integer], -32768[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod -32768;
endcode
varvalue r 0

$overflow off
code auto:3632 mod[Integer] 0[Integer], -32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3633 mod[compile-time] 0[Integer], -32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod -32767;
endcode
runtime noerror

$overflow on
code auto:3634 mod[Integer] 0[Integer], -32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3635 mod[compile-time] 0[Integer], -32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod -32767;
endcode
varvalue r 0

$overflow off
code auto:3636 mod[Integer] 0[Integer], -129[Integer] -> [Word] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3637 mod[compile-time] 0[Integer], -129[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod -129;
endcode
runtime noerror

$overflow on
code auto:3638 mod[Integer] 0[Integer], -129[Integer] -> [Word] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3639 mod[compile-time] 0[Integer], -129[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod -129;
endcode
varvalue r 0

$overflow off
code auto:3640 mod[Integer] 0[Integer], -128[Integer] -> [Word] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3641 mod[compile-time] 0[Integer], -128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod -128;
endcode
runtime noerror

$overflow on
code auto:3642 mod[Integer] 0[Integer], -128[Integer] -> [Word] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3643 mod[compile-time] 0[Integer], -128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod -128;
endcode
varvalue r 0

$overflow off
code auto:3644 mod[Integer] 0[Integer], -1[Integer] -> [Word] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3645 mod[compile-time] 0[Integer], -1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod -1;
endcode
runtime noerror

$overflow on
code auto:3646 mod[Integer] 0[Integer], -1[Integer] -> [Word] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3647 mod[compile-time] 0[Integer], -1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3648 mod[Integer] 0[Integer], 0[Integer] -> [Word] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3649 mod[compile-time] 0[Integer], 0[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:3650 mod[Integer] 0[Integer], 0[Integer] -> [Word] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3651 mod[compile-time] 0[Integer], 0[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:3652 mod[Integer] 0[Integer], 1[Integer] -> [Word] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3653 mod[compile-time] 0[Integer], 1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 1;
endcode
runtime noerror

$overflow on
code auto:3654 mod[Integer] 0[Integer], 1[Integer] -> [Word] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3655 mod[compile-time] 0[Integer], 1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3656 mod[Integer] 0[Integer], 127[Integer] -> [Word] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3657 mod[compile-time] 0[Integer], 127[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 127;
endcode
runtime noerror

$overflow on
code auto:3658 mod[Integer] 0[Integer], 127[Integer] -> [Word] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3659 mod[compile-time] 0[Integer], 127[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow off
code auto:3660 mod[Integer] 0[Integer], 128[Integer] -> [Word] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3661 mod[compile-time] 0[Integer], 128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 128;
endcode
runtime noerror

$overflow on
code auto:3662 mod[Integer] 0[Integer], 128[Integer] -> [Word] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3663 mod[compile-time] 0[Integer], 128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow off
code auto:3664 mod[Integer] 0[Integer], 32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = 0;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3665 mod[compile-time] 0[Integer], 32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 32767;
endcode
runtime noerror

$overflow on
code auto:3666 mod[Integer] 0[Integer], 32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = 0;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3667 mod[compile-time] 0[Integer], 32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:3668 mod[Integer] 1[Integer], -32768[Integer] -> [Word] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3669 mod[compile-time] 1[Integer], -32768[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod -32768;
endcode
runtime noerror

$overflow on
code auto:3670 mod[Integer] 1[Integer], -32768[Integer] -> [Word] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:3671 mod[compile-time] 1[Integer], -32768[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod -32768;
endcode
varvalue r 1

$overflow off
code auto:3672 mod[Integer] 1[Integer], -32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3673 mod[compile-time] 1[Integer], -32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod -32767;
endcode
runtime noerror

$overflow on
code auto:3674 mod[Integer] 1[Integer], -32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:3675 mod[compile-time] 1[Integer], -32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod -32767;
endcode
varvalue r 1

$overflow off
code auto:3676 mod[Integer] 1[Integer], -129[Integer] -> [Word] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3677 mod[compile-time] 1[Integer], -129[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod -129;
endcode
runtime noerror

$overflow on
code auto:3678 mod[Integer] 1[Integer], -129[Integer] -> [Word] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:3679 mod[compile-time] 1[Integer], -129[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod -129;
endcode
varvalue r 1

$overflow off
code auto:3680 mod[Integer] 1[Integer], -128[Integer] -> [Word] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3681 mod[compile-time] 1[Integer], -128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod -128;
endcode
runtime noerror

$overflow on
code auto:3682 mod[Integer] 1[Integer], -128[Integer] -> [Word] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:3683 mod[compile-time] 1[Integer], -128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod -128;
endcode
varvalue r 1

$overflow off
code auto:3684 mod[Integer] 1[Integer], -1[Integer] -> [Word] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3685 mod[compile-time] 1[Integer], -1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod -1;
endcode
runtime noerror

$overflow on
code auto:3686 mod[Integer] 1[Integer], -1[Integer] -> [Word] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3687 mod[compile-time] 1[Integer], -1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3688 mod[Integer] 1[Integer], 0[Integer] -> [Word] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3689 mod[compile-time] 1[Integer], 0[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:3690 mod[Integer] 1[Integer], 0[Integer] -> [Word] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3691 mod[compile-time] 1[Integer], 0[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 0;
endcode
compile error

$overflow off
code auto:3692 mod[Integer] 1[Integer], 1[Integer] -> [Word] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3693 mod[compile-time] 1[Integer], 1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 1;
endcode
runtime noerror

$overflow on
code auto:3694 mod[Integer] 1[Integer], 1[Integer] -> [Word] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3695 mod[compile-time] 1[Integer], 1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3696 mod[Integer] 1[Integer], 127[Integer] -> [Word] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3697 mod[compile-time] 1[Integer], 127[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 127;
endcode
runtime noerror

$overflow on
code auto:3698 mod[Integer] 1[Integer], 127[Integer] -> [Word] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:3699 mod[compile-time] 1[Integer], 127[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow off
code auto:3700 mod[Integer] 1[Integer], 128[Integer] -> [Word] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3701 mod[compile-time] 1[Integer], 128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 128;
endcode
runtime noerror

$overflow on
code auto:3702 mod[Integer] 1[Integer], 128[Integer] -> [Word] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:3703 mod[compile-time] 1[Integer], 128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow off
code auto:3704 mod[Integer] 1[Integer], 32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = 1;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3705 mod[compile-time] 1[Integer], 32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 32767;
endcode
runtime noerror

$overflow on
code auto:3706 mod[Integer] 1[Integer], 32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = 1;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:3707 mod[compile-time] 1[Integer], 32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:3708 mod[Integer] 127[Integer], -32768[Integer] -> [Word] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3709 mod[compile-time] 127[Integer], -32768[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod -32768;
endcode
runtime noerror

$overflow on
code auto:3710 mod[Integer] 127[Integer], -32768[Integer] -> [Word] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:3711 mod[compile-time] 127[Integer], -32768[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod -32768;
endcode
varvalue r 127

$overflow off
code auto:3712 mod[Integer] 127[Integer], -32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3713 mod[compile-time] 127[Integer], -32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod -32767;
endcode
runtime noerror

$overflow on
code auto:3714 mod[Integer] 127[Integer], -32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:3715 mod[compile-time] 127[Integer], -32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod -32767;
endcode
varvalue r 127

$overflow off
code auto:3716 mod[Integer] 127[Integer], -129[Integer] -> [Word] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3717 mod[compile-time] 127[Integer], -129[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod -129;
endcode
runtime noerror

$overflow on
code auto:3718 mod[Integer] 127[Integer], -129[Integer] -> [Word] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:3719 mod[compile-time] 127[Integer], -129[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod -129;
endcode
varvalue r 127

$overflow off
code auto:3720 mod[Integer] 127[Integer], -128[Integer] -> [Word] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3721 mod[compile-time] 127[Integer], -128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod -128;
endcode
runtime noerror

$overflow on
code auto:3722 mod[Integer] 127[Integer], -128[Integer] -> [Word] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:3723 mod[compile-time] 127[Integer], -128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod -128;
endcode
varvalue r 127

$overflow off
code auto:3724 mod[Integer] 127[Integer], -1[Integer] -> [Word] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3725 mod[compile-time] 127[Integer], -1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod -1;
endcode
runtime noerror

$overflow on
code auto:3726 mod[Integer] 127[Integer], -1[Integer] -> [Word] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3727 mod[compile-time] 127[Integer], -1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3728 mod[Integer] 127[Integer], 0[Integer] -> [Word] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3729 mod[compile-time] 127[Integer], 0[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:3730 mod[Integer] 127[Integer], 0[Integer] -> [Word] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3731 mod[compile-time] 127[Integer], 0[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 0;
endcode
compile error

$overflow off
code auto:3732 mod[Integer] 127[Integer], 1[Integer] -> [Word] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3733 mod[compile-time] 127[Integer], 1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 1;
endcode
runtime noerror

$overflow on
code auto:3734 mod[Integer] 127[Integer], 1[Integer] -> [Word] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3735 mod[compile-time] 127[Integer], 1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3736 mod[Integer] 127[Integer], 127[Integer] -> [Word] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3737 mod[compile-time] 127[Integer], 127[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 127;
endcode
runtime noerror

$overflow on
code auto:3738 mod[Integer] 127[Integer], 127[Integer] -> [Word] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3739 mod[compile-time] 127[Integer], 127[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:3740 mod[Integer] 127[Integer], 128[Integer] -> [Word] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3741 mod[compile-time] 127[Integer], 128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 128;
endcode
runtime noerror

$overflow on
code auto:3742 mod[Integer] 127[Integer], 128[Integer] -> [Word] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:3743 mod[compile-time] 127[Integer], 128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow off
code auto:3744 mod[Integer] 127[Integer], 32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = 127;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3745 mod[compile-time] 127[Integer], 32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 32767;
endcode
runtime noerror

$overflow on
code auto:3746 mod[Integer] 127[Integer], 32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = 127;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:3747 mod[compile-time] 127[Integer], 32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 32767;
endcode
varvalue r 127

$overflow off
code auto:3748 mod[Integer] 128[Integer], -32768[Integer] -> [Word] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3749 mod[compile-time] 128[Integer], -32768[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod -32768;
endcode
runtime noerror

$overflow on
code auto:3750 mod[Integer] 128[Integer], -32768[Integer] -> [Word] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:3751 mod[compile-time] 128[Integer], -32768[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod -32768;
endcode
varvalue r 128

$overflow off
code auto:3752 mod[Integer] 128[Integer], -32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3753 mod[compile-time] 128[Integer], -32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod -32767;
endcode
runtime noerror

$overflow on
code auto:3754 mod[Integer] 128[Integer], -32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:3755 mod[compile-time] 128[Integer], -32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod -32767;
endcode
varvalue r 128

$overflow off
code auto:3756 mod[Integer] 128[Integer], -129[Integer] -> [Word] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3757 mod[compile-time] 128[Integer], -129[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod -129;
endcode
runtime noerror

$overflow on
code auto:3758 mod[Integer] 128[Integer], -129[Integer] -> [Word] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:3759 mod[compile-time] 128[Integer], -129[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod -129;
endcode
varvalue r 128

$overflow off
code auto:3760 mod[Integer] 128[Integer], -128[Integer] -> [Word] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3761 mod[compile-time] 128[Integer], -128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod -128;
endcode
runtime noerror

$overflow on
code auto:3762 mod[Integer] 128[Integer], -128[Integer] -> [Word] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3763 mod[compile-time] 128[Integer], -128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod -128;
endcode
varvalue r 0

$overflow off
code auto:3764 mod[Integer] 128[Integer], -1[Integer] -> [Word] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3765 mod[compile-time] 128[Integer], -1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod -1;
endcode
runtime noerror

$overflow on
code auto:3766 mod[Integer] 128[Integer], -1[Integer] -> [Word] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3767 mod[compile-time] 128[Integer], -1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3768 mod[Integer] 128[Integer], 0[Integer] -> [Word] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3769 mod[compile-time] 128[Integer], 0[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:3770 mod[Integer] 128[Integer], 0[Integer] -> [Word] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3771 mod[compile-time] 128[Integer], 0[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 0;
endcode
compile error

$overflow off
code auto:3772 mod[Integer] 128[Integer], 1[Integer] -> [Word] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3773 mod[compile-time] 128[Integer], 1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod 1;
endcode
runtime noerror

$overflow on
code auto:3774 mod[Integer] 128[Integer], 1[Integer] -> [Word] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3775 mod[compile-time] 128[Integer], 1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3776 mod[Integer] 128[Integer], 127[Integer] -> [Word] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3777 mod[compile-time] 128[Integer], 127[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod 127;
endcode
runtime noerror

$overflow on
code auto:3778 mod[Integer] 128[Integer], 127[Integer] -> [Word] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:3779 mod[compile-time] 128[Integer], 127[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow off
code auto:3780 mod[Integer] 128[Integer], 128[Integer] -> [Word] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3781 mod[compile-time] 128[Integer], 128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod 128;
endcode
runtime noerror

$overflow on
code auto:3782 mod[Integer] 128[Integer], 128[Integer] -> [Word] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3783 mod[compile-time] 128[Integer], 128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 128;
endcode
varvalue r 0

$overflow off
code auto:3784 mod[Integer] 128[Integer], 32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = 128;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3785 mod[compile-time] 128[Integer], 32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod 32767;
endcode
runtime noerror

$overflow on
code auto:3786 mod[Integer] 128[Integer], 32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = 128;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:3787 mod[compile-time] 128[Integer], 32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 32767;
endcode
varvalue r 128

$overflow off
code auto:3788 mod[Integer] 32767[Integer], -32768[Integer] -> [Word] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3789 mod[compile-time] 32767[Integer], -32768[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod -32768;
endcode
runtime noerror

$overflow on
code auto:3790 mod[Integer] 32767[Integer], -32768[Integer] -> [Word] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32767

code auto:3791 mod[compile-time] 32767[Integer], -32768[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod -32768;
endcode
varvalue r 32767

$overflow off
code auto:3792 mod[Integer] 32767[Integer], -32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3793 mod[compile-time] 32767[Integer], -32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod -32767;
endcode
runtime noerror

$overflow on
code auto:3794 mod[Integer] 32767[Integer], -32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3795 mod[compile-time] 32767[Integer], -32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod -32767;
endcode
varvalue r 0

$overflow off
code auto:3796 mod[Integer] 32767[Integer], -129[Integer] -> [Word] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3797 mod[compile-time] 32767[Integer], -129[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod -129;
endcode
runtime noerror

$overflow on
code auto:3798 mod[Integer] 32767[Integer], -129[Integer] -> [Word] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -129;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:3799 mod[compile-time] 32767[Integer], -129[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod -129;
endcode
varvalue r 1

$overflow off
code auto:3800 mod[Integer] 32767[Integer], -128[Integer] -> [Word] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3801 mod[compile-time] 32767[Integer], -128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod -128;
endcode
runtime noerror

$overflow on
code auto:3802 mod[Integer] 32767[Integer], -128[Integer] -> [Word] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:3803 mod[compile-time] 32767[Integer], -128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod -128;
endcode
varvalue r 127

$overflow off
code auto:3804 mod[Integer] 32767[Integer], -1[Integer] -> [Word] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3805 mod[compile-time] 32767[Integer], -1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod -1;
endcode
runtime noerror

$overflow on
code auto:3806 mod[Integer] 32767[Integer], -1[Integer] -> [Word] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = -1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3807 mod[compile-time] 32767[Integer], -1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod -1;
endcode
varvalue r 0

$overflow off
code auto:3808 mod[Integer] 32767[Integer], 0[Integer] -> [Word] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3809 mod[compile-time] 32767[Integer], 0[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:3810 mod[Integer] 32767[Integer], 0[Integer] -> [Word] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3811 mod[compile-time] 32767[Integer], 0[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 0;
endcode
compile error

$overflow off
code auto:3812 mod[Integer] 32767[Integer], 1[Integer] -> [Word] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3813 mod[compile-time] 32767[Integer], 1[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod 1;
endcode
runtime noerror

$overflow on
code auto:3814 mod[Integer] 32767[Integer], 1[Integer] -> [Word] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3815 mod[compile-time] 32767[Integer], 1[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3816 mod[Integer] 32767[Integer], 127[Integer] -> [Word] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3817 mod[compile-time] 32767[Integer], 127[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod 127;
endcode
runtime noerror

$overflow on
code auto:3818 mod[Integer] 32767[Integer], 127[Integer] -> [Word] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:3819 mod[compile-time] 32767[Integer], 127[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 127;
endcode
varvalue r 1

$overflow off
code auto:3820 mod[Integer] 32767[Integer], 128[Integer] -> [Word] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3821 mod[compile-time] 32767[Integer], 128[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod 128;
endcode
runtime noerror

$overflow on
code auto:3822 mod[Integer] 32767[Integer], 128[Integer] -> [Word] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:3823 mod[compile-time] 32767[Integer], 128[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 128;
endcode
varvalue r 127

$overflow off
code auto:3824 mod[Integer] 32767[Integer], 32767[Integer] -> [Word] Var $overflow off
  var  a: Integer = 32767;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:3825 mod[compile-time] 32767[Integer], 32767[Integer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:3826 mod[Integer] 32767[Integer], 32767[Integer] -> [Word] Var $overflow on
  var  a: Integer = 32767;
  var  b: Integer = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:3827 mod[compile-time] 32767[Integer], 32767[Integer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:3828 mod[Byte] 0[Byte], 0[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3829 mod[compile-time] 0[Byte], 0[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:3830 mod[Byte] 0[Byte], 0[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3831 mod[compile-time] 0[Byte], 0[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:3832 mod[Byte] 0[Byte], 1[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3833 mod[compile-time] 0[Byte], 1[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 1;
endcode
runtime noerror

$overflow on
code auto:3834 mod[Byte] 0[Byte], 1[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:3835 mod[compile-time] 0[Byte], 1[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3836 mod[Byte] 0[Byte], 127[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3837 mod[compile-time] 0[Byte], 127[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 127;
endcode
runtime noerror

$overflow on
code auto:3838 mod[Byte] 0[Byte], 127[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:3839 mod[compile-time] 0[Byte], 127[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow off
code auto:3840 mod[Byte] 0[Byte], 128[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3841 mod[compile-time] 0[Byte], 128[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 128;
endcode
runtime noerror

$overflow on
code auto:3842 mod[Byte] 0[Byte], 128[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:3843 mod[compile-time] 0[Byte], 128[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow off
code auto:3844 mod[Byte] 0[Byte], 255[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3845 mod[compile-time] 0[Byte], 255[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 255;
endcode
runtime noerror

$overflow on
code auto:3846 mod[Byte] 0[Byte], 255[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 255;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:3847 mod[compile-time] 0[Byte], 255[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow off
code auto:3848 mod[Byte] 1[Byte], 0[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3849 mod[compile-time] 1[Byte], 0[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:3850 mod[Byte] 1[Byte], 0[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3851 mod[compile-time] 1[Byte], 0[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 0;
endcode
compile error

$overflow off
code auto:3852 mod[Byte] 1[Byte], 1[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3853 mod[compile-time] 1[Byte], 1[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod 1;
endcode
runtime noerror

$overflow on
code auto:3854 mod[Byte] 1[Byte], 1[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:3855 mod[compile-time] 1[Byte], 1[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3856 mod[Byte] 1[Byte], 127[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3857 mod[compile-time] 1[Byte], 127[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod 127;
endcode
runtime noerror

$overflow on
code auto:3858 mod[Byte] 1[Byte], 127[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:3859 mod[compile-time] 1[Byte], 127[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow off
code auto:3860 mod[Byte] 1[Byte], 128[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3861 mod[compile-time] 1[Byte], 128[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod 128;
endcode
runtime noerror

$overflow on
code auto:3862 mod[Byte] 1[Byte], 128[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:3863 mod[compile-time] 1[Byte], 128[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow off
code auto:3864 mod[Byte] 1[Byte], 255[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3865 mod[compile-time] 1[Byte], 255[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 1 mod 255;
endcode
runtime noerror

$overflow on
code auto:3866 mod[Byte] 1[Byte], 255[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 255;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:3867 mod[compile-time] 1[Byte], 255[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow off
code auto:3868 mod[Byte] 127[Byte], 0[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3869 mod[compile-time] 127[Byte], 0[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:3870 mod[Byte] 127[Byte], 0[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3871 mod[compile-time] 127[Byte], 0[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 0;
endcode
compile error

$overflow off
code auto:3872 mod[Byte] 127[Byte], 1[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3873 mod[compile-time] 127[Byte], 1[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod 1;
endcode
runtime noerror

$overflow on
code auto:3874 mod[Byte] 127[Byte], 1[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:3875 mod[compile-time] 127[Byte], 1[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3876 mod[Byte] 127[Byte], 127[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3877 mod[compile-time] 127[Byte], 127[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod 127;
endcode
runtime noerror

$overflow on
code auto:3878 mod[Byte] 127[Byte], 127[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:3879 mod[compile-time] 127[Byte], 127[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:3880 mod[Byte] 127[Byte], 128[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3881 mod[compile-time] 127[Byte], 128[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod 128;
endcode
runtime noerror

$overflow on
code auto:3882 mod[Byte] 127[Byte], 128[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:3883 mod[compile-time] 127[Byte], 128[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow off
code auto:3884 mod[Byte] 127[Byte], 255[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3885 mod[compile-time] 127[Byte], 255[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 127 mod 255;
endcode
runtime noerror

$overflow on
code auto:3886 mod[Byte] 127[Byte], 255[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 255;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:3887 mod[compile-time] 127[Byte], 255[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow off
code auto:3888 mod[Byte] 128[Byte], 0[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3889 mod[compile-time] 128[Byte], 0[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:3890 mod[Byte] 128[Byte], 0[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3891 mod[compile-time] 128[Byte], 0[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod 0;
endcode
compile error

$overflow off
code auto:3892 mod[Byte] 128[Byte], 1[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3893 mod[compile-time] 128[Byte], 1[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod 1;
endcode
runtime noerror

$overflow on
code auto:3894 mod[Byte] 128[Byte], 1[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:3895 mod[compile-time] 128[Byte], 1[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3896 mod[Byte] 128[Byte], 127[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3897 mod[compile-time] 128[Byte], 127[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod 127;
endcode
runtime noerror

$overflow on
code auto:3898 mod[Byte] 128[Byte], 127[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:3899 mod[compile-time] 128[Byte], 127[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow off
code auto:3900 mod[Byte] 128[Byte], 128[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3901 mod[compile-time] 128[Byte], 128[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod 128;
endcode
runtime noerror

$overflow on
code auto:3902 mod[Byte] 128[Byte], 128[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:3903 mod[compile-time] 128[Byte], 128[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod 128;
endcode
varvalue r 0

$overflow off
code auto:3904 mod[Byte] 128[Byte], 255[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3905 mod[compile-time] 128[Byte], 255[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 128 mod 255;
endcode
compile error

$overflow on
code auto:3906 mod[Byte] 128[Byte], 255[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:3907 mod[compile-time] 128[Byte], 255[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 128 mod 255;
endcode
compile error

$overflow off
code auto:3908 mod[Byte] 255[Byte], 0[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3909 mod[compile-time] 255[Byte], 0[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:3910 mod[Byte] 255[Byte], 0[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3911 mod[compile-time] 255[Byte], 0[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 0;
endcode
compile error

$overflow off
code auto:3912 mod[Byte] 255[Byte], 1[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 1;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3913 mod[compile-time] 255[Byte], 1[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 1;
endcode
runtime noerror

$overflow on
code auto:3914 mod[Byte] 255[Byte], 1[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 1;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:3915 mod[compile-time] 255[Byte], 1[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3916 mod[Byte] 255[Byte], 127[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 127;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3917 mod[compile-time] 255[Byte], 127[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 127;
endcode
runtime noerror

$overflow on
code auto:3918 mod[Byte] 255[Byte], 127[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 127;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:3919 mod[compile-time] 255[Byte], 127[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow off
code auto:3920 mod[Byte] 255[Byte], 128[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 128;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3921 mod[compile-time] 255[Byte], 128[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 128;
endcode
runtime noerror

$overflow on
code auto:3922 mod[Byte] 255[Byte], 128[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 128;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:3923 mod[compile-time] 255[Byte], 128[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 128;
endcode
varvalue r 127

$overflow off
code auto:3924 mod[Byte] 255[Byte], 255[Byte] -> [Int8] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:3925 mod[compile-time] 255[Byte], 255[Byte] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 255;
endcode
runtime noerror

$overflow on
code auto:3926 mod[Byte] 255[Byte], 255[Byte] -> [Int8] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 255;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:3927 mod[compile-time] 255[Byte], 255[Byte] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow off
code auto:3928 mod[Byte] 0[Byte], 0[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3929 mod[compile-time] 0[Byte], 0[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:3930 mod[Byte] 0[Byte], 0[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3931 mod[compile-time] 0[Byte], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:3932 mod[Byte] 0[Byte], 1[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3933 mod[compile-time] 0[Byte], 1[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 1;
endcode
runtime noerror

$overflow on
code auto:3934 mod[Byte] 0[Byte], 1[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3935 mod[compile-time] 0[Byte], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3936 mod[Byte] 0[Byte], 127[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3937 mod[compile-time] 0[Byte], 127[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 127;
endcode
runtime noerror

$overflow on
code auto:3938 mod[Byte] 0[Byte], 127[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3939 mod[compile-time] 0[Byte], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow off
code auto:3940 mod[Byte] 0[Byte], 128[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3941 mod[compile-time] 0[Byte], 128[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 128;
endcode
runtime noerror

$overflow on
code auto:3942 mod[Byte] 0[Byte], 128[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3943 mod[compile-time] 0[Byte], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow off
code auto:3944 mod[Byte] 0[Byte], 255[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3945 mod[compile-time] 0[Byte], 255[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 255;
endcode
runtime noerror

$overflow on
code auto:3946 mod[Byte] 0[Byte], 255[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3947 mod[compile-time] 0[Byte], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow off
code auto:3948 mod[Byte] 1[Byte], 0[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3949 mod[compile-time] 1[Byte], 0[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:3950 mod[Byte] 1[Byte], 0[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3951 mod[compile-time] 1[Byte], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 0;
endcode
compile error

$overflow off
code auto:3952 mod[Byte] 1[Byte], 1[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3953 mod[compile-time] 1[Byte], 1[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 1 mod 1;
endcode
runtime noerror

$overflow on
code auto:3954 mod[Byte] 1[Byte], 1[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3955 mod[compile-time] 1[Byte], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3956 mod[Byte] 1[Byte], 127[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3957 mod[compile-time] 1[Byte], 127[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 1 mod 127;
endcode
runtime noerror

$overflow on
code auto:3958 mod[Byte] 1[Byte], 127[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:3959 mod[compile-time] 1[Byte], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow off
code auto:3960 mod[Byte] 1[Byte], 128[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3961 mod[compile-time] 1[Byte], 128[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 1 mod 128;
endcode
runtime noerror

$overflow on
code auto:3962 mod[Byte] 1[Byte], 128[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:3963 mod[compile-time] 1[Byte], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow off
code auto:3964 mod[Byte] 1[Byte], 255[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3965 mod[compile-time] 1[Byte], 255[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 1 mod 255;
endcode
runtime noerror

$overflow on
code auto:3966 mod[Byte] 1[Byte], 255[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:3967 mod[compile-time] 1[Byte], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow off
code auto:3968 mod[Byte] 127[Byte], 0[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3969 mod[compile-time] 127[Byte], 0[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:3970 mod[Byte] 127[Byte], 0[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3971 mod[compile-time] 127[Byte], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 0;
endcode
compile error

$overflow off
code auto:3972 mod[Byte] 127[Byte], 1[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3973 mod[compile-time] 127[Byte], 1[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 127 mod 1;
endcode
runtime noerror

$overflow on
code auto:3974 mod[Byte] 127[Byte], 1[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3975 mod[compile-time] 127[Byte], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3976 mod[Byte] 127[Byte], 127[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3977 mod[compile-time] 127[Byte], 127[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 127 mod 127;
endcode
runtime noerror

$overflow on
code auto:3978 mod[Byte] 127[Byte], 127[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3979 mod[compile-time] 127[Byte], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:3980 mod[Byte] 127[Byte], 128[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3981 mod[compile-time] 127[Byte], 128[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 127 mod 128;
endcode
runtime noerror

$overflow on
code auto:3982 mod[Byte] 127[Byte], 128[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:3983 mod[compile-time] 127[Byte], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow off
code auto:3984 mod[Byte] 127[Byte], 255[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3985 mod[compile-time] 127[Byte], 255[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 127 mod 255;
endcode
runtime noerror

$overflow on
code auto:3986 mod[Byte] 127[Byte], 255[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:3987 mod[compile-time] 127[Byte], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow off
code auto:3988 mod[Byte] 128[Byte], 0[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3989 mod[compile-time] 128[Byte], 0[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:3990 mod[Byte] 128[Byte], 0[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:3991 mod[compile-time] 128[Byte], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 0;
endcode
compile error

$overflow off
code auto:3992 mod[Byte] 128[Byte], 1[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3993 mod[compile-time] 128[Byte], 1[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 128 mod 1;
endcode
runtime noerror

$overflow on
code auto:3994 mod[Byte] 128[Byte], 1[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:3995 mod[compile-time] 128[Byte], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow off
code auto:3996 mod[Byte] 128[Byte], 127[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:3997 mod[compile-time] 128[Byte], 127[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 128 mod 127;
endcode
runtime noerror

$overflow on
code auto:3998 mod[Byte] 128[Byte], 127[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:3999 mod[compile-time] 128[Byte], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow off
code auto:4000 mod[Byte] 128[Byte], 128[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4001 mod[compile-time] 128[Byte], 128[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 128 mod 128;
endcode
runtime noerror

$overflow on
code auto:4002 mod[Byte] 128[Byte], 128[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4003 mod[compile-time] 128[Byte], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 128;
endcode
varvalue r 0

$overflow off
code auto:4004 mod[Byte] 128[Byte], 255[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4005 mod[compile-time] 128[Byte], 255[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 128 mod 255;
endcode
runtime noerror

$overflow on
code auto:4006 mod[Byte] 128[Byte], 255[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:4007 mod[compile-time] 128[Byte], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 128 mod 255;
endcode
varvalue r 128

$overflow off
code auto:4008 mod[Byte] 255[Byte], 0[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4009 mod[compile-time] 255[Byte], 0[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:4010 mod[Byte] 255[Byte], 0[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4011 mod[compile-time] 255[Byte], 0[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 0;
endcode
compile error

$overflow off
code auto:4012 mod[Byte] 255[Byte], 1[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4013 mod[compile-time] 255[Byte], 1[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 1;
endcode
runtime noerror

$overflow on
code auto:4014 mod[Byte] 255[Byte], 1[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 1;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4015 mod[compile-time] 255[Byte], 1[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow off
code auto:4016 mod[Byte] 255[Byte], 127[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4017 mod[compile-time] 255[Byte], 127[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 127;
endcode
runtime noerror

$overflow on
code auto:4018 mod[Byte] 255[Byte], 127[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 127;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:4019 mod[compile-time] 255[Byte], 127[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow off
code auto:4020 mod[Byte] 255[Byte], 128[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4021 mod[compile-time] 255[Byte], 128[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 128;
endcode
runtime noerror

$overflow on
code auto:4022 mod[Byte] 255[Byte], 128[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 128;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:4023 mod[compile-time] 255[Byte], 128[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 128;
endcode
varvalue r 127

$overflow off
code auto:4024 mod[Byte] 255[Byte], 255[Byte] -> [Integer] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4025 mod[compile-time] 255[Byte], 255[Byte] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 255;
endcode
runtime noerror

$overflow on
code auto:4026 mod[Byte] 255[Byte], 255[Byte] -> [Integer] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4027 mod[compile-time] 255[Byte], 255[Byte] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow on
code auto:4028 mod[Byte] 0[Byte], 0[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4029 mod[compile-time] 0[Byte], 0[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:4030 mod[Byte] 0[Byte], 1[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4031 mod[compile-time] 0[Byte], 1[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow on
code auto:4032 mod[Byte] 0[Byte], 127[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4033 mod[compile-time] 0[Byte], 127[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow on
code auto:4034 mod[Byte] 0[Byte], 128[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4035 mod[compile-time] 0[Byte], 128[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow on
code auto:4036 mod[Byte] 0[Byte], 255[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4037 mod[compile-time] 0[Byte], 255[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:4038 mod[Byte] 1[Byte], 0[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4039 mod[compile-time] 1[Byte], 0[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:4040 mod[Byte] 1[Byte], 1[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4041 mod[compile-time] 1[Byte], 1[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow on
code auto:4042 mod[Byte] 1[Byte], 127[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:4043 mod[compile-time] 1[Byte], 127[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow on
code auto:4044 mod[Byte] 1[Byte], 128[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:4045 mod[compile-time] 1[Byte], 128[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow on
code auto:4046 mod[Byte] 1[Byte], 255[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:4047 mod[compile-time] 1[Byte], 255[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow on
code auto:4048 mod[Byte] 127[Byte], 0[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4049 mod[compile-time] 127[Byte], 0[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:4050 mod[Byte] 127[Byte], 1[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4051 mod[compile-time] 127[Byte], 1[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow on
code auto:4052 mod[Byte] 127[Byte], 127[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4053 mod[compile-time] 127[Byte], 127[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow on
code auto:4054 mod[Byte] 127[Byte], 128[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:4055 mod[compile-time] 127[Byte], 128[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow on
code auto:4056 mod[Byte] 127[Byte], 255[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:4057 mod[compile-time] 127[Byte], 255[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow on
code auto:4058 mod[Byte] 128[Byte], 0[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4059 mod[compile-time] 128[Byte], 0[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:4060 mod[Byte] 128[Byte], 1[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4061 mod[compile-time] 128[Byte], 1[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow on
code auto:4062 mod[Byte] 128[Byte], 127[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:4063 mod[compile-time] 128[Byte], 127[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow on
code auto:4064 mod[Byte] 128[Byte], 128[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4065 mod[compile-time] 128[Byte], 128[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 128;
endcode
varvalue r 0

$overflow on
code auto:4066 mod[Byte] 128[Byte], 255[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 128

code auto:4067 mod[compile-time] 128[Byte], 255[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 128 mod 255;
endcode
varvalue r 128

$overflow on
code auto:4068 mod[Byte] 255[Byte], 0[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4069 mod[compile-time] 255[Byte], 0[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:4070 mod[Byte] 255[Byte], 1[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 1;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4071 mod[compile-time] 255[Byte], 1[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow on
code auto:4072 mod[Byte] 255[Byte], 127[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 127;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:4073 mod[compile-time] 255[Byte], 127[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow on
code auto:4074 mod[Byte] 255[Byte], 128[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 128;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:4075 mod[compile-time] 255[Byte], 128[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 128;
endcode
varvalue r 127

$overflow on
code auto:4076 mod[Byte] 255[Byte], 255[Byte] -> [Byte] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4077 mod[compile-time] 255[Byte], 255[Byte] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4078 mod[Byte] 0[Byte], 0[Byte] -> [Word] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4079 mod[compile-time] 0[Byte], 0[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:4080 mod[Byte] 0[Byte], 0[Byte] -> [Word] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4081 mod[compile-time] 0[Byte], 0[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:4082 mod[Byte] 0[Byte], 1[Byte] -> [Word] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4083 mod[compile-time] 0[Byte], 1[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 1;
endcode
runtime noerror

$overflow on
code auto:4084 mod[Byte] 0[Byte], 1[Byte] -> [Word] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4085 mod[compile-time] 0[Byte], 1[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 1;
endcode
varvalue r 0

$overflow off
code auto:4086 mod[Byte] 0[Byte], 127[Byte] -> [Word] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4087 mod[compile-time] 0[Byte], 127[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 127;
endcode
runtime noerror

$overflow on
code auto:4088 mod[Byte] 0[Byte], 127[Byte] -> [Word] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4089 mod[compile-time] 0[Byte], 127[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 127;
endcode
varvalue r 0

$overflow off
code auto:4090 mod[Byte] 0[Byte], 128[Byte] -> [Word] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4091 mod[compile-time] 0[Byte], 128[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 128;
endcode
runtime noerror

$overflow on
code auto:4092 mod[Byte] 0[Byte], 128[Byte] -> [Word] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4093 mod[compile-time] 0[Byte], 128[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 128;
endcode
varvalue r 0

$overflow off
code auto:4094 mod[Byte] 0[Byte], 255[Byte] -> [Word] Var $overflow off
  var  a: Byte = 0;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4095 mod[compile-time] 0[Byte], 255[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 255;
endcode
runtime noerror

$overflow on
code auto:4096 mod[Byte] 0[Byte], 255[Byte] -> [Word] Var $overflow on
  var  a: Byte = 0;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4097 mod[compile-time] 0[Byte], 255[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4098 mod[Byte] 1[Byte], 0[Byte] -> [Word] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4099 mod[compile-time] 1[Byte], 0[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 0;
endcode
compile error

$overflow on
code auto:4100 mod[Byte] 1[Byte], 0[Byte] -> [Word] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4101 mod[compile-time] 1[Byte], 0[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 0;
endcode
compile error

$overflow off
code auto:4102 mod[Byte] 1[Byte], 1[Byte] -> [Word] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4103 mod[compile-time] 1[Byte], 1[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 1;
endcode
runtime noerror

$overflow on
code auto:4104 mod[Byte] 1[Byte], 1[Byte] -> [Word] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4105 mod[compile-time] 1[Byte], 1[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 1;
endcode
varvalue r 0

$overflow off
code auto:4106 mod[Byte] 1[Byte], 127[Byte] -> [Word] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4107 mod[compile-time] 1[Byte], 127[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 127;
endcode
runtime noerror

$overflow on
code auto:4108 mod[Byte] 1[Byte], 127[Byte] -> [Word] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:4109 mod[compile-time] 1[Byte], 127[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 127;
endcode
varvalue r 1

$overflow off
code auto:4110 mod[Byte] 1[Byte], 128[Byte] -> [Word] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4111 mod[compile-time] 1[Byte], 128[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 128;
endcode
runtime noerror

$overflow on
code auto:4112 mod[Byte] 1[Byte], 128[Byte] -> [Word] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:4113 mod[compile-time] 1[Byte], 128[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 128;
endcode
varvalue r 1

$overflow off
code auto:4114 mod[Byte] 1[Byte], 255[Byte] -> [Word] Var $overflow off
  var  a: Byte = 1;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4115 mod[compile-time] 1[Byte], 255[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 1 mod 255;
endcode
runtime noerror

$overflow on
code auto:4116 mod[Byte] 1[Byte], 255[Byte] -> [Word] Var $overflow on
  var  a: Byte = 1;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:4117 mod[compile-time] 1[Byte], 255[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 1 mod 255;
endcode
varvalue r 1

$overflow off
code auto:4118 mod[Byte] 127[Byte], 0[Byte] -> [Word] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4119 mod[compile-time] 127[Byte], 0[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 0;
endcode
compile error

$overflow on
code auto:4120 mod[Byte] 127[Byte], 0[Byte] -> [Word] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4121 mod[compile-time] 127[Byte], 0[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 0;
endcode
compile error

$overflow off
code auto:4122 mod[Byte] 127[Byte], 1[Byte] -> [Word] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4123 mod[compile-time] 127[Byte], 1[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 1;
endcode
runtime noerror

$overflow on
code auto:4124 mod[Byte] 127[Byte], 1[Byte] -> [Word] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4125 mod[compile-time] 127[Byte], 1[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 1;
endcode
varvalue r 0

$overflow off
code auto:4126 mod[Byte] 127[Byte], 127[Byte] -> [Word] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4127 mod[compile-time] 127[Byte], 127[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 127;
endcode
runtime noerror

$overflow on
code auto:4128 mod[Byte] 127[Byte], 127[Byte] -> [Word] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4129 mod[compile-time] 127[Byte], 127[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 127;
endcode
varvalue r 0

$overflow off
code auto:4130 mod[Byte] 127[Byte], 128[Byte] -> [Word] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4131 mod[compile-time] 127[Byte], 128[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 128;
endcode
runtime noerror

$overflow on
code auto:4132 mod[Byte] 127[Byte], 128[Byte] -> [Word] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:4133 mod[compile-time] 127[Byte], 128[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 128;
endcode
varvalue r 127

$overflow off
code auto:4134 mod[Byte] 127[Byte], 255[Byte] -> [Word] Var $overflow off
  var  a: Byte = 127;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4135 mod[compile-time] 127[Byte], 255[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 127 mod 255;
endcode
runtime noerror

$overflow on
code auto:4136 mod[Byte] 127[Byte], 255[Byte] -> [Word] Var $overflow on
  var  a: Byte = 127;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:4137 mod[compile-time] 127[Byte], 255[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 127 mod 255;
endcode
varvalue r 127

$overflow off
code auto:4138 mod[Byte] 128[Byte], 0[Byte] -> [Word] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4139 mod[compile-time] 128[Byte], 0[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod 0;
endcode
compile error

$overflow on
code auto:4140 mod[Byte] 128[Byte], 0[Byte] -> [Word] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4141 mod[compile-time] 128[Byte], 0[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 0;
endcode
compile error

$overflow off
code auto:4142 mod[Byte] 128[Byte], 1[Byte] -> [Word] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4143 mod[compile-time] 128[Byte], 1[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod 1;
endcode
runtime noerror

$overflow on
code auto:4144 mod[Byte] 128[Byte], 1[Byte] -> [Word] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4145 mod[compile-time] 128[Byte], 1[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 1;
endcode
varvalue r 0

$overflow off
code auto:4146 mod[Byte] 128[Byte], 127[Byte] -> [Word] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4147 mod[compile-time] 128[Byte], 127[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod 127;
endcode
runtime noerror

$overflow on
code auto:4148 mod[Byte] 128[Byte], 127[Byte] -> [Word] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:4149 mod[compile-time] 128[Byte], 127[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 127;
endcode
varvalue r 1

$overflow off
code auto:4150 mod[Byte] 128[Byte], 128[Byte] -> [Word] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4151 mod[compile-time] 128[Byte], 128[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod 128;
endcode
runtime noerror

$overflow on
code auto:4152 mod[Byte] 128[Byte], 128[Byte] -> [Word] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4153 mod[compile-time] 128[Byte], 128[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 128;
endcode
varvalue r 0

$overflow off
code auto:4154 mod[Byte] 128[Byte], 255[Byte] -> [Word] Var $overflow off
  var  a: Byte = 128;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4155 mod[compile-time] 128[Byte], 255[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 128 mod 255;
endcode
runtime noerror

$overflow on
code auto:4156 mod[Byte] 128[Byte], 255[Byte] -> [Word] Var $overflow on
  var  a: Byte = 128;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:4157 mod[compile-time] 128[Byte], 255[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 128 mod 255;
endcode
varvalue r 128

$overflow off
code auto:4158 mod[Byte] 255[Byte], 0[Byte] -> [Word] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4159 mod[compile-time] 255[Byte], 0[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:4160 mod[Byte] 255[Byte], 0[Byte] -> [Word] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4161 mod[compile-time] 255[Byte], 0[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 0;
endcode
compile error

$overflow off
code auto:4162 mod[Byte] 255[Byte], 1[Byte] -> [Word] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4163 mod[compile-time] 255[Byte], 1[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 255 mod 1;
endcode
runtime noerror

$overflow on
code auto:4164 mod[Byte] 255[Byte], 1[Byte] -> [Word] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 1;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4165 mod[compile-time] 255[Byte], 1[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 1;
endcode
varvalue r 0

$overflow off
code auto:4166 mod[Byte] 255[Byte], 127[Byte] -> [Word] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4167 mod[compile-time] 255[Byte], 127[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 255 mod 127;
endcode
runtime noerror

$overflow on
code auto:4168 mod[Byte] 255[Byte], 127[Byte] -> [Word] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 127;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:4169 mod[compile-time] 255[Byte], 127[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 127;
endcode
varvalue r 1

$overflow off
code auto:4170 mod[Byte] 255[Byte], 128[Byte] -> [Word] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4171 mod[compile-time] 255[Byte], 128[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 255 mod 128;
endcode
runtime noerror

$overflow on
code auto:4172 mod[Byte] 255[Byte], 128[Byte] -> [Word] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 128;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:4173 mod[compile-time] 255[Byte], 128[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 128;
endcode
varvalue r 127

$overflow off
code auto:4174 mod[Byte] 255[Byte], 255[Byte] -> [Word] Var $overflow off
  var  a: Byte = 255;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4175 mod[compile-time] 255[Byte], 255[Byte] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 255 mod 255;
endcode
runtime noerror

$overflow on
code auto:4176 mod[Byte] 255[Byte], 255[Byte] -> [Word] Var $overflow on
  var  a: Byte = 255;
  var  b: Byte = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4177 mod[compile-time] 255[Byte], 255[Byte] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4178 mod[Word] 0[Word], 0[Word] -> [Int8] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4179 mod[compile-time] 0[Word], 0[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:4180 mod[Word] 0[Word], 0[Word] -> [Int8] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4181 mod[compile-time] 0[Word], 0[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:4182 mod[Word] 0[Word], 255[Word] -> [Int8] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4183 mod[compile-time] 0[Word], 255[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 255;
endcode
runtime noerror

$overflow on
code auto:4184 mod[Word] 0[Word], 255[Word] -> [Int8] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 255;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4185 mod[compile-time] 0[Word], 255[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4186 mod[Word] 0[Word], 32767[Word] -> [Int8] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4187 mod[compile-time] 0[Word], 32767[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4188 mod[Word] 0[Word], 32767[Word] -> [Int8] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4189 mod[compile-time] 0[Word], 32767[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4190 mod[Word] 0[Word], 32768[Word] -> [Int8] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4191 mod[compile-time] 0[Word], 32768[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4192 mod[Word] 0[Word], 32768[Word] -> [Int8] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 32768;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4193 mod[compile-time] 0[Word], 32768[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4194 mod[Word] 0[Word], 65535[Word] -> [Int8] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4195 mod[compile-time] 0[Word], 65535[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4196 mod[Word] 0[Word], 65535[Word] -> [Int8] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 65535;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4197 mod[compile-time] 0[Word], 65535[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4198 mod[Word] 255[Word], 0[Word] -> [Int8] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4199 mod[compile-time] 255[Word], 0[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:4200 mod[Word] 255[Word], 0[Word] -> [Int8] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4201 mod[compile-time] 255[Word], 0[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 0;
endcode
compile error

$overflow off
code auto:4202 mod[Word] 255[Word], 255[Word] -> [Int8] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4203 mod[compile-time] 255[Word], 255[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 255;
endcode
runtime noerror

$overflow on
code auto:4204 mod[Word] 255[Word], 255[Word] -> [Int8] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 255;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4205 mod[compile-time] 255[Word], 255[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4206 mod[Word] 255[Word], 32767[Word] -> [Int8] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4207 mod[compile-time] 255[Word], 32767[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 32767;
endcode
compile error

$overflow on
code auto:4208 mod[Word] 255[Word], 32767[Word] -> [Int8] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4209 mod[compile-time] 255[Word], 32767[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 32767;
endcode
compile error

$overflow off
code auto:4210 mod[Word] 255[Word], 32768[Word] -> [Int8] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4211 mod[compile-time] 255[Word], 32768[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 32768;
endcode
compile error

$overflow on
code auto:4212 mod[Word] 255[Word], 32768[Word] -> [Int8] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4213 mod[compile-time] 255[Word], 32768[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 32768;
endcode
compile error

$overflow off
code auto:4214 mod[Word] 255[Word], 65535[Word] -> [Int8] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4215 mod[compile-time] 255[Word], 65535[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 65535;
endcode
compile error

$overflow on
code auto:4216 mod[Word] 255[Word], 65535[Word] -> [Int8] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4217 mod[compile-time] 255[Word], 65535[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 65535;
endcode
compile error

$overflow off
code auto:4218 mod[Word] 32767[Word], 0[Word] -> [Int8] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4219 mod[compile-time] 32767[Word], 0[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:4220 mod[Word] 32767[Word], 0[Word] -> [Int8] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4221 mod[compile-time] 32767[Word], 0[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 0;
endcode
compile error

$overflow off
code auto:4222 mod[Word] 32767[Word], 255[Word] -> [Int8] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4223 mod[compile-time] 32767[Word], 255[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 255;
endcode
runtime noerror

$overflow on
code auto:4224 mod[Word] 32767[Word], 255[Word] -> [Int8] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 255;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:4225 mod[compile-time] 32767[Word], 255[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow off
code auto:4226 mod[Word] 32767[Word], 32767[Word] -> [Int8] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4227 mod[compile-time] 32767[Word], 32767[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4228 mod[Word] 32767[Word], 32767[Word] -> [Int8] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4229 mod[compile-time] 32767[Word], 32767[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4230 mod[Word] 32767[Word], 32768[Word] -> [Int8] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4231 mod[compile-time] 32767[Word], 32768[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 32768;
endcode
compile error

$overflow on
code auto:4232 mod[Word] 32767[Word], 32768[Word] -> [Int8] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4233 mod[compile-time] 32767[Word], 32768[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 32768;
endcode
compile error

$overflow off
code auto:4234 mod[Word] 32767[Word], 65535[Word] -> [Int8] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4235 mod[compile-time] 32767[Word], 65535[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 65535;
endcode
compile error

$overflow on
code auto:4236 mod[Word] 32767[Word], 65535[Word] -> [Int8] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4237 mod[compile-time] 32767[Word], 65535[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 65535;
endcode
compile error

$overflow off
code auto:4238 mod[Word] 32768[Word], 0[Word] -> [Int8] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4239 mod[compile-time] 32768[Word], 0[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:4240 mod[Word] 32768[Word], 0[Word] -> [Int8] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4241 mod[compile-time] 32768[Word], 0[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32768 mod 0;
endcode
compile error

$overflow off
code auto:4242 mod[Word] 32768[Word], 255[Word] -> [Int8] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4243 mod[compile-time] 32768[Word], 255[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32768 mod 255;
endcode
compile error

$overflow on
code auto:4244 mod[Word] 32768[Word], 255[Word] -> [Int8] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4245 mod[compile-time] 32768[Word], 255[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32768 mod 255;
endcode
compile error

$overflow off
code auto:4246 mod[Word] 32768[Word], 32767[Word] -> [Int8] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4247 mod[compile-time] 32768[Word], 32767[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32768 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4248 mod[Word] 32768[Word], 32767[Word] -> [Int8] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:4249 mod[compile-time] 32768[Word], 32767[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4250 mod[Word] 32768[Word], 32768[Word] -> [Int8] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4251 mod[compile-time] 32768[Word], 32768[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32768 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4252 mod[Word] 32768[Word], 32768[Word] -> [Int8] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 32768;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4253 mod[compile-time] 32768[Word], 32768[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32768 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4254 mod[Word] 32768[Word], 65535[Word] -> [Int8] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4255 mod[compile-time] 32768[Word], 65535[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32768 mod 65535;
endcode
compile error

$overflow on
code auto:4256 mod[Word] 32768[Word], 65535[Word] -> [Int8] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4257 mod[compile-time] 32768[Word], 65535[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32768 mod 65535;
endcode
compile error

$overflow off
code auto:4258 mod[Word] 65535[Word], 0[Word] -> [Int8] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4259 mod[compile-time] 65535[Word], 0[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:4260 mod[Word] 65535[Word], 0[Word] -> [Int8] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4261 mod[compile-time] 65535[Word], 0[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 65535 mod 0;
endcode
compile error

$overflow off
code auto:4262 mod[Word] 65535[Word], 255[Word] -> [Int8] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4263 mod[compile-time] 65535[Word], 255[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 65535 mod 255;
endcode
runtime noerror

$overflow on
code auto:4264 mod[Word] 65535[Word], 255[Word] -> [Int8] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 255;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4265 mod[compile-time] 65535[Word], 255[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4266 mod[Word] 65535[Word], 32767[Word] -> [Int8] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4267 mod[compile-time] 65535[Word], 32767[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 65535 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4268 mod[Word] 65535[Word], 32767[Word] -> [Int8] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:4269 mod[compile-time] 65535[Word], 32767[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4270 mod[Word] 65535[Word], 32768[Word] -> [Int8] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4271 mod[compile-time] 65535[Word], 32768[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 65535 mod 32768;
endcode
compile error

$overflow on
code auto:4272 mod[Word] 65535[Word], 32768[Word] -> [Int8] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4273 mod[compile-time] 65535[Word], 32768[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 65535 mod 32768;
endcode
compile error

$overflow off
code auto:4274 mod[Word] 65535[Word], 65535[Word] -> [Int8] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4275 mod[compile-time] 65535[Word], 65535[Word] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 65535 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4276 mod[Word] 65535[Word], 65535[Word] -> [Int8] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 65535;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4277 mod[compile-time] 65535[Word], 65535[Word] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 65535 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4278 mod[Word] 0[Word], 0[Word] -> [Integer] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4279 mod[compile-time] 0[Word], 0[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:4280 mod[Word] 0[Word], 0[Word] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4281 mod[compile-time] 0[Word], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:4282 mod[Word] 0[Word], 255[Word] -> [Integer] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4283 mod[compile-time] 0[Word], 255[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 255;
endcode
runtime noerror

$overflow on
code auto:4284 mod[Word] 0[Word], 255[Word] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4285 mod[compile-time] 0[Word], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4286 mod[Word] 0[Word], 32767[Word] -> [Integer] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4287 mod[compile-time] 0[Word], 32767[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4288 mod[Word] 0[Word], 32767[Word] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4289 mod[compile-time] 0[Word], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4290 mod[Word] 0[Word], 32768[Word] -> [Integer] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4291 mod[compile-time] 0[Word], 32768[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4292 mod[Word] 0[Word], 32768[Word] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4293 mod[compile-time] 0[Word], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4294 mod[Word] 0[Word], 65535[Word] -> [Integer] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4295 mod[compile-time] 0[Word], 65535[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4296 mod[Word] 0[Word], 65535[Word] -> [Integer] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4297 mod[compile-time] 0[Word], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4298 mod[Word] 255[Word], 0[Word] -> [Integer] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4299 mod[compile-time] 255[Word], 0[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:4300 mod[Word] 255[Word], 0[Word] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4301 mod[compile-time] 255[Word], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 0;
endcode
compile error

$overflow off
code auto:4302 mod[Word] 255[Word], 255[Word] -> [Integer] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4303 mod[compile-time] 255[Word], 255[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 255;
endcode
runtime noerror

$overflow on
code auto:4304 mod[Word] 255[Word], 255[Word] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4305 mod[compile-time] 255[Word], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4306 mod[Word] 255[Word], 32767[Word] -> [Integer] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4307 mod[compile-time] 255[Word], 32767[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4308 mod[Word] 255[Word], 32767[Word] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 255

code auto:4309 mod[compile-time] 255[Word], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow off
code auto:4310 mod[Word] 255[Word], 32768[Word] -> [Integer] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4311 mod[compile-time] 255[Word], 32768[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4312 mod[Word] 255[Word], 32768[Word] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 255

code auto:4313 mod[compile-time] 255[Word], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 32768;
endcode
varvalue r 255

$overflow off
code auto:4314 mod[Word] 255[Word], 65535[Word] -> [Integer] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4315 mod[compile-time] 255[Word], 65535[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4316 mod[Word] 255[Word], 65535[Word] -> [Integer] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 255

code auto:4317 mod[compile-time] 255[Word], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 65535;
endcode
varvalue r 255

$overflow off
code auto:4318 mod[Word] 32767[Word], 0[Word] -> [Integer] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4319 mod[compile-time] 32767[Word], 0[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:4320 mod[Word] 32767[Word], 0[Word] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4321 mod[compile-time] 32767[Word], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 0;
endcode
compile error

$overflow off
code auto:4322 mod[Word] 32767[Word], 255[Word] -> [Integer] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4323 mod[compile-time] 32767[Word], 255[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32767 mod 255;
endcode
runtime noerror

$overflow on
code auto:4324 mod[Word] 32767[Word], 255[Word] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:4325 mod[compile-time] 32767[Word], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow off
code auto:4326 mod[Word] 32767[Word], 32767[Word] -> [Integer] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4327 mod[compile-time] 32767[Word], 32767[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4328 mod[Word] 32767[Word], 32767[Word] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4329 mod[compile-time] 32767[Word], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4330 mod[Word] 32767[Word], 32768[Word] -> [Integer] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4331 mod[compile-time] 32767[Word], 32768[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32767 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4332 mod[Word] 32767[Word], 32768[Word] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 32767

code auto:4333 mod[compile-time] 32767[Word], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 32768;
endcode
varvalue r 32767

$overflow off
code auto:4334 mod[Word] 32767[Word], 65535[Word] -> [Integer] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4335 mod[compile-time] 32767[Word], 65535[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32767 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4336 mod[Word] 32767[Word], 65535[Word] -> [Integer] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 32767

code auto:4337 mod[compile-time] 32767[Word], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 65535;
endcode
varvalue r 32767

$overflow off
code auto:4338 mod[Word] 32768[Word], 0[Word] -> [Integer] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4339 mod[compile-time] 32768[Word], 0[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:4340 mod[Word] 32768[Word], 0[Word] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4341 mod[compile-time] 32768[Word], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 0;
endcode
compile error

$overflow off
code auto:4342 mod[Word] 32768[Word], 255[Word] -> [Integer] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4343 mod[compile-time] 32768[Word], 255[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32768 mod 255;
endcode
runtime noerror

$overflow on
code auto:4344 mod[Word] 32768[Word], 255[Word] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:4345 mod[compile-time] 32768[Word], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 255;
endcode
varvalue r 128

$overflow off
code auto:4346 mod[Word] 32768[Word], 32767[Word] -> [Integer] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4347 mod[compile-time] 32768[Word], 32767[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32768 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4348 mod[Word] 32768[Word], 32767[Word] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:4349 mod[compile-time] 32768[Word], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4350 mod[Word] 32768[Word], 32768[Word] -> [Integer] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4351 mod[compile-time] 32768[Word], 32768[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32768 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4352 mod[Word] 32768[Word], 32768[Word] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4353 mod[compile-time] 32768[Word], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4354 mod[Word] 32768[Word], 65535[Word] -> [Integer] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4355 mod[compile-time] 32768[Word], 65535[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32768 mod 65535;
endcode
compile error

$overflow on
code auto:4356 mod[Word] 32768[Word], 65535[Word] -> [Integer] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
runtime overflow

code auto:4357 mod[compile-time] 32768[Word], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 65535;
endcode
compile error

$overflow off
code auto:4358 mod[Word] 65535[Word], 0[Word] -> [Integer] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4359 mod[compile-time] 65535[Word], 0[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:4360 mod[Word] 65535[Word], 0[Word] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4361 mod[compile-time] 65535[Word], 0[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 0;
endcode
compile error

$overflow off
code auto:4362 mod[Word] 65535[Word], 255[Word] -> [Integer] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4363 mod[compile-time] 65535[Word], 255[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 65535 mod 255;
endcode
runtime noerror

$overflow on
code auto:4364 mod[Word] 65535[Word], 255[Word] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4365 mod[compile-time] 65535[Word], 255[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4366 mod[Word] 65535[Word], 32767[Word] -> [Integer] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4367 mod[compile-time] 65535[Word], 32767[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 65535 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4368 mod[Word] 65535[Word], 32767[Word] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:4369 mod[compile-time] 65535[Word], 32767[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4370 mod[Word] 65535[Word], 32768[Word] -> [Integer] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4371 mod[compile-time] 65535[Word], 32768[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 65535 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4372 mod[Word] 65535[Word], 32768[Word] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 32767

code auto:4373 mod[compile-time] 65535[Word], 32768[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 32768;
endcode
varvalue r 32767

$overflow off
code auto:4374 mod[Word] 65535[Word], 65535[Word] -> [Integer] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4375 mod[compile-time] 65535[Word], 65535[Word] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 65535 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4376 mod[Word] 65535[Word], 65535[Word] -> [Integer] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4377 mod[compile-time] 65535[Word], 65535[Word] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4378 mod[Word] 0[Word], 0[Word] -> [Byte] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4379 mod[compile-time] 0[Word], 0[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:4380 mod[Word] 0[Word], 0[Word] -> [Byte] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4381 mod[compile-time] 0[Word], 0[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:4382 mod[Word] 0[Word], 255[Word] -> [Byte] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 255;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4383 mod[compile-time] 0[Word], 255[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 255;
endcode
runtime noerror

$overflow on
code auto:4384 mod[Word] 0[Word], 255[Word] -> [Byte] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4385 mod[compile-time] 0[Word], 255[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4386 mod[Word] 0[Word], 32767[Word] -> [Byte] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4387 mod[compile-time] 0[Word], 32767[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4388 mod[Word] 0[Word], 32767[Word] -> [Byte] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4389 mod[compile-time] 0[Word], 32767[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4390 mod[Word] 0[Word], 32768[Word] -> [Byte] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4391 mod[compile-time] 0[Word], 32768[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4392 mod[Word] 0[Word], 32768[Word] -> [Byte] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 32768;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4393 mod[compile-time] 0[Word], 32768[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4394 mod[Word] 0[Word], 65535[Word] -> [Byte] Var $overflow off
  var  a: Word = 0;
  var  b: Word = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4395 mod[compile-time] 0[Word], 65535[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4396 mod[Word] 0[Word], 65535[Word] -> [Byte] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 65535;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4397 mod[compile-time] 0[Word], 65535[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4398 mod[Word] 255[Word], 0[Word] -> [Byte] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4399 mod[compile-time] 255[Word], 0[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:4400 mod[Word] 255[Word], 0[Word] -> [Byte] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4401 mod[compile-time] 255[Word], 0[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 0;
endcode
compile error

$overflow off
code auto:4402 mod[Word] 255[Word], 255[Word] -> [Byte] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 255;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4403 mod[compile-time] 255[Word], 255[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 255 mod 255;
endcode
runtime noerror

$overflow on
code auto:4404 mod[Word] 255[Word], 255[Word] -> [Byte] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4405 mod[compile-time] 255[Word], 255[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4406 mod[Word] 255[Word], 32767[Word] -> [Byte] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4407 mod[compile-time] 255[Word], 32767[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 255 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4408 mod[Word] 255[Word], 32767[Word] -> [Byte] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 255

code auto:4409 mod[compile-time] 255[Word], 32767[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow off
code auto:4410 mod[Word] 255[Word], 32768[Word] -> [Byte] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4411 mod[compile-time] 255[Word], 32768[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 255 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4412 mod[Word] 255[Word], 32768[Word] -> [Byte] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 32768;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 255

code auto:4413 mod[compile-time] 255[Word], 32768[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 32768;
endcode
varvalue r 255

$overflow off
code auto:4414 mod[Word] 255[Word], 65535[Word] -> [Byte] Var $overflow off
  var  a: Word = 255;
  var  b: Word = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4415 mod[compile-time] 255[Word], 65535[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 255 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4416 mod[Word] 255[Word], 65535[Word] -> [Byte] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 65535;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 255

code auto:4417 mod[compile-time] 255[Word], 65535[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 65535;
endcode
varvalue r 255

$overflow off
code auto:4418 mod[Word] 32767[Word], 0[Word] -> [Byte] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4419 mod[compile-time] 32767[Word], 0[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:4420 mod[Word] 32767[Word], 0[Word] -> [Byte] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4421 mod[compile-time] 32767[Word], 0[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 0;
endcode
compile error

$overflow off
code auto:4422 mod[Word] 32767[Word], 255[Word] -> [Byte] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 255;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4423 mod[compile-time] 32767[Word], 255[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 255;
endcode
runtime noerror

$overflow on
code auto:4424 mod[Word] 32767[Word], 255[Word] -> [Byte] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:4425 mod[compile-time] 32767[Word], 255[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow off
code auto:4426 mod[Word] 32767[Word], 32767[Word] -> [Byte] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4427 mod[compile-time] 32767[Word], 32767[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4428 mod[Word] 32767[Word], 32767[Word] -> [Byte] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4429 mod[compile-time] 32767[Word], 32767[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4430 mod[Word] 32767[Word], 32768[Word] -> [Byte] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4431 mod[compile-time] 32767[Word], 32768[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 32768;
endcode
compile error

$overflow on
code auto:4432 mod[Word] 32767[Word], 32768[Word] -> [Byte] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:4433 mod[compile-time] 32767[Word], 32768[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 32768;
endcode
compile error

$overflow off
code auto:4434 mod[Word] 32767[Word], 65535[Word] -> [Byte] Var $overflow off
  var  a: Word = 32767;
  var  b: Word = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4435 mod[compile-time] 32767[Word], 65535[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 65535;
endcode
compile error

$overflow on
code auto:4436 mod[Word] 32767[Word], 65535[Word] -> [Byte] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:4437 mod[compile-time] 32767[Word], 65535[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 65535;
endcode
compile error

$overflow off
code auto:4438 mod[Word] 32768[Word], 0[Word] -> [Byte] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4439 mod[compile-time] 32768[Word], 0[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:4440 mod[Word] 32768[Word], 0[Word] -> [Byte] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4441 mod[compile-time] 32768[Word], 0[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32768 mod 0;
endcode
compile error

$overflow off
code auto:4442 mod[Word] 32768[Word], 255[Word] -> [Byte] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 255;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4443 mod[compile-time] 32768[Word], 255[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32768 mod 255;
endcode
runtime noerror

$overflow on
code auto:4444 mod[Word] 32768[Word], 255[Word] -> [Byte] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 128

code auto:4445 mod[compile-time] 32768[Word], 255[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32768 mod 255;
endcode
varvalue r 128

$overflow off
code auto:4446 mod[Word] 32768[Word], 32767[Word] -> [Byte] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4447 mod[compile-time] 32768[Word], 32767[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32768 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4448 mod[Word] 32768[Word], 32767[Word] -> [Byte] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:4449 mod[compile-time] 32768[Word], 32767[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4450 mod[Word] 32768[Word], 32768[Word] -> [Byte] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4451 mod[compile-time] 32768[Word], 32768[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32768 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4452 mod[Word] 32768[Word], 32768[Word] -> [Byte] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 32768;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4453 mod[compile-time] 32768[Word], 32768[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32768 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4454 mod[Word] 32768[Word], 65535[Word] -> [Byte] Var $overflow off
  var  a: Word = 32768;
  var  b: Word = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4455 mod[compile-time] 32768[Word], 65535[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32768 mod 65535;
endcode
compile error

$overflow on
code auto:4456 mod[Word] 32768[Word], 65535[Word] -> [Byte] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:4457 mod[compile-time] 32768[Word], 65535[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32768 mod 65535;
endcode
compile error

$overflow off
code auto:4458 mod[Word] 65535[Word], 0[Word] -> [Byte] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4459 mod[compile-time] 65535[Word], 0[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:4460 mod[Word] 65535[Word], 0[Word] -> [Byte] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4461 mod[compile-time] 65535[Word], 0[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 65535 mod 0;
endcode
compile error

$overflow off
code auto:4462 mod[Word] 65535[Word], 255[Word] -> [Byte] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 255;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4463 mod[compile-time] 65535[Word], 255[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 65535 mod 255;
endcode
runtime noerror

$overflow on
code auto:4464 mod[Word] 65535[Word], 255[Word] -> [Byte] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4465 mod[compile-time] 65535[Word], 255[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4466 mod[Word] 65535[Word], 32767[Word] -> [Byte] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4467 mod[compile-time] 65535[Word], 32767[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 65535 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4468 mod[Word] 65535[Word], 32767[Word] -> [Byte] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:4469 mod[compile-time] 65535[Word], 32767[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4470 mod[Word] 65535[Word], 32768[Word] -> [Byte] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4471 mod[compile-time] 65535[Word], 32768[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 65535 mod 32768;
endcode
compile error

$overflow on
code auto:4472 mod[Word] 65535[Word], 32768[Word] -> [Byte] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:4473 mod[compile-time] 65535[Word], 32768[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 65535 mod 32768;
endcode
compile error

$overflow off
code auto:4474 mod[Word] 65535[Word], 65535[Word] -> [Byte] Var $overflow off
  var  a: Word = 65535;
  var  b: Word = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4475 mod[compile-time] 65535[Word], 65535[Word] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 65535 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4476 mod[Word] 65535[Word], 65535[Word] -> [Byte] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 65535;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4477 mod[compile-time] 65535[Word], 65535[Word] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 65535 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:4478 mod[Word] 0[Word], 0[Word] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4479 mod[compile-time] 0[Word], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:4480 mod[Word] 0[Word], 255[Word] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4481 mod[compile-time] 0[Word], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow on
code auto:4482 mod[Word] 0[Word], 32767[Word] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4483 mod[compile-time] 0[Word], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:4484 mod[Word] 0[Word], 32768[Word] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4485 mod[compile-time] 0[Word], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:4486 mod[Word] 0[Word], 65535[Word] -> [Word] Var $overflow on
  var  a: Word = 0;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4487 mod[compile-time] 0[Word], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow on
code auto:4488 mod[Word] 255[Word], 0[Word] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4489 mod[compile-time] 255[Word], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:4490 mod[Word] 255[Word], 255[Word] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4491 mod[compile-time] 255[Word], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow on
code auto:4492 mod[Word] 255[Word], 32767[Word] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 255

code auto:4493 mod[compile-time] 255[Word], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow on
code auto:4494 mod[Word] 255[Word], 32768[Word] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 255

code auto:4495 mod[compile-time] 255[Word], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 32768;
endcode
varvalue r 255

$overflow on
code auto:4496 mod[Word] 255[Word], 65535[Word] -> [Word] Var $overflow on
  var  a: Word = 255;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 255

code auto:4497 mod[compile-time] 255[Word], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 65535;
endcode
varvalue r 255

$overflow on
code auto:4498 mod[Word] 32767[Word], 0[Word] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4499 mod[compile-time] 32767[Word], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:4500 mod[Word] 32767[Word], 255[Word] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:4501 mod[compile-time] 32767[Word], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow on
code auto:4502 mod[Word] 32767[Word], 32767[Word] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4503 mod[compile-time] 32767[Word], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow on
code auto:4504 mod[Word] 32767[Word], 32768[Word] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32767

code auto:4505 mod[compile-time] 32767[Word], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 32768;
endcode
varvalue r 32767

$overflow on
code auto:4506 mod[Word] 32767[Word], 65535[Word] -> [Word] Var $overflow on
  var  a: Word = 32767;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32767

code auto:4507 mod[compile-time] 32767[Word], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 65535;
endcode
varvalue r 32767

$overflow on
code auto:4508 mod[Word] 32768[Word], 0[Word] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4509 mod[compile-time] 32768[Word], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:4510 mod[Word] 32768[Word], 255[Word] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:4511 mod[compile-time] 32768[Word], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 255;
endcode
varvalue r 128

$overflow on
code auto:4512 mod[Word] 32768[Word], 32767[Word] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:4513 mod[compile-time] 32768[Word], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:4514 mod[Word] 32768[Word], 32768[Word] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4515 mod[compile-time] 32768[Word], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 32768;
endcode
varvalue r 0

$overflow on
code auto:4516 mod[Word] 32768[Word], 65535[Word] -> [Word] Var $overflow on
  var  a: Word = 32768;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32768

code auto:4517 mod[compile-time] 32768[Word], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 65535;
endcode
varvalue r 32768

$overflow on
code auto:4518 mod[Word] 65535[Word], 0[Word] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4519 mod[compile-time] 65535[Word], 0[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:4520 mod[Word] 65535[Word], 255[Word] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4521 mod[compile-time] 65535[Word], 255[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow on
code auto:4522 mod[Word] 65535[Word], 32767[Word] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:4523 mod[compile-time] 65535[Word], 32767[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow on
code auto:4524 mod[Word] 65535[Word], 32768[Word] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32767

code auto:4525 mod[compile-time] 65535[Word], 32768[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 32768;
endcode
varvalue r 32767

$overflow on
code auto:4526 mod[Word] 65535[Word], 65535[Word] -> [Word] Var $overflow on
  var  a: Word = 65535;
  var  b: Word = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4527 mod[compile-time] 65535[Word], 65535[Word] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4528 mod[Pointer] 0[Pointer], 0[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4529 mod[compile-time] 0[Pointer], 0[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:4530 mod[Pointer] 0[Pointer], 0[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4531 mod[compile-time] 0[Pointer], 0[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:4532 mod[Pointer] 0[Pointer], 255[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4533 mod[compile-time] 0[Pointer], 255[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 255;
endcode
runtime noerror

$overflow on
code auto:4534 mod[Pointer] 0[Pointer], 255[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 255;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4535 mod[compile-time] 0[Pointer], 255[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4536 mod[Pointer] 0[Pointer], 32767[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4537 mod[compile-time] 0[Pointer], 32767[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4538 mod[Pointer] 0[Pointer], 32767[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4539 mod[compile-time] 0[Pointer], 32767[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4540 mod[Pointer] 0[Pointer], 32768[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4541 mod[compile-time] 0[Pointer], 32768[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4542 mod[Pointer] 0[Pointer], 32768[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 32768;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4543 mod[compile-time] 0[Pointer], 32768[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4544 mod[Pointer] 0[Pointer], 65535[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4545 mod[compile-time] 0[Pointer], 65535[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 0 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4546 mod[Pointer] 0[Pointer], 65535[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 65535;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4547 mod[compile-time] 0[Pointer], 65535[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4548 mod[Pointer] 255[Pointer], 0[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4549 mod[compile-time] 255[Pointer], 0[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:4550 mod[Pointer] 255[Pointer], 0[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4551 mod[compile-time] 255[Pointer], 0[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 0;
endcode
compile error

$overflow off
code auto:4552 mod[Pointer] 255[Pointer], 255[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4553 mod[compile-time] 255[Pointer], 255[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 255;
endcode
runtime noerror

$overflow on
code auto:4554 mod[Pointer] 255[Pointer], 255[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 255;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4555 mod[compile-time] 255[Pointer], 255[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4556 mod[Pointer] 255[Pointer], 32767[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4557 mod[compile-time] 255[Pointer], 32767[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 32767;
endcode
compile error

$overflow on
code auto:4558 mod[Pointer] 255[Pointer], 32767[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4559 mod[compile-time] 255[Pointer], 32767[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 32767;
endcode
compile error

$overflow off
code auto:4560 mod[Pointer] 255[Pointer], 32768[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4561 mod[compile-time] 255[Pointer], 32768[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 32768;
endcode
compile error

$overflow on
code auto:4562 mod[Pointer] 255[Pointer], 32768[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4563 mod[compile-time] 255[Pointer], 32768[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 32768;
endcode
compile error

$overflow off
code auto:4564 mod[Pointer] 255[Pointer], 65535[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4565 mod[compile-time] 255[Pointer], 65535[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 255 mod 65535;
endcode
compile error

$overflow on
code auto:4566 mod[Pointer] 255[Pointer], 65535[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4567 mod[compile-time] 255[Pointer], 65535[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 255 mod 65535;
endcode
compile error

$overflow off
code auto:4568 mod[Pointer] 32767[Pointer], 0[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4569 mod[compile-time] 32767[Pointer], 0[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:4570 mod[Pointer] 32767[Pointer], 0[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4571 mod[compile-time] 32767[Pointer], 0[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 0;
endcode
compile error

$overflow off
code auto:4572 mod[Pointer] 32767[Pointer], 255[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4573 mod[compile-time] 32767[Pointer], 255[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 255;
endcode
runtime noerror

$overflow on
code auto:4574 mod[Pointer] 32767[Pointer], 255[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 255;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 127

code auto:4575 mod[compile-time] 32767[Pointer], 255[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow off
code auto:4576 mod[Pointer] 32767[Pointer], 32767[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4577 mod[compile-time] 32767[Pointer], 32767[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4578 mod[Pointer] 32767[Pointer], 32767[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4579 mod[compile-time] 32767[Pointer], 32767[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4580 mod[Pointer] 32767[Pointer], 32768[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4581 mod[compile-time] 32767[Pointer], 32768[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 32768;
endcode
compile error

$overflow on
code auto:4582 mod[Pointer] 32767[Pointer], 32768[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4583 mod[compile-time] 32767[Pointer], 32768[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 32768;
endcode
compile error

$overflow off
code auto:4584 mod[Pointer] 32767[Pointer], 65535[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4585 mod[compile-time] 32767[Pointer], 65535[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32767 mod 65535;
endcode
compile error

$overflow on
code auto:4586 mod[Pointer] 32767[Pointer], 65535[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4587 mod[compile-time] 32767[Pointer], 65535[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32767 mod 65535;
endcode
compile error

$overflow off
code auto:4588 mod[Pointer] 32768[Pointer], 0[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4589 mod[compile-time] 32768[Pointer], 0[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:4590 mod[Pointer] 32768[Pointer], 0[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4591 mod[compile-time] 32768[Pointer], 0[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32768 mod 0;
endcode
compile error

$overflow off
code auto:4592 mod[Pointer] 32768[Pointer], 255[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4593 mod[compile-time] 32768[Pointer], 255[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32768 mod 255;
endcode
compile error

$overflow on
code auto:4594 mod[Pointer] 32768[Pointer], 255[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4595 mod[compile-time] 32768[Pointer], 255[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32768 mod 255;
endcode
compile error

$overflow off
code auto:4596 mod[Pointer] 32768[Pointer], 32767[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4597 mod[compile-time] 32768[Pointer], 32767[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32768 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4598 mod[Pointer] 32768[Pointer], 32767[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:4599 mod[compile-time] 32768[Pointer], 32767[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4600 mod[Pointer] 32768[Pointer], 32768[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4601 mod[compile-time] 32768[Pointer], 32768[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32768 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4602 mod[Pointer] 32768[Pointer], 32768[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 32768;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4603 mod[compile-time] 32768[Pointer], 32768[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32768 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4604 mod[Pointer] 32768[Pointer], 65535[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4605 mod[compile-time] 32768[Pointer], 65535[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 32768 mod 65535;
endcode
compile error

$overflow on
code auto:4606 mod[Pointer] 32768[Pointer], 65535[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4607 mod[compile-time] 32768[Pointer], 65535[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 32768 mod 65535;
endcode
compile error

$overflow off
code auto:4608 mod[Pointer] 65535[Pointer], 0[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4609 mod[compile-time] 65535[Pointer], 0[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:4610 mod[Pointer] 65535[Pointer], 0[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 0;
  var  r: Int8;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4611 mod[compile-time] 65535[Pointer], 0[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 65535 mod 0;
endcode
compile error

$overflow off
code auto:4612 mod[Pointer] 65535[Pointer], 255[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 255;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4613 mod[compile-time] 65535[Pointer], 255[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 65535 mod 255;
endcode
runtime noerror

$overflow on
code auto:4614 mod[Pointer] 65535[Pointer], 255[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 255;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4615 mod[compile-time] 65535[Pointer], 255[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4616 mod[Pointer] 65535[Pointer], 32767[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4617 mod[compile-time] 65535[Pointer], 32767[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 65535 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4618 mod[Pointer] 65535[Pointer], 32767[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 32767;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 1

code auto:4619 mod[compile-time] 65535[Pointer], 32767[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4620 mod[Pointer] 65535[Pointer], 32768[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4621 mod[compile-time] 65535[Pointer], 32768[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 65535 mod 32768;
endcode
compile error

$overflow on
code auto:4622 mod[Pointer] 65535[Pointer], 32768[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 32768;
  var  r: Int8;
  r := a mod b;
endcode
runtime overflow

code auto:4623 mod[compile-time] 65535[Pointer], 32768[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 65535 mod 32768;
endcode
compile error

$overflow off
code auto:4624 mod[Pointer] 65535[Pointer], 65535[Pointer] -> [Int8] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 65535;
  var  r: Int8;
  r := a mod b;
endcode
runtime noerror

code auto:4625 mod[compile-time] 65535[Pointer], 65535[Pointer] -> [Int8] Both immediate $overflow off
  var  r: Int8;
  r := 65535 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4626 mod[Pointer] 65535[Pointer], 65535[Pointer] -> [Int8] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 65535;
  var  r: Int8;
  r := a mod b;
endcode
varvalue r 0

code auto:4627 mod[compile-time] 65535[Pointer], 65535[Pointer] -> [Int8] Both immediate $overflow on
  var  r: Int8;
  r := 65535 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4628 mod[Pointer] 0[Pointer], 0[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4629 mod[compile-time] 0[Pointer], 0[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:4630 mod[Pointer] 0[Pointer], 0[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4631 mod[compile-time] 0[Pointer], 0[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:4632 mod[Pointer] 0[Pointer], 255[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4633 mod[compile-time] 0[Pointer], 255[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 255;
endcode
runtime noerror

$overflow on
code auto:4634 mod[Pointer] 0[Pointer], 255[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4635 mod[compile-time] 0[Pointer], 255[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4636 mod[Pointer] 0[Pointer], 32767[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4637 mod[compile-time] 0[Pointer], 32767[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4638 mod[Pointer] 0[Pointer], 32767[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4639 mod[compile-time] 0[Pointer], 32767[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4640 mod[Pointer] 0[Pointer], 32768[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 32768;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4641 mod[compile-time] 0[Pointer], 32768[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4642 mod[Pointer] 0[Pointer], 32768[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4643 mod[compile-time] 0[Pointer], 32768[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4644 mod[Pointer] 0[Pointer], 65535[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 65535;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4645 mod[compile-time] 0[Pointer], 65535[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 0 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4646 mod[Pointer] 0[Pointer], 65535[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4647 mod[compile-time] 0[Pointer], 65535[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4648 mod[Pointer] 255[Pointer], 0[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4649 mod[compile-time] 255[Pointer], 0[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:4650 mod[Pointer] 255[Pointer], 0[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4651 mod[compile-time] 255[Pointer], 0[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 0;
endcode
compile error

$overflow off
code auto:4652 mod[Pointer] 255[Pointer], 255[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4653 mod[compile-time] 255[Pointer], 255[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 255;
endcode
runtime noerror

$overflow on
code auto:4654 mod[Pointer] 255[Pointer], 255[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4655 mod[compile-time] 255[Pointer], 255[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4656 mod[Pointer] 255[Pointer], 32767[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4657 mod[compile-time] 255[Pointer], 32767[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4658 mod[Pointer] 255[Pointer], 32767[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 255

code auto:4659 mod[compile-time] 255[Pointer], 32767[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow off
code auto:4660 mod[Pointer] 255[Pointer], 32768[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 32768;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4661 mod[compile-time] 255[Pointer], 32768[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4662 mod[Pointer] 255[Pointer], 32768[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 255

code auto:4663 mod[compile-time] 255[Pointer], 32768[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 32768;
endcode
varvalue r 255

$overflow off
code auto:4664 mod[Pointer] 255[Pointer], 65535[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 65535;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4665 mod[compile-time] 255[Pointer], 65535[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 255 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4666 mod[Pointer] 255[Pointer], 65535[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 255

code auto:4667 mod[compile-time] 255[Pointer], 65535[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 255 mod 65535;
endcode
varvalue r 255

$overflow off
code auto:4668 mod[Pointer] 32767[Pointer], 0[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4669 mod[compile-time] 32767[Pointer], 0[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:4670 mod[Pointer] 32767[Pointer], 0[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4671 mod[compile-time] 32767[Pointer], 0[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 0;
endcode
compile error

$overflow off
code auto:4672 mod[Pointer] 32767[Pointer], 255[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4673 mod[compile-time] 32767[Pointer], 255[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32767 mod 255;
endcode
runtime noerror

$overflow on
code auto:4674 mod[Pointer] 32767[Pointer], 255[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 127

code auto:4675 mod[compile-time] 32767[Pointer], 255[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow off
code auto:4676 mod[Pointer] 32767[Pointer], 32767[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4677 mod[compile-time] 32767[Pointer], 32767[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4678 mod[Pointer] 32767[Pointer], 32767[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4679 mod[compile-time] 32767[Pointer], 32767[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4680 mod[Pointer] 32767[Pointer], 32768[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 32768;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4681 mod[compile-time] 32767[Pointer], 32768[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32767 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4682 mod[Pointer] 32767[Pointer], 32768[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 32767

code auto:4683 mod[compile-time] 32767[Pointer], 32768[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 32768;
endcode
varvalue r 32767

$overflow off
code auto:4684 mod[Pointer] 32767[Pointer], 65535[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 65535;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4685 mod[compile-time] 32767[Pointer], 65535[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32767 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4686 mod[Pointer] 32767[Pointer], 65535[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 32767

code auto:4687 mod[compile-time] 32767[Pointer], 65535[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32767 mod 65535;
endcode
varvalue r 32767

$overflow off
code auto:4688 mod[Pointer] 32768[Pointer], 0[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4689 mod[compile-time] 32768[Pointer], 0[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:4690 mod[Pointer] 32768[Pointer], 0[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4691 mod[compile-time] 32768[Pointer], 0[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 0;
endcode
compile error

$overflow off
code auto:4692 mod[Pointer] 32768[Pointer], 255[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4693 mod[compile-time] 32768[Pointer], 255[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32768 mod 255;
endcode
runtime noerror

$overflow on
code auto:4694 mod[Pointer] 32768[Pointer], 255[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 128

code auto:4695 mod[compile-time] 32768[Pointer], 255[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 255;
endcode
varvalue r 128

$overflow off
code auto:4696 mod[Pointer] 32768[Pointer], 32767[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4697 mod[compile-time] 32768[Pointer], 32767[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32768 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4698 mod[Pointer] 32768[Pointer], 32767[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:4699 mod[compile-time] 32768[Pointer], 32767[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4700 mod[Pointer] 32768[Pointer], 32768[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 32768;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4701 mod[compile-time] 32768[Pointer], 32768[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32768 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4702 mod[Pointer] 32768[Pointer], 32768[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4703 mod[compile-time] 32768[Pointer], 32768[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4704 mod[Pointer] 32768[Pointer], 65535[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 65535;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4705 mod[compile-time] 32768[Pointer], 65535[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 32768 mod 65535;
endcode
compile error

$overflow on
code auto:4706 mod[Pointer] 32768[Pointer], 65535[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 65535;
  var  r: Integer;
  r := a mod b;
endcode
runtime overflow

code auto:4707 mod[compile-time] 32768[Pointer], 65535[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 32768 mod 65535;
endcode
compile error

$overflow off
code auto:4708 mod[Pointer] 65535[Pointer], 0[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4709 mod[compile-time] 65535[Pointer], 0[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:4710 mod[Pointer] 65535[Pointer], 0[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 0;
  var  r: Integer;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4711 mod[compile-time] 65535[Pointer], 0[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 0;
endcode
compile error

$overflow off
code auto:4712 mod[Pointer] 65535[Pointer], 255[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 255;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4713 mod[compile-time] 65535[Pointer], 255[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 65535 mod 255;
endcode
runtime noerror

$overflow on
code auto:4714 mod[Pointer] 65535[Pointer], 255[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 255;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4715 mod[compile-time] 65535[Pointer], 255[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4716 mod[Pointer] 65535[Pointer], 32767[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4717 mod[compile-time] 65535[Pointer], 32767[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 65535 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4718 mod[Pointer] 65535[Pointer], 32767[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 32767;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 1

code auto:4719 mod[compile-time] 65535[Pointer], 32767[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4720 mod[Pointer] 65535[Pointer], 32768[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 32768;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4721 mod[compile-time] 65535[Pointer], 32768[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 65535 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4722 mod[Pointer] 65535[Pointer], 32768[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 32768;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 32767

code auto:4723 mod[compile-time] 65535[Pointer], 32768[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 32768;
endcode
varvalue r 32767

$overflow off
code auto:4724 mod[Pointer] 65535[Pointer], 65535[Pointer] -> [Integer] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 65535;
  var  r: Integer;
  r := a mod b;
endcode
runtime noerror

code auto:4725 mod[compile-time] 65535[Pointer], 65535[Pointer] -> [Integer] Both immediate $overflow off
  var  r: Integer;
  r := 65535 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4726 mod[Pointer] 65535[Pointer], 65535[Pointer] -> [Integer] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 65535;
  var  r: Integer;
  r := a mod b;
endcode
varvalue r 0

code auto:4727 mod[compile-time] 65535[Pointer], 65535[Pointer] -> [Integer] Both immediate $overflow on
  var  r: Integer;
  r := 65535 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4728 mod[Pointer] 0[Pointer], 0[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4729 mod[compile-time] 0[Pointer], 0[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:4730 mod[Pointer] 0[Pointer], 0[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4731 mod[compile-time] 0[Pointer], 0[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:4732 mod[Pointer] 0[Pointer], 255[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 255;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4733 mod[compile-time] 0[Pointer], 255[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 255;
endcode
runtime noerror

$overflow on
code auto:4734 mod[Pointer] 0[Pointer], 255[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4735 mod[compile-time] 0[Pointer], 255[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4736 mod[Pointer] 0[Pointer], 32767[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4737 mod[compile-time] 0[Pointer], 32767[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4738 mod[Pointer] 0[Pointer], 32767[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4739 mod[compile-time] 0[Pointer], 32767[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4740 mod[Pointer] 0[Pointer], 32768[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4741 mod[compile-time] 0[Pointer], 32768[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4742 mod[Pointer] 0[Pointer], 32768[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 32768;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4743 mod[compile-time] 0[Pointer], 32768[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4744 mod[Pointer] 0[Pointer], 65535[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4745 mod[compile-time] 0[Pointer], 65535[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 0 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4746 mod[Pointer] 0[Pointer], 65535[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 65535;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4747 mod[compile-time] 0[Pointer], 65535[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4748 mod[Pointer] 255[Pointer], 0[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4749 mod[compile-time] 255[Pointer], 0[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:4750 mod[Pointer] 255[Pointer], 0[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4751 mod[compile-time] 255[Pointer], 0[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 0;
endcode
compile error

$overflow off
code auto:4752 mod[Pointer] 255[Pointer], 255[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 255;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4753 mod[compile-time] 255[Pointer], 255[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 255 mod 255;
endcode
runtime noerror

$overflow on
code auto:4754 mod[Pointer] 255[Pointer], 255[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4755 mod[compile-time] 255[Pointer], 255[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4756 mod[Pointer] 255[Pointer], 32767[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4757 mod[compile-time] 255[Pointer], 32767[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 255 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4758 mod[Pointer] 255[Pointer], 32767[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 255

code auto:4759 mod[compile-time] 255[Pointer], 32767[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow off
code auto:4760 mod[Pointer] 255[Pointer], 32768[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4761 mod[compile-time] 255[Pointer], 32768[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 255 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4762 mod[Pointer] 255[Pointer], 32768[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 32768;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 255

code auto:4763 mod[compile-time] 255[Pointer], 32768[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 32768;
endcode
varvalue r 255

$overflow off
code auto:4764 mod[Pointer] 255[Pointer], 65535[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4765 mod[compile-time] 255[Pointer], 65535[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 255 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4766 mod[Pointer] 255[Pointer], 65535[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 65535;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 255

code auto:4767 mod[compile-time] 255[Pointer], 65535[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 255 mod 65535;
endcode
varvalue r 255

$overflow off
code auto:4768 mod[Pointer] 32767[Pointer], 0[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4769 mod[compile-time] 32767[Pointer], 0[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:4770 mod[Pointer] 32767[Pointer], 0[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4771 mod[compile-time] 32767[Pointer], 0[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 0;
endcode
compile error

$overflow off
code auto:4772 mod[Pointer] 32767[Pointer], 255[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 255;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4773 mod[compile-time] 32767[Pointer], 255[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 255;
endcode
runtime noerror

$overflow on
code auto:4774 mod[Pointer] 32767[Pointer], 255[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 127

code auto:4775 mod[compile-time] 32767[Pointer], 255[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow off
code auto:4776 mod[Pointer] 32767[Pointer], 32767[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4777 mod[compile-time] 32767[Pointer], 32767[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4778 mod[Pointer] 32767[Pointer], 32767[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4779 mod[compile-time] 32767[Pointer], 32767[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4780 mod[Pointer] 32767[Pointer], 32768[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4781 mod[compile-time] 32767[Pointer], 32768[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 32768;
endcode
compile error

$overflow on
code auto:4782 mod[Pointer] 32767[Pointer], 32768[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:4783 mod[compile-time] 32767[Pointer], 32768[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 32768;
endcode
compile error

$overflow off
code auto:4784 mod[Pointer] 32767[Pointer], 65535[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4785 mod[compile-time] 32767[Pointer], 65535[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32767 mod 65535;
endcode
compile error

$overflow on
code auto:4786 mod[Pointer] 32767[Pointer], 65535[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:4787 mod[compile-time] 32767[Pointer], 65535[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32767 mod 65535;
endcode
compile error

$overflow off
code auto:4788 mod[Pointer] 32768[Pointer], 0[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4789 mod[compile-time] 32768[Pointer], 0[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:4790 mod[Pointer] 32768[Pointer], 0[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4791 mod[compile-time] 32768[Pointer], 0[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32768 mod 0;
endcode
compile error

$overflow off
code auto:4792 mod[Pointer] 32768[Pointer], 255[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 255;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4793 mod[compile-time] 32768[Pointer], 255[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32768 mod 255;
endcode
runtime noerror

$overflow on
code auto:4794 mod[Pointer] 32768[Pointer], 255[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 128

code auto:4795 mod[compile-time] 32768[Pointer], 255[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32768 mod 255;
endcode
varvalue r 128

$overflow off
code auto:4796 mod[Pointer] 32768[Pointer], 32767[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4797 mod[compile-time] 32768[Pointer], 32767[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32768 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4798 mod[Pointer] 32768[Pointer], 32767[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:4799 mod[compile-time] 32768[Pointer], 32767[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4800 mod[Pointer] 32768[Pointer], 32768[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4801 mod[compile-time] 32768[Pointer], 32768[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32768 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4802 mod[Pointer] 32768[Pointer], 32768[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 32768;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4803 mod[compile-time] 32768[Pointer], 32768[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32768 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4804 mod[Pointer] 32768[Pointer], 65535[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4805 mod[compile-time] 32768[Pointer], 65535[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 32768 mod 65535;
endcode
compile error

$overflow on
code auto:4806 mod[Pointer] 32768[Pointer], 65535[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:4807 mod[compile-time] 32768[Pointer], 65535[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 32768 mod 65535;
endcode
compile error

$overflow off
code auto:4808 mod[Pointer] 65535[Pointer], 0[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4809 mod[compile-time] 65535[Pointer], 0[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:4810 mod[Pointer] 65535[Pointer], 0[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 0;
  var  r: Byte;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4811 mod[compile-time] 65535[Pointer], 0[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 65535 mod 0;
endcode
compile error

$overflow off
code auto:4812 mod[Pointer] 65535[Pointer], 255[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 255;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4813 mod[compile-time] 65535[Pointer], 255[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 65535 mod 255;
endcode
runtime noerror

$overflow on
code auto:4814 mod[Pointer] 65535[Pointer], 255[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 255;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4815 mod[compile-time] 65535[Pointer], 255[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4816 mod[Pointer] 65535[Pointer], 32767[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4817 mod[compile-time] 65535[Pointer], 32767[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 65535 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4818 mod[Pointer] 65535[Pointer], 32767[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 32767;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 1

code auto:4819 mod[compile-time] 65535[Pointer], 32767[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4820 mod[Pointer] 65535[Pointer], 32768[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4821 mod[compile-time] 65535[Pointer], 32768[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 65535 mod 32768;
endcode
compile error

$overflow on
code auto:4822 mod[Pointer] 65535[Pointer], 32768[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 32768;
  var  r: Byte;
  r := a mod b;
endcode
runtime overflow

code auto:4823 mod[compile-time] 65535[Pointer], 32768[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 65535 mod 32768;
endcode
compile error

$overflow off
code auto:4824 mod[Pointer] 65535[Pointer], 65535[Pointer] -> [Byte] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 65535;
  var  r: Byte;
  r := a mod b;
endcode
runtime noerror

code auto:4825 mod[compile-time] 65535[Pointer], 65535[Pointer] -> [Byte] Both immediate $overflow off
  var  r: Byte;
  r := 65535 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4826 mod[Pointer] 65535[Pointer], 65535[Pointer] -> [Byte] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 65535;
  var  r: Byte;
  r := a mod b;
endcode
varvalue r 0

code auto:4827 mod[compile-time] 65535[Pointer], 65535[Pointer] -> [Byte] Both immediate $overflow on
  var  r: Byte;
  r := 65535 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4828 mod[Pointer] 0[Pointer], 0[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4829 mod[compile-time] 0[Pointer], 0[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 0;
endcode
compile error

$overflow on
code auto:4830 mod[Pointer] 0[Pointer], 0[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4831 mod[compile-time] 0[Pointer], 0[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 0;
endcode
compile error

$overflow off
code auto:4832 mod[Pointer] 0[Pointer], 255[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 255;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4833 mod[compile-time] 0[Pointer], 255[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 255;
endcode
runtime noerror

$overflow on
code auto:4834 mod[Pointer] 0[Pointer], 255[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4835 mod[compile-time] 0[Pointer], 255[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4836 mod[Pointer] 0[Pointer], 32767[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4837 mod[compile-time] 0[Pointer], 32767[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4838 mod[Pointer] 0[Pointer], 32767[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4839 mod[compile-time] 0[Pointer], 32767[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4840 mod[Pointer] 0[Pointer], 32768[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4841 mod[compile-time] 0[Pointer], 32768[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4842 mod[Pointer] 0[Pointer], 32768[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4843 mod[compile-time] 0[Pointer], 32768[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4844 mod[Pointer] 0[Pointer], 65535[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 0;
  var  b: Pointer = 65535;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4845 mod[compile-time] 0[Pointer], 65535[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 0 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4846 mod[Pointer] 0[Pointer], 65535[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 0;
  var  b: Pointer = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4847 mod[compile-time] 0[Pointer], 65535[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 0 mod 65535;
endcode
varvalue r 0

$overflow off
code auto:4848 mod[Pointer] 255[Pointer], 0[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4849 mod[compile-time] 255[Pointer], 0[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 255 mod 0;
endcode
compile error

$overflow on
code auto:4850 mod[Pointer] 255[Pointer], 0[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4851 mod[compile-time] 255[Pointer], 0[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 0;
endcode
compile error

$overflow off
code auto:4852 mod[Pointer] 255[Pointer], 255[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 255;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4853 mod[compile-time] 255[Pointer], 255[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 255 mod 255;
endcode
runtime noerror

$overflow on
code auto:4854 mod[Pointer] 255[Pointer], 255[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4855 mod[compile-time] 255[Pointer], 255[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4856 mod[Pointer] 255[Pointer], 32767[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4857 mod[compile-time] 255[Pointer], 32767[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 255 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4858 mod[Pointer] 255[Pointer], 32767[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 255

code auto:4859 mod[compile-time] 255[Pointer], 32767[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 32767;
endcode
varvalue r 255

$overflow off
code auto:4860 mod[Pointer] 255[Pointer], 32768[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4861 mod[compile-time] 255[Pointer], 32768[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 255 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4862 mod[Pointer] 255[Pointer], 32768[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 255

code auto:4863 mod[compile-time] 255[Pointer], 32768[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 32768;
endcode
varvalue r 255

$overflow off
code auto:4864 mod[Pointer] 255[Pointer], 65535[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 255;
  var  b: Pointer = 65535;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4865 mod[compile-time] 255[Pointer], 65535[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 255 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4866 mod[Pointer] 255[Pointer], 65535[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 255;
  var  b: Pointer = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 255

code auto:4867 mod[compile-time] 255[Pointer], 65535[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 255 mod 65535;
endcode
varvalue r 255

$overflow off
code auto:4868 mod[Pointer] 32767[Pointer], 0[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4869 mod[compile-time] 32767[Pointer], 0[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod 0;
endcode
compile error

$overflow on
code auto:4870 mod[Pointer] 32767[Pointer], 0[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4871 mod[compile-time] 32767[Pointer], 0[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 0;
endcode
compile error

$overflow off
code auto:4872 mod[Pointer] 32767[Pointer], 255[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 255;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4873 mod[compile-time] 32767[Pointer], 255[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod 255;
endcode
runtime noerror

$overflow on
code auto:4874 mod[Pointer] 32767[Pointer], 255[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 127

code auto:4875 mod[compile-time] 32767[Pointer], 255[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 255;
endcode
varvalue r 127

$overflow off
code auto:4876 mod[Pointer] 32767[Pointer], 32767[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4877 mod[compile-time] 32767[Pointer], 32767[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4878 mod[Pointer] 32767[Pointer], 32767[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4879 mod[compile-time] 32767[Pointer], 32767[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 32767;
endcode
varvalue r 0

$overflow off
code auto:4880 mod[Pointer] 32767[Pointer], 32768[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4881 mod[compile-time] 32767[Pointer], 32768[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4882 mod[Pointer] 32767[Pointer], 32768[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32767

code auto:4883 mod[compile-time] 32767[Pointer], 32768[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 32768;
endcode
varvalue r 32767

$overflow off
code auto:4884 mod[Pointer] 32767[Pointer], 65535[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 32767;
  var  b: Pointer = 65535;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4885 mod[compile-time] 32767[Pointer], 65535[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32767 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4886 mod[Pointer] 32767[Pointer], 65535[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 32767;
  var  b: Pointer = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32767

code auto:4887 mod[compile-time] 32767[Pointer], 65535[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32767 mod 65535;
endcode
varvalue r 32767

$overflow off
code auto:4888 mod[Pointer] 32768[Pointer], 0[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4889 mod[compile-time] 32768[Pointer], 0[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32768 mod 0;
endcode
compile error

$overflow on
code auto:4890 mod[Pointer] 32768[Pointer], 0[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4891 mod[compile-time] 32768[Pointer], 0[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 0;
endcode
compile error

$overflow off
code auto:4892 mod[Pointer] 32768[Pointer], 255[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 255;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4893 mod[compile-time] 32768[Pointer], 255[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32768 mod 255;
endcode
runtime noerror

$overflow on
code auto:4894 mod[Pointer] 32768[Pointer], 255[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 128

code auto:4895 mod[compile-time] 32768[Pointer], 255[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 255;
endcode
varvalue r 128

$overflow off
code auto:4896 mod[Pointer] 32768[Pointer], 32767[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4897 mod[compile-time] 32768[Pointer], 32767[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32768 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4898 mod[Pointer] 32768[Pointer], 32767[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:4899 mod[compile-time] 32768[Pointer], 32767[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4900 mod[Pointer] 32768[Pointer], 32768[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4901 mod[compile-time] 32768[Pointer], 32768[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32768 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4902 mod[Pointer] 32768[Pointer], 32768[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4903 mod[compile-time] 32768[Pointer], 32768[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 32768;
endcode
varvalue r 0

$overflow off
code auto:4904 mod[Pointer] 32768[Pointer], 65535[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 32768;
  var  b: Pointer = 65535;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4905 mod[compile-time] 32768[Pointer], 65535[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 32768 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4906 mod[Pointer] 32768[Pointer], 65535[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 32768;
  var  b: Pointer = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32768

code auto:4907 mod[compile-time] 32768[Pointer], 65535[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 32768 mod 65535;
endcode
varvalue r 32768

$overflow off
code auto:4908 mod[Pointer] 65535[Pointer], 0[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4909 mod[compile-time] 65535[Pointer], 0[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 65535 mod 0;
endcode
compile error

$overflow on
code auto:4910 mod[Pointer] 65535[Pointer], 0[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 0;
  var  r: Word;
  r := a mod b;
endcode
runtime dividebyzero

code auto:4911 mod[compile-time] 65535[Pointer], 0[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 0;
endcode
compile error

$overflow off
code auto:4912 mod[Pointer] 65535[Pointer], 255[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 255;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4913 mod[compile-time] 65535[Pointer], 255[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 65535 mod 255;
endcode
runtime noerror

$overflow on
code auto:4914 mod[Pointer] 65535[Pointer], 255[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 255;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4915 mod[compile-time] 65535[Pointer], 255[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 255;
endcode
varvalue r 0

$overflow off
code auto:4916 mod[Pointer] 65535[Pointer], 32767[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 32767;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4917 mod[compile-time] 65535[Pointer], 32767[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 65535 mod 32767;
endcode
runtime noerror

$overflow on
code auto:4918 mod[Pointer] 65535[Pointer], 32767[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 32767;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 1

code auto:4919 mod[compile-time] 65535[Pointer], 32767[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 32767;
endcode
varvalue r 1

$overflow off
code auto:4920 mod[Pointer] 65535[Pointer], 32768[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 32768;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4921 mod[compile-time] 65535[Pointer], 32768[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 65535 mod 32768;
endcode
runtime noerror

$overflow on
code auto:4922 mod[Pointer] 65535[Pointer], 32768[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 32768;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 32767

code auto:4923 mod[compile-time] 65535[Pointer], 32768[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 32768;
endcode
varvalue r 32767

$overflow off
code auto:4924 mod[Pointer] 65535[Pointer], 65535[Pointer] -> [Word] Var $overflow off
  var  a: Pointer = 65535;
  var  b: Pointer = 65535;
  var  r: Word;
  r := a mod b;
endcode
runtime noerror

code auto:4925 mod[compile-time] 65535[Pointer], 65535[Pointer] -> [Word] Both immediate $overflow off
  var  r: Word;
  r := 65535 mod 65535;
endcode
runtime noerror

$overflow on
code auto:4926 mod[Pointer] 65535[Pointer], 65535[Pointer] -> [Word] Var $overflow on
  var  a: Pointer = 65535;
  var  b: Pointer = 65535;
  var  r: Word;
  r := a mod b;
endcode
varvalue r 0

code auto:4927 mod[compile-time] 65535[Pointer], 65535[Pointer] -> [Word] Both immediate $overflow on
  var  r: Word;
  r := 65535 mod 65535;
endcode
varvalue r 0

