;Arrays and Strings and Lists;============================;=============== ARRAY DECLARATIONS;Note: It's not easy to self test that the array data structures have been set ;up correctly, so these tests are really just testing the syntax(es) parse ;correctly. The execution tests should find any deeper flaws.code Array Single  type Basic = array[0..10] of Byteendcodecompile noerrorcode Array Double  type Basic = array[0..10, 11..20] of Byteendcodecompile noerrorcode Array Triple  type Basic = array[0..10, 11..20, 21..30] of Byteendcodecompile noerrorcode Array Alternate Double  type Basic = array[0..10][11..20] of Byteendcodecompile noerrorcode Array Another Alternate Double  type Basic = array[0..10] of array [11..20] of Byteendcodecompile noerrorcode Array Unbounded  type Basic = array of Byteendcodecompile noerrorcode Array Various Variants  type A=array of Byte  type B=array[1..10] of Byte  type C=array[1..10,11..20] of Byte  type D=array[1..10][11..20] of Byte  type E=array[Char] of Integer  type F=array[(Red, White, Blue)] of 'a'..'z'  type G=array[1..5] of array [1..5] of Boolean  const Start=1  const Finish=10  type H=array[Start+1..2*Finish] of Byteendcodecompile noerrorcode Array Whitespace  type A= array of Byte  type B=array [1..10] of Byte  type C=array[ 1..10,11.. 20] of Byte  type D=array[1..10] [11..20]    of Byteendcodecompile noerrorcode Array Linebreaks A  type A1=    array of Byte  type A2=array     of Byte  type A3=array of     Byteendcodecompile noerrorcode Array Invalid Line Break A  type B4=array[1    ..10] of Byteendcodecompile RangeOperatorExpectedcode Array Linebreaks B  type B1=array    [1..10] of Byte  type B2=array[    1..10] of Byte  type B3=array[1..    10] of Byte  type B5=array[1..10    ] of Byte  type B7=array[1..10] of     Byteendcodecompile noerrorcode Array No ]  type B1=array[1..10 of Byteendcodecompile ArrayBoundsDefinitioncode Array Invalid Line Break B  type B6=array[1..10]     of Byteendcodecompile OFExpected	code Array Linebreaks C  type C1=array[1..10    ,11..20] of Byte  type C2=array[1..10,    11..20] of Byteendcodecompile noerror	code Array Invalid Line Break D  type D=array[1..10]    [11..20] of Byteendcodecompile OFExpectedcode Array Invalid Type  type Basic = array[String] of Byteendcodecompile OrdinalTypeExpected;======================= LIST DECLARATIONScode List Unsized  type A=list of Byteendcodecompile noerrorcode List Sized  type B=list[10] of Byteendcodecompile noerrorcode List Spacing  type B=list [ 10 ] of Byteendcodecompile noerrorcode List Unsized Line Breaks  type A1=    list of Byte  type A3=list of     Byteendcodecompile noerrorcode List Unsized Line Break Error  type A2=list    of Byteendcodecompile noerrorcode List Sized Line Breaks  type B1=list[    10] of Byte  type B2=list[10    ] of Byteendcodecompile noerrorcode List Sized Line Break Error  type B=list    [10] of Byteendcodecompile noerrorcode List Sized Line Breaks  type B=list[10]     of Byteendcodecompile OFExpectedcode List Invalid Capacity 1  type B=list[0] of Byteendcodecompile ListCapacityErrorcode List Invalid Capacity 2  type B=list[-100] of Byteendcodecompile ListCapacityErrorcode List Invalid Capacity 3  type B=list[False] of Byteendcodecompile ListCapacityErrorcode List unbounded to bounded 1  type TA = list of Integer  type TB = TA[10]endcodecompile noerrorcode List unbounded to bounded 2  type TA = list of Integer  var A: TA[10]endcodecompile noerror;====================== INSTANTIATE VARIABLEScode Inst Simple Array Typed  type TA = array[0..10] of Integer  var A: TAendcodecompile noerrorcode Inst Simple Array Inline  var A: array[0..10] of Integerendcodecompile noerrorcode Inst Multi Array Typed  type TA = array[0..10,0..10] of Integer  var A: TAendcodecompile noerrorcode Inst Multi Array Inline  var A: array[0..10,0..10] of Integerendcodecompile noerrorcode Inst Long Simple Array Typed  type TA = array[0..300] of Integer  var A: TAendcodecompile noerrorcode Inst Long Simple Array Inline  var A: array[0..300] of Integerendcodecompile noerrorcode Inst Long Multi Array Typed  type TA = array[0..300,0..300] of Byte  var A: TAendcodecompile noerrorcode Inst Long Multi Array Inline  var A: array[0..300,0..300] of Integerendcodecompile noerrorcode Inst Char Inline  var A: array['A'..'Z'] of Integerendcodecompile noerrorcode Inst Enumeration Inline  type TColour = (Red, Green, Blue)  var A: array[Red..Blue] of Integerendcodecompile noerrorcode Inst Unbounded Array Typed  type TA = array of Integer  var A: TAendcodecompile InstantiateUnboundedArraycode Inst Unbounded Array Inline  var A: array of Integerendcodecompile InstantiateUnboundedArraycode Inst Short List Typed  type TA = list[10] of Integer  var A: TAendcodecompile noerrorcode Inst Short List Inline  var A: list[10] of Integerendcodecompile noerrorcode Inst Long List Typed  type TA = list[300] of Integer  var A: TAendcodecompile noerrorcode Inst Long List Inline  var A: list[300] of Integerendcodecompile noerrorcode Inst Unbounded List Typed  type TA = list of Integer  var A: TAendcodecompile InstantiateUnboundedArraycode Inst Unbounded List Inline  var A: list of Integerendcodecompile InstantiateUnboundedArray;===========================SUPPORT FUNCTIONS;---AddrOfcode AddrOf Array  var A: array[0..500] of Integer  A[0] := $21  var P: Pointer  P := @A  var B := P^endcodevarvalue B $21code AddrOf Array Register  program  function f: Byte;register;  begin    var A: array[0..500] of Integer    A[0] := $21    var P: Pointer    P := @A    Result := P^  end  var B: Byte  begin    B := F;  end.endcodevarvalue B $21code AddrOf Array Stack  program  function f: Byte;stack;  begin    var A: array[0..500] of Integer    A[0] := $21    var P: Pointer    P := @A    Result := P^  end  var B: Byte  begin    B := F;  end.endcodevarvalue B $21code AddrOf Short Vector  var A: Short Vector[10] of Integer  A[0] := $42  var P: Pointer  P := @A  inc(P)  var B := P^endcodevarvalue B $42code AddrOf Short Vector Register  program  function f: Byte;register;  begin    var A: Short Vector[10] of Integer    A[0] := $42    var P: Pointer    P := @A    inc(P)    Result := P^  end  var B: Byte  begin    B := F;  end.endcodevarvalue B $42code AddrOf Short Vector Stack  program  function f: Byte;stack;  begin    var A: Short Vector[10] of Integer    A[0] := $42    var P: Pointer    P := @A    inc(P)    Result := P^  end  var B: Byte  begin    B := F;  end.endcodevarvalue B $42code AddrOf Long Vector  var A: Long Vector[10] of Integer  A[0] := $84  var P: Pointer  P := @A  P := P + 2  var B := P^endcodevarvalue B $84code AddrOf Long Vector Register  program  function f: Byte;register;  begin    var A: Long Vector[10] of Integer    A[0] := $84    var P: Pointer    P := @A    P := P + 2    Result := P^  end  var B: Byte  begin    B := F  end.endcodevarvalue B $84code AddrOf Long Vector Stack  program  function f: Byte;stack;  begin    var A: Long Vector[10] of Integer    A[0] := $84    var P: Pointer    P := @A    P := P + 2    Result := P^  end  var B: Byte  begin    B := F  end.endcodevarvalue B $84code AddrOf Short List  var A: Short List[10] of Integer  SetLength(A, 1)  A[0] := $a8  var P: Pointer  P := @A  P := P + 2  var B := P^endcodevarvalue B $a8code AddrOf Short List Register  program  function f: Byte;register;  begin    var A: Short List[10] of Integer    SetLength(A, 1)    A[0] := $a8    var P: Pointer    P := @A    P := P + 2    Result := P^  end  var B: Byte  begin    B := F  end.endcodevarvalue B $a8code AddrOf Short List Stack  program  function f: Byte;stack;  begin    var A: Short List[10] of Integer    SetLength(A, 1)    A[0] := $a8    var P: Pointer    P := @A    P := P + 2    Result := P^  end  var B: Byte  begin    B := F  end.endcodevarvalue B $a8code AddrOf Long List  var A: Long List[10] of Integer  SetLength(A, 1)  A[0] := $ca  var P: Pointer  P := @A  P := P + 4  var B := P^endcodevarvalue B $cacode AddrOf Long List Register  program  function f: Byte;register;  begin    var A: Long List[10] of Integer    SetLength(A, 1)    A[0] := $ca    var P: Pointer    P := @A    P := P + 4    Result := P^  end  var B: Byte  begin    B := F;  end.endcodevarvalue B $cacode AddrOf Long List Stack  program  function f: Byte;stack;  begin    var A: Long List[10] of Integer    SetLength(A, 1)    A[0] := $ca    var P: Pointer    P := @A    P := P + 4    Result := P^  end  var B: Byte  begin    B := F;  end.endcodevarvalue B $cacode AddrOf String Literal CONST  const S = 'Hello World!'  var P: Pointer  P := @S  var Len := P^endcodevarvalue Len 12code AddrOf String Literal Immediate  var P :Pointer  P := @'Hello World!'  var Len := P^endcodevarvalue Len 12;--- Capacitycode Capacity  type TSL= list[10] of Word  var SL: TSL  var SSL := capacity(SL)  type TLL= List[300] of Char  var LL: TLL  var SLL := capacity(LL)endcodevarvalue SSL 10varvalue SLL 300code Capacity Register  program  var SSL: Integer  var SLL: Integer    procedure p;register;  type TSL= list[10] of Word  type TLL= List[300] of Char  begin    var SL: TSL    SSL := capacity(SL)    var LL: TLL    SLL := capacity(LL)  end    begin    p  end.endcodevarvalue SSL 10varvalue SLL 300code Capacity Stack  program  var SSL: Integer  var SLL: Integer    procedure p;stack;  type TSL= list[10] of Word  type TLL= List[300] of Char  begin    var SL: TSL    SSL := capacity(SL)    var LL: TLL    SLL := capacity(LL)  end    begin    p  end.endcodevarvalue SSL 10varvalue SLL 300code Capacity Unbounded Short List  function F(const V: Short List of Byte): Byte  begin    Result := Capacity(V)  end  type TVA = Short List[10] of Byte  type TVB = Short List[100] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 10varvalue LB 100code Capacity Unbounded Long List  function F(const V: Long List of Byte): Word  begin    Result := Capacity(V)  end  type TVA = Long List[300] of Byte  type TVB = Long List[400] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 300varvalue LB 400code Capacity String Literal Error  const S = 'Hello World!'  var Cap := Capacity(S)endcodecompile TypeMismatchcode Capacity String Literal Error  var Cap := Capacity('Hello World!')endcodecompile TypeMismatch;--- Highcode High Array  type TA= array[-5..10] of Byte  var ATA := high(TA)  var A: array[0..10] of Integer  var AH := high(A)  var B: array[100..101] of Integer  var BH := high(B)  var C: array[1000..1010] of Integer  var CH := high(C)  var D: array[-10..-5] of Integer  var DH := high(D)  var E: array[-1000..-900] of Integer  var EH := high(E)  var F: array['A'..'Z'] of Integer  var FH := high(F)  type TColour = (Red, Green, Blue)  var G: array[Red..Blue] of Integer  var GH := high(G)  var H: array[TColour] of Integer  var HH := high(H)endcodevarvalue ATA 10varvalue AH 10varvalue BH 101varvalue CH 1010varvalue DH -5varvalue EH -900varvalue FH 'Z'varvalue GH Bluevarvalue HH Bluecode High Vector, List  var SV: vector[10] of Byte  var SVH := high(SV)  var LV: vector[300] of Byte  var LVH := high(LV)  var SL: list[10] of Byte  var SLH := high(SL)  var LL: List[300] of Byte  var LLH := high(LL)endcodevarvalue SVH 9varvalue LVH 299varvalue SLH -1varvalue LLH -1code High List Register  program    var SLH: Integer    var LLH: Integer	  procedure p;register;  begin    var SL: list[10] of Byte    SLH := high(SL)    var LL: List[300] of Byte    LLH := high(LL)  end    begin    p  end.endcodevarvalue SLH -1varvalue LLH -1code High List Stack  program    var SLH: Integer    var LLH: Integer	  procedure p;stack;  begin    var SL: list[10] of Byte    SLH := high(SL)    var LL: List[300] of Byte    LLH := high(LL)  end    begin    p  end.endcodevarvalue SLH -1varvalue LLH -1;We can't determine High() of a list type at compile time so an error is expectedcode High Short List Type Error  type TSL = Short List[10] of Byte  var SLH := high(TSL)endcodecompile TypeMismatch;We can't determine High() of a list type at compile time so an error is expectedcode High Long List Type Error  type TLL = Long List[300] of Byte  var LLH := high(TLL)endcodecompile TypeMismatchcode High Unbounded Short Vector  function F(const V: Short Vector of Byte): Integer  begin    Result := High(V)  end  type TVA = Short Vector[10] of Byte  type TVB = Short Vector[100] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 9varvalue LB 99code High Unbounded Long Vector  function F(const V: Long Vector of Byte): Word  begin    Result := High(V)  end  type TVA = Long Vector[300] of Byte  type TVB = Long Vector[400] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 299varvalue LB 399code High Unbounded Short List  function F(const V: Short List of Byte): Integer  begin    Result := High(V)  end  type TVA = Short List[10] of Byte  type TVB = Short List[100] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA -1varvalue LB -1code High Unbounded Long List  function F(const V: Long List of Byte): Integer  begin    Result := High(V)  end  type TVA = Long List[300] of Byte  type TVB = Long List[400] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA -1varvalue LB -1code High String Literal CONST  const S = 'Hello World!'  var H := High(S)endcodevarvalue H 11code High String Literal Immediate  var H := High('Hello World!')endcodevarvalue H 11;--- Lengthcode Length Array  type TA= array[0..9] of Byte  var SA := length(TA)  var A: TA  var SVA := length(A)  type TB= array[0..9] of Integer  var SB := length(TB)  var B: TB  var SVB := length(B)  type TC= array[-10..9] of Byte  var SC := length(TC)  type TD= array[-1000..-1] of Integer  var SD := length(TD)  type TE= array['A'..'Z'] of Byte  var SE := length(TE)  type TColour = (Red, Green, Blue)  type TF= array[Red..Blue] of Byte  var SF := length(TF)endcodevarvalue SA 10varvalue SVA 10varvalue SB 10varvalue SVB 10varvalue SC 20varvalue SD 1000varvalue SE 26varvalue SF 3code Length Vector and List  type TSV= vector[10] of Byte  var SSV := length(TSV)  var SV: TSV  var SSVB := length(SV)  type TLV= vector[300] of Integer  var SLV := length(TLV)  type TSL= list[10] of Word  var SL: TSL  var SSL := length(SL)  type TLL= List[300] of Char  var LL: TLL  var SLL := length(LL)endcodevarvalue SSV 10varvalue SSVB 10varvalue SLV 300varvalue SSL 0varvalue SLL 0code Length List Register  program  var SSL: Integer  var SLL: Integer    procedure p;register;  type TSL= list[10] of Word  type TLL= List[300] of Char  begin    var SL: TSL    SSL := length(SL)    var LL: TLL    SLL := length(LL)  end    begin    p  end.endcodevarvalue SSL 0varvalue SLL 0code Length List Stack  program  var SSL: Integer  var SLL: Integer    procedure p;stack;  type TSL= list[10] of Word  type TLL= List[300] of Char  begin    var SL: TSL    SSL := length(SL)    var LL: TLL    SLL := length(LL)  end    begin    p  end.endcodevarvalue SSL 0varvalue SLL 0;Length of a list cannot be determined at compile time so an error must be generatedcode Length Short List Type Error  type TSL = Short List[10] of Byte  var SLL := length(TSL)endcodecompile TypeMismatchcode Length Long List Type Error  type TLL = Long List[300] of Byte  var LLL := length(TLL)endcodecompile TypeMismatchcode Length Unbounded Short Vector  function F(const V: Short Vector of Byte): Byte  begin    Result := Length(V)  end  type TVA = Short Vector[10] of Byte  type TVB = Short Vector[100] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 10varvalue LB 100code Length Unbounded Long Vector  function F(const V: Long Vector of Byte): Word  begin    Result := Length(V)  end  type TVA = Long Vector[300] of Byte  type TVB = Long Vector[400] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 300varvalue LB 400code Length Unbounded Short List  function F(const V: Short List of Byte): Byte  begin    Result := Length(V)  end  type TVA = Short List[10] of Byte  type TVB = Short List[100] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 0varvalue LB 0code Length Unbounded Long List  function F(const V: Long List of Byte): Word  begin    Result := Length(V)  end  type TVA = Long List[300] of Byte  type TVB = Long List[400] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 0varvalue LB 0code Length String Literal CONST  const S = 'Hello World!'  var L := Length(S)endcodevarvalue L 12code Length String Literal Immediate  var L := Length('Hello World!')endcodevarvalue L 12;--- Lowcode Low Array  type TA= array[-5..10] of Byte  var ATA := low(TA)  var A: array[0..10] of Integer  var AL := low(A)  var B: array[100..101] of Integer  var BL := low(B)  var C: array[1000..1010] of Integer  var CL := low(C)  var D: array[-10..10] of Integer  var DL := low(D)  var E: array[-1000..-900] of Integer  var EL := low(E)  var F: array['A'..'Z'] of Integer  var FL := low(F)    type TColour = (Red, Green, Blue)  var G: array[Red..Blue] of Integer  var GL := low(G)  var H: array[TColour] of Integer  var HL := low(H)endcodevarvalue ATA -5varvalue AL 0varvalue BL 100varvalue CL 1000varvalue DL -10varvalue EL -1000varvalue FL 'A'varvalue GL Redvarvalue HL Redcode Low Vector, List  var SV: vector[10] of Byte  var SVL := low(SV)  var LV: vector[300] of Byte  var LVL := low(LV)  var SL: list[10] of Byte  var SLL := low(SL)  var LL: List[300] of Byte  var LLL := low(LL)endcodevarvalue SVL 0varvalue LVL 0varvalue SLL 0varvalue LLL 0code Low Unbounded Short Vector  function F(const V: Short Vector of Byte): Byte  begin    Result := Low(V)  end  type TVA = Short Vector[10] of Byte  type TVB = Short Vector[100] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 0varvalue LB 0code Low Unbounded Long Vector  function F(const V: Long Vector of Byte): Byte  begin    Result := Low(V)  end  type TVA = Long Vector[300] of Byte  type TVB = Long Vector[400] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 0varvalue LB 0code Low Unbounded Short List  function F(const V: Short List of Byte): Byte  begin    Result := Low(V)  end  type TVA = Short List[10] of Byte  type TVB = Short List[100] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 0varvalue LB 0code Low Unbounded Long List  function F(const V: Long List of Byte): Byte  begin    Result := Low(V)  end  type TVA = Long List[300] of Byte  type TVB = Long List[400] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 0varvalue LB 0code Low String Literal CONST  const S = 'Hello World!'  var L := Low(S)endcodevarvalue L 0code Low String Literal Immediate  var L := Low('Hello World!')endcodevarvalue L 0;---SetLengthcode SetLength Short List  type TL = Short List of Integer  var A: TL[10]  SetLength(A, 1)  var LA := Length(A)  SetLength(A, 10)  var LB := Length(A)  SetLength(A, 0)  var LC := Length(A)endcodevarvalue LA 1varvalue LB 10varvalue LC 0code SetLength Short List Register  program  var LA: Integer  var LB: Integer  var LC: Integer    procedure p;register;  type TL = Short List of Integer  begin    var A: TL[10]    SetLength(A, 1)    LA := Length(A)    SetLength(A, 10)    LB := Length(A)    SetLength(A, 0)    LC := Length(A)  end    begin    p  end.endcodevarvalue LA 1varvalue LB 10varvalue LC 0code SetLength Short List Stack  program  var LA: Integer  var LB: Integer  var LC: Integer    procedure p;stack;  type TL = Short List of Integer  begin    var A: TL[10]    SetLength(A, 1)    LA := Length(A)    SetLength(A, 10)    LB := Length(A)    SetLength(A, 0)    LC := Length(A)  end    begin    p  end.endcodevarvalue LA 1varvalue LB 10varvalue LC 0code SetLength Short List Out Of Range  type TL = Short List of Integer  var A: TL[10]  SetLength(A, 11)endcoderuntime errorcode SetLength Short List Out Of Range  type TL = Short List of Integer  var A: TL[10]  SetLength(A, -1)endcodecompile ConstantAssignmentOutOfRangecode SetLength Short List No Range Check  {$R-}  type TL = Short List of Integer  var A: TL[10]  SetLength(A, 11)  var LA := Length(A)endcodevarvalue LA 11code SetLength Long List  type TL = Long List of Integer  var A: TL[1000]  SetLength(A, 1)  var LA := Length(A)  SetLength(A, 1000)  var LB := Length(A)  SetLength(A, 0)  var LC := Length(A)endcodevarvalue LA 1varvalue LB 1000varvalue LC 0code SetLength Long List Register  program    var LA: Integer	var LB: Integer	var LC: Integer	  procedure p;register;  type TL = Long List of Integer  begin    var A: TL[1000]    SetLength(A, 1)    LA := Length(A)    SetLength(A, 1000)    LB := Length(A)    SetLength(A, 0)    LC := Length(A)  end    begin    p  end.endcodevarvalue LA 1varvalue LB 1000varvalue LC 0code SetLength Long List Stack  program    var LA: Integer	var LB: Integer	var LC: Integer	  procedure p;stack;  type TL = Long List of Integer  begin    var A: TL[1000]    SetLength(A, 1)    LA := Length(A)    SetLength(A, 1000)    LB := Length(A)    SetLength(A, 0)    LC := Length(A)  end    begin    p  end.endcodevarvalue LA 1varvalue LB 1000varvalue LC 0code SetLength Long List Out Of Range  type TL = Long List of Integer  var A: TL[1000]  SetLength(A, 1001)endcoderuntime errorcode SetLength Long List Out Of Range  type TL = Long List of Integer  var A: TL[1000]  SetLength(A, -1)endcodecompile ConstantAssignmentOutOfRangecode SetLength Long List No Range Check  {$R-}  type TL = Long List of Integer  var A: TL[1000]  SetLength(A, 1001)  var LA := Length(A)endcodevarvalue LA 1001code SetLength String Literal CONST Error  const S = 'Hello World!'  SetLength(S, 3)endcodecompile ArgMustBeVariablecode SetLength String Literal Immediate Error  SetLength('Hello World!', 4)endcodecompile ArgMustBeVariable;--- Sizeofcode Array Sizeof  type TA= array[0..9] of Byte  var SA := sizeof(TA)  var A: TA  var SVA := sizeof(A)  type TB= array[0..9] of Integer  var SB := sizeof(TB)  var B: TB  var SVB := sizeof(B)  type TC= array[-10..9] of Byte  var SC := sizeof(TC)  type TD= array[-1000..-1] of Integer  var SD := sizeof(TD)  type TE= array['A'..'Z'] of Byte  var SE := sizeof(TE)  type TColour = (Red, Green, Blue)  type TF= array[Red..Blue] of Byte  var SF := sizeof(TF)endcodevarvalue SA 10varvalue SVA 10varvalue SB 20varvalue SVB 20varvalue SC 20varvalue SD 2000varvalue SE 26varvalue SF 3code Sizeof Vector and List  type TSV= short vector[10] of Byte  var SSV := sizeof(TSV)  var SV: TSV  var SSVB := sizeof(SV)  type TLV= long vector[300] of Integer  var SLV := sizeof(TLV)  type TSL= short list[10] of Word  var SSL := sizeof(TSL)  type TLL= long List[300] of Char  var SLL := sizeof(TLL)endcodevarvalue SSV 11varvalue SSVB 11varvalue SLV 602varvalue SSL 22varvalue SLL 304code Sizeof Unbounded Short Vector Of Byte  function F(const V: Short Vector of Byte): Word  begin    Result := Sizeof(V)  end  type TVA = Short Vector[10] of Byte  type TVB = Short Vector[100] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 11varvalue LB 101code Sizeof Unbounded Short Vector of Integer  function F(const V: Short Vector of Integer): Word  begin    Result := Sizeof(V)  end  type TVA = Short Vector[10] of Integer  type TVB = Short Vector[100] of Integer  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 21varvalue LB 201code Sizeof Unbounded Long Vector of Byte  function F(const V: Long Vector of Byte): Word  begin    Result := Sizeof(V)  end  type TVA = Long Vector[300] of Byte  type TVB = Long Vector[400] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 302varvalue LB 402code Sizeof Unbounded Long Vector of Integer  function F(const V: Long Vector of Integer): Word  begin    Result := Sizeof(V)  end  type TVA = Long Vector[300] of Integer  type TVB = Long Vector[400] of Integer  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 602varvalue LB 802code Sizeof Unbounded Short List of Byte  function F(const V: Short List of Byte): Word  begin    Result := Sizeof(V)  end  type TVA = Short List[10] of Byte  type TVB = Short List[100] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 12varvalue LB 102code Sizeof Unbounded Short List of Integer  function F(const V: Short List of Integer): Word  begin    Result := Sizeof(V)  end  type TVA = Short List[10] of Integer  type TVB = Short List[100] of Integer  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 22varvalue LB 202code Sizeof Unbounded Long List of Byte  function F(const V: Long List of Byte): Word  begin    Result := Sizeof(V)  end  type TVA = Long List[300] of Byte  type TVB = Long List[400] of Byte  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 304varvalue LB 404code Sizeof Unbounded Long List of Integer  function F(const V: Long List of Integer): Word  begin    Result := Sizeof(V)  end  type TVA = Long List[300] of Integer  type TVB = Long List[400] of Integer  var VA: TVA  var LA := F(VA)  var VB: TVB  var LB := F(VB)endcodevarvalue LA 604varvalue LB 804code Sizeof String Literal CONST  const Str = 'Hello World!'  var S := Sizeof(Str)endcodevarvalue S 13code Sizeof String Literal Immediate  var S := Sizeof('Hello World!')endcodevarvalue S 13;--Writecode Write String Literal  write('Hello World!')endcodeconsolelog 'Hello World!'code Write Array of Char  var S: array[10..15] of Char  S[10] := 'H'  S[11] := 'e'  S[12] := 'l'  S[13] := 'l'  S[14] := 'o'  S[15] := '!'  write Sendcodeconsolelog 'Hello!'code Write Short Vector of Char  var S: short vector[6] of Char  S[0] := 'H'  S[1] := 'e'  S[2] := 'l'  S[3] := 'l'  S[4] := 'o'  S[5] := '!'  write Sendcodeconsolelog 'Hello!'code Write Long Vector of Char  var S: long vector[6] of Char  S[0] := 'H'  S[1] := 'e'  S[2] := 'l'  S[3] := 'l'  S[4] := 'o'  S[5] := '!'  write Sendcodeconsolelog 'Hello!'code Write Short List of Char  var S: short list[10] of Char  SetLength(S, 6)  S[0] := 'H'  S[1] := 'e'  S[2] := 'l'  S[3] := 'l'  S[4] := 'o'  S[5] := '!'  write Sendcodeconsolelog 'Hello!'code Write Long List of Char  var S: long list[10] of Char  SetLength(S, 6)  S[0] := 'H'  S[1] := 'e'  S[2] := 'l'  S[3] := 'l'  S[4] := 'o'  S[5] := '!'  write Sendcodeconsolelog 'Hello!';===========================RUNTIME;--Write literals to literal indexcode Write Array Byte Absolute Zero  var a: array[0..3] of Byte  a[0] := $01  a[1] := $10  a[2] := $08  a[3] := $80endcodevarvaluestring a '[$01,$10,$08,$80]'code Write Array Integer Absolute Zero  var a: array[0..3] of Integer  a[0] := 10  a[1] := 100  a[2] := 1000  a[3] := 10000endcodevarvaluestring a '[10,100,1000,10000]'code Write Array Byte Positive Zero  var a: array[10..13] of Byte  a[10] := $01  a[11] := $10  a[12] := $08  a[13] := $80endcodevarvaluestring a '[$01,$10,$08,$80]'code Write Array Integer Positive Zero  var a: array[10..13] of Integer  a[10] := 10  a[11] := 100  a[12] := 1000  a[13] := 10000endcodevarvaluestring a '[10,100,1000,10000]'code Array Array Write Byte Negative Zero  var a: array[-10..-7] of Byte  a[-10] := $01  a[-9] := $10  a[-8] := $08  a[-7] := $80endcodevarvaluestring a '[$01,$10,$08,$80]'code Write Array Integer Negative Zero  var a: array[-10..-7] of Integer  a[-10] := 10  a[-9] := 100  a[-8] := 1000  a[-7] := 10000endcodevarvaluestring a '[10,100,1000,10000]'code Write Array Integer Char  var a: array['a'..'d'] of Integer  a['a'] := 10  a['b'] := 100  a['c'] := 1000  a['d'] := 10000endcodevarvaluestring a '[10,100,1000,10000]'code Write Array Integer enumerated  type TMyEnum = (eenie, meenie, minie, mo)  var a: array[eenie..mo] of Integer  a[eenie] := 10  a[meenie] := 100  a[minie] := 1000  a[mo] := 10000endcodevarvaluestring a '[10,100,1000,10000]';--Read/Write static arraycode Read/Write Array Byte Zero Based  var A: array[0..5] of Byte  for var I := 0 to 5 do    A[I] := 10	  var Total: Integer  for var J := 0 to 5 do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Array Byte Zero Based Using Range  var A: array[0..5] of Byte  for var I := low(A) to high(A) do    A[I] := 10	  var Total: Integer  for var J := low(A) to high(A) do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Array Byte Negative Low  var A: array[-1..4] of Byte  for var I := low(A) to high(A) do    A[I] := 10	  var Total: Integer  for var J := low(A) to high(A) do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Array Byte Negative  var A: array[-6..-1] of Byte  for var I := low(A) to high(A) do    A[I] := 10	  var Total: Integer  for var J := low(A) to high(A) do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Array Byte Large Negative  var A: array[-1006..-1001] of Byte  for var I := low(A) to high(A) do    A[I] := 10	  var Total: Integer  for var J := low(A) to high(A) do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Array Byte Positive  var A: array[100..105] of Byte  for var I := low(A) to high(A) do    A[I] := 10	  var Total: Integer  for var J := low(A) to high(A) do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Array Byte Large Positive  var A: array[1000..1005] of Byte  for var I := low(A) to high(A) do    A[I] := 10	  var Total: Integer  for var J := low(A) to high(A) do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]';--Write expression valuecode Read/Write Array Int Expr Zero Based  var A: array[0..5] of Integer  for var I := 0 to 5 do    A[I] := I*2	  var Total: Integer  for var J := 0 to 5 do    Total := Total + A[J]endcodevarvalue Total 30VarValueString A '[0,2,4,6,8,10]';--Write expression indexcode Read/Write Array Int Expr Zero Based  var A: array[0..5] of Integer  for var I := 10 to 15 do    A[I-10] := 10	  var Total: Integer  for var J := 0 to 5 do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[10,10,10,10,10,10]';--Write expression index and valuecode Read/Write Array Int Expr Zero Based  var A: array[0..5] of Integer  for var I := 10 to 15 do    A[I-10] := I*10	  var Total: Integer  for var J := 0 to 5 do    Total := Total + A[J]endcodevarvalue Total 750VarValueString A '[100,110,120,130,140,150]';--Range checkscode Range Check Array Immediate  {$R+}  var A: array[0..5] of Integer  A[10] := 10endcodecompile ConstantAssignmentOutOfRangecode Range Check Array Variable  {$R+}  var A: array[0..5] of Integer  var B:=100  A[10] := Bendcodecompile ConstantAssignmentOutOfRangecode Range Check Array Variable  {$R+}  var A: array[0..5] of Integer  var B:=10  A[B] := Bendcoderuntime errorcode Range Check Off Array Immediate  {$R-}  var A: array[0..5] of Integer  A[10] := 10endcodecompile ConstantAssignmentOutOfRangecode Range Check Off Array Variable  {$R-}  var A: array[0..5] of Integer  var B:=100  A[10] := Bendcodecompile ConstantAssignmentOutOfRangecode Range Check Off Array Variable  {$R-}  var A: array[0..5] of Integer  var B:=10  A[B] := Bendcoderuntime noerror;--Array pointercode Read/Write Array Byte Large Positive  var A: array[1000..1005] of Byte  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Array Byte Large Negative  var A: array[-1005..-1000] of Byte  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Array Byte Small Positive  var A: array[100..105] of Byte  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Array Byte Small Negative  var A: array[-105..-100] of Byte  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Array Byte Large Positive Int  var A: array[1000..1005] of Integer  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[10,10,10,10,10,10]'code Read/Write Array Byte Large Negative Int  var A: array[-1005..-1000] of Integer  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[10,10,10,10,10,10]'code Read/Write Array Byte Small Positive Int  var A: array[100..105] of Integer  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[10,10,10,10,10,10]'code Read/Write Array Byte Small Negative Int  var A: array[-105..-100] of Integer  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[10,10,10,10,10,10]';====================MISCELLANEOUScode Multiple Array Derefs  type TArray = array[0..5] of Byte  function FillArray: TArray;register;  begin    for var I := 0 to 5 do      Result[I] := I  end  function DoubleArray(const A: TArray): TArray;register;  begin    for var I := 0 to 5      Result[I] := A[I] * 2  end  var MyArray: TArray    MyArray := DoubleArray(FillArray)endcodeVarValueString MyArray '[$00,$02,$04,$06,$08,$0A]';===================== LITERALS AND CONSTANT EXPRESSIONScode Untyped String Literal  const S = 'Hello World!'endcodecompile noerrorcode String Compile Time Concatention  const S1 = 'Hello ' + 'World!'  const S2 = 'Hello'#32'World!'  const S3 = #32'Hello'#32#32'World!'  const S4 = 'A' + 'Z'  const S5 = 'A' + ' to ' + 'Z'endcodecompile noerrorcode String Compile Time Constants  const S1 = 'Hello'  const S2 = 'World!'  const Space: Char = ' '  const S = S1 + Space + S2endcodecompile noerrorcode Typed String Constants  const S1 = array of Char = 'An array'  const S2 = vector of Char = 'A vector'  const S3 = list of Char = 'a list'  ;Sizes should include meta data  var Size1 := sizeof(S1)  var Size2 := sizeof(S2)  var Size3 := sizeof(S3)endcodevarvalue Size1 8varvalue Size2 9varvalue Size3 8code Assign String Literal to Short List  var S: Short List[20] of Char  S := 'Hello World!'endcodevarvalue S 'Hello World!'code Assign String Literal to Long List  var S: Long List[20] of Char  S := 'Hello World!'endcodevarvalue S 'Hello World!'code Untyped String Literal  var S := 'Hello World!'endcodevarvalue S 'Hello World!'code String Compile Time Concatention  var S1 := 'Hello ' + 'World!'  var S2 := 'Hello'#32'World!'  var S3 := #32'Hello'#32#32'World!'  var S4 := 'A' + 'Z'  var S5 := 'A' + ' to ' + 'Z'endcodevarvalue S1 'Hello World!'varvalue S2 'Hello World!'varvalue S3 ' Hello  World!'varvalue S4 'AZ'varvalue S5 'A to Z'code String Compile Time Constants  const S1 = 'Hello'  const S2 = 'World!'  const Space: Char = ' '  var S := S1 + Space + S2endcodevarvalue S 'Hello World!'