;Arrays and Strings and Lists;============================;=============== ARRAY DECLARATIONS;Note: It's not easy to self test that the array data structures have been set ;up correctly, so these tests are really just testing the syntax(es) parse ;correctly. The execution tests should find any deeper flaws.code Array Single  type Basic = array[0..10] of Byteendcodecompile noerrorcode Array Double  type Basic = array[0..10, 11..20] of Byteendcodecompile noerrorcode Array Triple  type Basic = array[0..10, 11..20, 21..30] of Byteendcodecompile noerrorcode Array Alternate Double  type Basic = array[0..10][11..20] of Byteendcodecompile noerrorcode Array Another Alternate Double  type Basic = array[0..10] of array [11..20] of Byteendcodecompile noerrorcode Array Unbounded  type Basic = array of Byteendcodecompile noerrorcode Array Various Variants  type A=array of Byte  type B=array[1..10] of Byte  type C=array[1..10,11..20] of Byte  type D=array[1..10][11..20] of Byte  type E=array[Char] of Integer  type F=array[(Red, White, Blue)] of 'a'..'z'  type G=array[1..5] of array [1..5] of Boolean  const Start=1  const Finish=10  type H=array[Start+1..2*Finish] of Byteendcodecompile noerrorcode Array Whitespace  type A= array of Byte  type B=array [1..10] of Byte  type C=array[ 1..10,11.. 20] of Byte  type D=array[1..10] [11..20]    of Byteendcodecompile noerrorcode Array Linebreaks A  type A1=    array of Byte  type A2=array     of Byte  type A3=array of     Byteendcodecompile noerrorcode Array Invalid Line Break A  type B4=array[1    ..10] of Byteendcodecompile RangeOperatorExpectedcode Array Linebreaks B  type B1=array    [1..10] of Byte  type B2=array[    1..10] of Byte  type B3=array[1..    10] of Byte  type B5=array[1..10    ] of Byte  type B7=array[1..10] of     Byteendcodecompile noerrorcode Array No ]  type B1=array[1..10 of Byteendcodecompile ArrayBoundsDefinitioncode Array Invalid Line Break B  type B6=array[1..10]     of Byteendcodecompile OFExpected	code Array Linebreaks C  type C1=array[1..10    ,11..20] of Byte  type C2=array[1..10,    11..20] of Byteendcodecompile noerror	code Array Invalid Line Break D  type D=array[1..10]    [11..20] of Byteendcodecompile OFExpectedcode Array Invalid Type  type Basic = array[String] of Byteendcodecompile OrdinalTypeExpected;======================= LIST DECLARATIONScode List Unsized  type A=list of Byteendcodecompile noerrorcode List Sized  type B=list[10] of Byteendcodecompile noerrorcode List Spacing  type B=list [ 10 ] of Byteendcodecompile noerrorcode List Unsized Line Breaks  type A1=    list of Byte  type A3=list of     Byteendcodecompile noerrorcode List Unsized Line Break Error  type A2=list    of Byteendcodecompile noerrorcode List Sized Line Breaks  type B1=list[    10] of Byte  type B2=list[10    ] of Byteendcodecompile noerrorcode List Sized Line Break Error  type B=list    [10] of Byteendcodecompile noerrorcode List Sized Line Breaks  type B=list[10]     of Byteendcodecompile OFExpectedcode List Invalid Capacity 1  type B=list[0] of Byteendcodecompile ListCapacityErrorcode List Invalid Capacity 2  type B=list[-100] of Byteendcodecompile ListCapacityErrorcode List Invalid Capacity 3  type B=list[False] of Byteendcodecompile ListCapacityErrorcode List unbounded to bounded 1  type TA = list of Integer  type TB = TA[10]endcodecompile noerrorcode List unbounded to bounded 2  type TA = list of Integer  var A: TA[10]endcodecompile noerror;====================== INSTANTIATE VARIABLEScode Inst Simple Array Typed  type TA = array[0..10] of Integer  var A: TAendcodecompile noerrorcode Inst Simple Array Inline  var A: array[0..10] of Integerendcodecompile noerrorcode Inst Multi Array Typed  type TA = array[0..10,0..10] of Integer  var A: TAendcodecompile noerrorcode Inst Multi Array Inline  var A: array[0..10,0..10] of Integerendcodecompile noerrorcode Inst Long Simple Array Typed  type TA = array[0..300] of Integer  var A: TAendcodecompile noerrorcode Inst Long Simple Array Inline  var A: array[0..300] of Integerendcodecompile noerrorcode Inst Long Multi Array Typed  type TA = array[0..300,0..300] of Byte  var A: TAendcodecompile noerrorcode Inst Long Multi Array Inline  var A: array[0..300,0..300] of Integerendcodecompile noerrorcode Inst Unbounded Array Typed  type TA = array of Integer  var A: TAendcodecompile InstantiateUnboundedArraycode Inst Unbounded Array Inline  var A: array of Integerendcodecompile InstantiateUnboundedArraycode Inst Short List Typed  type TA = list[10] of Integer  var A: TAendcodecompile noerrorcode Inst Short List Inline  var A: list[10] of Integerendcodecompile noerrorcode Inst Long List Typed  type TA = list[300] of Integer  var A: TAendcodecompile noerrorcode Inst Long List Inline  var A: list[300] of Integerendcodecompile noerrorcode Inst Unbounded List Typed  type TA = list of Integer  var A: TAendcodecompile InstantiateUnboundedArraycode Inst Unbounded List Inline  var A: list of Integerendcodecompile InstantiateUnboundedArray;===========================SUPPORT FUNCTIONScode Array Low  type TA= array[-5..10] of Byte  var ATA := low(TA)  var A: array[0..10] of Integer  var AL := low(A)  var B: array[100..101] of Integer  var BL := low(B)  var C: array[1000..1010] of Integer  var CL := low(C)  var D: array[-10..10] of Integer  var DL := low(D)  var E: array[-1000..-900] of Integer  var EL := low(E)  var F: array['A'..'Z'] of Integer  var FL := low(F)  endcodevarvalue ATA -5varvalue AL 0varvalue BL 100varvalue CL 1000varvalue DL -10varvalue EL -1000varvalue FL 'A'code Array High  type TA= array[-5..10] of Byte  var ATA := high(TA)  var A: array[0..10] of Integer  var AH := high(A)  var B: array[100..101] of Integer  var BH := high(B)  var C: array[1000..1010] of Integer  var CH := high(C)  var D: array[-10..-5] of Integer  var DH := high(D)  var E: array[-1000..-900] of Integer  var EH := high(E)  var F: array['A'..'Z'] of Integer  var FH := high(F)  endcodevarvalue ATA 10varvalue AH 10varvalue BH 101varvalue CH 1010varvalue DH -5varvalue EH -900varvalue FH 'Z'code Array Sizeof  type TA= array[0..9] of Byte  var SA := sizeof(TA)  var A: TA  var SVA := sizeof(A)  type TB= array[0..9] of Integer  var SB := sizeof(TB)  var B: TB  var SVB := sizeof(B)  type TC= array[-10..9] of Byte  var SC := sizeof(TC)  type TD= array[-1000..-1] of Integer  var SD := sizeof(TD)endcodevarvalue SA 10varvalue SVA 10varvalue SB 20varvalue SVB 20varvalue SC 20varvalue SD 2000code Array Length  type TA= array[0..9] of Byte  var SA := length(TA)  var A: TA  var SVA := length(A)  type TB= array[0..9] of Integer  var SB := length(TB)  var B: TB  var SVB := length(B)  type TC= array[-10..9] of Byte  var SC := length(TC)  type TD= array[-1000..-1] of Integer  var SD := length(TD)endcodevarvalue SA 10varvalue SVA 10varvalue SB 10varvalue SVB 10varvalue SC 20varvalue SD 1000code Array AddrOf  var A: array[0..500] of Integer  A[0] := $ff  var P: Pointer  P := @A  var B := P^endcodevarvalue B $ff;===========================RUNTIME;--Write literals to literal indexcode Write Byte Absolute Zero  var a: array[0..3] of Byte  a[0] := $01  a[1] := $10  a[2] := $08  a[3] := $80endcodevarvaluestring a '[$01,$10,$08,$80]'code Write Integer Absolute Zero  var a: array[0..3] of Integer  a[0] := 10  a[1] := 100  a[2] := 1000  a[3] := 10000endcodevarvaluestring a '[10,100,1000,10000]'code Write Byte Positive Zero  var a: array[10..13] of Byte  a[10] := $01  a[11] := $10  a[12] := $08  a[13] := $80endcodevarvaluestring a '[$01,$10,$08,$80]'code Write Integer Positive Zero  var a: array[10..13] of Integer  a[10] := 10  a[11] := 100  a[12] := 1000  a[13] := 10000endcodevarvaluestring a '[10,100,1000,10000]'code Write Byte Negative Zero  var a: array[-10..-7] of Byte  a[-10] := $01  a[-9] := $10  a[-8] := $08  a[-7] := $80endcodevarvaluestring a '[$01,$10,$08,$80]'code Write Integer Negative Zero  var a: array[-10..-7] of Integer  a[-10] := 10  a[-9] := 100  a[-8] := 1000  a[-7] := 10000endcodevarvaluestring a '[10,100,1000,10000]';--Read/Write static arraycode Read/Write Byte Zero Based  var A: array[0..5] of Byte  for var I := 0 to 5 do    A[I] := 10	  var Total: Integer  for var J := 0 to 5 do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Byte Zero Based Using Range  var A: array[0..5] of Byte  for var I := low(A) to high(A) do    A[I] := 10	  var Total: Integer  for var J := low(A) to high(A) do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Byte Negative Low  var A: array[-1..4] of Byte  for var I := low(A) to high(A) do    A[I] := 10	  var Total: Integer  for var J := low(A) to high(A) do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Byte Negative  var A: array[-6..-1] of Byte  for var I := low(A) to high(A) do    A[I] := 10	  var Total: Integer  for var J := low(A) to high(A) do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Byte Large Negative  var A: array[-1006..-1001] of Byte  for var I := low(A) to high(A) do    A[I] := 10	  var Total: Integer  for var J := low(A) to high(A) do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Byte Positive  var A: array[100..105] of Byte  for var I := low(A) to high(A) do    A[I] := 10	  var Total: Integer  for var J := low(A) to high(A) do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Byte Large Positive  var A: array[1000..1005] of Byte  for var I := low(A) to high(A) do    A[I] := 10	  var Total: Integer  for var J := low(A) to high(A) do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]';--Write expression valuecode Read/Write Int Expr Zero Based  var A: array[0..5] of Integer  for var I := 0 to 5 do    A[I] := I*2	  var Total: Integer  for var J := 0 to 5 do    Total := Total + A[J]endcodevarvalue Total 30VarValueString A '[0,2,4,6,8,10]';--Write expression indexcode Read/Write Int Expr Zero Based  var A: array[0..5] of Integer  for var I := 10 to 15 do    A[I-10] := 10	  var Total: Integer  for var J := 0 to 5 do    Total := Total + A[J]endcodevarvalue Total 60VarValueString A '[10,10,10,10,10,10]';--Write expression index and valuecode Read/Write Int Expr Zero Based  var A: array[0..5] of Integer  for var I := 10 to 15 do    A[I-10] := I*10	  var Total: Integer  for var J := 0 to 5 do    Total := Total + A[J]endcodevarvalue Total 750VarValueString A '[100,110,120,130,140,150]';--Range checkscode Range Check Immediate  {$R+}  var A: array[0..5] of Integer  A[10] := 10endcodecompile ConstantAssignmentOutOfRangecode Range Check Variable  {$R+}  var A: array[0..5] of Integer  var B:=100  A[10] := Bendcodecompile ConstantAssignmentOutOfRangecode Range Check Variable  {$R+}  var A: array[0..5] of Integer  var B:=10  A[B] := Bendcoderuntime errorcode Range Check Off Immediate  {$R-}  var A: array[0..5] of Integer  A[10] := 10endcodecompile ConstantAssignmentOutOfRangecode Range Check Off Variable  {$R-}  var A: array[0..5] of Integer  var B:=100  A[10] := Bendcodecompile ConstantAssignmentOutOfRangecode Range Check Off Variable  {$R-}  var A: array[0..5] of Integer  var B:=10  A[B] := Bendcoderuntime noerror;--Array pointercode Read/Write Byte Large Positive  var A: array[1000..1005] of Byte  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Byte Large Negative  var A: array[-1005..-1000] of Byte  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Byte Small Positive  var A: array[100..105] of Byte  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Byte Small Negative  var A: array[-105..-100] of Byte  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[$0A,$0A,$0A,$0A,$0A,$0A]'code Read/Write Byte Large Positive Int  var A: array[1000..1005] of Integer  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[10,10,10,10,10,10]'code Read/Write Byte Large Negative Int  var A: array[-1005..-1000] of Integer  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[10,10,10,10,10,10]'code Read/Write Byte Small Positive Int  var A: array[100..105] of Integer  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[10,10,10,10,10,10]'code Read/Write Byte Small Negative Int  var A: array[-105..-100] of Integer  var PA := @A  for var I := low(PA^) to high(PA^) do    PA^[I] := 10	  var Total: Integer  for var J := low(PA^) to high(PA^) do    Total := Total + PA^[J]endcodevarvalue Total 60VarValueString A '[10,10,10,10,10,10]'code Multiple Array Derefs  type TArray = array[0..5] of Byte  function FillArray: TArray;register;  begin    for var I := 0 to 5 do      Result[I] := I  end  function DoubleArray(const A: TArray): TArray;register;  begin    for var I := 0 to 5      Result[I] := A[I] * 2  end  var MyArray: TArray;  begin    MyArray := DoubleArray(FillArray)  end.endcodeVarValueString MyArray '[$00,$02,$04,$06,$08,$0A]'