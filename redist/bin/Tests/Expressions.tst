code Assignment and Operations  var x%:=100  var y%:=259    var add% := x+y  var sub1% := x-y  var sub2% := y-x  var neg% := -add  var invert% := not addendcodevarvalue add 359varvalue sub1 -159varvalue sub2 159varvalue neg -359varvalue invert -360code Precedence  var x%:=689  var y%:=1000  var z%:=84    var aa%:=x+y+z  var as%:=x+y-z  var sa%:=x-y+zendcodevarvalue aa 1773varvalue as 1605varvalue sa -227code Parenthesis  var x%:=689  var y%:=1000  var z%:=84    var a%:=x-(y-z)  var b%:=(x-y)-z  var c%:=x-(y-z)-z  var d%:=((y-x)+y)-z   var e%:=x+(y-(z-y))   var f%:=x+(-y)  var g%:=x+-(y)endcodevarvalue a -227varvalue b -395varvalue c -311varvalue d 1227varvalue e 2605varvalue f -311varvalue g -311code Overflow Integer  var a%:=32768endcodecompile ConstantAssignmentOutOfRangecode Underflow Integer  var a%:=-32769endcodecompile ConstantAssignmentOutOfRangecode Overflow Word  var a#:=65536endcodecompile ConstantAssignmentOutOfRangecode Underflow Word  var a#:=-1endcodecompile ConstantAssignmentOutOfRangecode Overflow Byte  var a##:=256endcodecompile ConstantAssignmentOutOfRangecode Underflow Byte  var a##:=-1endcodecompile ConstantAssignmentOutOfRangecode Intrinsic after expression  var x:Integer=0  x := x+1 inc(x)endcodecompile EndOfStatementExpected;Tests for a potential bug in param loader:;The first addition leaves the result in A,;The second requires that value to still be in A but loading x trashes A;This code tests that the value of z was successfully preserved (or reloaded)code PreserveA  var x:Byte = 10  var y:Byte = 20  var z:Byte = x+y  var j:Byte = z+xendcodevarvalue x 10varvalue y 20varvalue z 30varvalue j 40;Alternative with subtraction - in case of register swapping in the add casecode PreserveA Sub  var x:Byte = 10  var y:Byte = 20  var z:Byte = x+y  var j:Byte = z-xendcodevarvalue x 10varvalue y 20varvalue z 30varvalue j 20