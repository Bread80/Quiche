code Pascal style declarations  var I16: Integer;  var I8: Int8;  var W : Word;  var B:Byte;  var Bool: Boolean  var  C  :  Char  ;endcodevartype I16 Integervartype I8 Int8vartype W Wordvartype B Bytevartype Bool Booleanvartype C Charcode Quiche style declarations  var I16%;  var I8%%;  var W#;  var B## ;  var Bool?  ;  var C$$;endcodevartype I16 Integervartype I8 Int8vartype W Wordvartype B Bytevartype Bool Booleanvartype C Charcode Pascal style declarations with assignment  var I16: Integer = 1234;  var I16n: Integer = -1234;  var I16min: Integer = -32768;  var I16max: Integer = 32767;  var I8:Int8 =$12;  var I8n:Int8=-60  var I8min: Int8 = -128;  var I8max: Int8 = 127;  var W : Word = 4321;  var Wmax: Word = 65535;  var B  :  Byte  =  $21  var Bmax: Byte = 255;  var Bool: Boolean = True;  var C: Char = 'x';endcodevarvalue I16 1234varvalue I16n -1234varvalue I16min -32768varvalue I16max 32767varvalue I8 18varvalue I8n -60varvalue I8min -128varvalue I8max 127varvalue W 4321varvalue Wmax 65535varvalue B 33varvalue Bmax 255varvalue Bool Truevarvalue C 'x'code Quiche style declarations with assignment  var I16% := 1234;  var I8%%:=$12;  var W#  :=  4321;  var B## := $21;  var Bool? := True;  var C$$ := 'x';endcodevarvalue I16 1234varvalue I8 18varvalue W 4321varvalue B 33varvalue Bool Truevarvalue C 'x'code Inference signed default  {$DEFAULTSIGNEDINTEGER+}  {$DEFAULTSMALLESTINTEGER-}  var I16 := 1234;  var I16min := -32768  var I16max := 32767  var I16Plus := +1000    var I8:=12;  var I8Plus := +100  var I8Minus := -100    var IPrefix := 012  var IPrefixPlus := +100  var IPrefixMinus := -100endcodevartype I16 Integervartype I16min Integervartype I16max Integervartype I16Plus Integervartype I8 Integervartype I8Plus Integervartype I8Minus Integervartype IPrefix Integervartype IPrefixPlus Integervartype IPrefixMinus Integercode Inference unsigned default  {$DEFAULTSIGNEDINTEGER-}  {$DEFAULTSMALLESTINTEGER-}  var I16 := 1234;  var I16min := -32768  var I16max := 32767  var I16Plus := +1000    var I8:=12;  var I8Plus := +100  var I8Minus := -100    var IPrefix := 012  var IPrefixPlus := +100  var IPrefixMinus := -100endcodevartype I16 Wordvartype I16min Integervartype I16max Wordvartype I16Plus Integervartype I8 Wordvartype I8Plus Integervartype I8Minus Integervartype IPrefix Wordvartype IPrefixPlus Integervartype IPrefixMinus Integercode Inference signed smallest  {$DEFAULTSIGNEDINTEGER+}  {$DEFAULTSMALLESTINTEGER+}  var I16 := 1234;  var I16min := -32768  var I16max := 32767  var I16Plus := +1000    var I8:=12;  var I8Plus := +100  var I8Minus := -100    var IPrefix := 012  var IPrefixPlus := +100  var IPrefixMinus := -100endcodevartype I16 Integervartype I16min Integervartype I16max Integervartype I16Plus Integervartype I8 Int8vartype I8Plus Int8vartype I8Minus Int8vartype IPrefix Integervartype IPrefixPlus Int8vartype IPrefixMinus Int8code Inference unsigned smallest  {$DEFAULTSIGNEDINTEGER-}  {$DEFAULTSMALLESTINTEGER+}  var I16 := 1234;  var I16min := -32768  var I16max := 32767  var I16Plus := +1000    var I8:=12;  var I8Plus := +100  var I8Minus := -100    var IPrefix := 012  var IPrefixPlus := +100  var IPrefixMinus := -100endcodevartype I16 Wordvartype I16min Integervartype I16max Wordvartype I16Plus Integervartype I8 Bytevartype I8Plus Int8vartype I8Minus Int8vartype IPrefix Wordvartype IPrefixPlus Int8vartype IPrefixMinus Int8code Inference hex  var WH  :=  $4321;  var WMin := $100  var WHMax := $ffff  var BH := $21;  var Bmax := $ffendcodevartype WH Pointervartype WMin Pointervartype WHMax Pointervartype BH Bytevartype BMax Bytecode Inference binary  var WB := %1100110001010101;  var BB := %1100;endcodevartype WB Wordvartype BB Bytecode Inference other  var Bool := True;  var C := 'x';endcodevartype Bool Booleanvartype C Charcode Complex type inference  {$DEFAULTSIGNEDINTEGER+}  {$DEFAULTSMALLESTINTEGER-}  var I16 := 1234 + $01;  var I8:=12+$1234;  var WH  :=  $4321  +  12 ;  var WB := %1100 + 1234  var BH := $21 + 21  var BB := %0011 + 128  var Bool := 1=1;  var C := 'x';  var N:=not 2  var M:=-Nendcodevartype I16 Integervartype I8 Pointervartype WH Pointervartype WB Integervartype BH Integervartype BB Integervartype Bool Booleanvartype C Charvartype N Integervartype M Integercode Inference out of range 1  {$DEFAULTSIGNEDINTEGER+}  var X := 65535;endcodecompile ConstantAssignmentOutOfRangecode Variable already declared A  var a%;  var a%;endcodecompile IdentifierRedeclaredcode Variable already declared B  var a%:=1;  var a%:=1;endcodecompile IdentifierRedeclaredcode Variable not yet declared  a:=1endcodecompile VariableNotFound;;=========================LINE BREAKScode Valid line breaks  var    b := 1  var d :=    1  var e :    Integer = 1  var f : Integer =    1endcodecompile noerrorcode Invalid Line Break 1  var c    := 1endcodecompile ColonExpectedInVARcode Invalid Line break 2  var a : Integer    = 1endcodecompile IdentifierExpectedcode Invalid Line break 3  var x%     := 10endcodecompile IdentifierExpectedvarvalue y 40code Statements  var x:=1;var y:=2endcodecompile noerrorcode Statements error  var x:=1 var y:=2endcodecompile EndOfStatementExpected;=============MULTILINEparsetype Declarationscode Multiline  var     x:Integer    c: Char;b: Byte  begin  end.endcoderuntime noerrorvartype x Integervartype c Charvartype b Byte;=============SCOPEparsetype Codecode Same name, separate scopes  for var I := 1 to 10    var X := 1  for var I := 1 to 10 do ;    var X := 10endcodecompile noerror;=============STACK FUNCTIONS;Tests the allocation of stack space for Pointered Types;Tests we're allocating stack storage correctlycode local array declaration, storage  program  var    TestA: Integer    TestB: Integer  procedure F;stack;  var    A: Integer    MyArray: array[0..500] of Integer    B: Integer  begin    A := 100    B := 1000    MyArray[0] := 10000    TestA := A    TestB := B  end  begin    F  end.endcodevarvalue TestA 100varvalue TestB 1000code local array declaration, Literal index  program  var Test: Integer  procedure F;stack;  var MyArray: array[0..5] of Integer  begin    MyArray[0] := 1000    Test := MyArray[0]  end  begin    F  end.endcodevarvalue Test 1000code local array declaration, Variable index  program  var Test: Integer  procedure F;stack;  var MyArray: array[0..5] of Integer  begin    for var I := 0 to 5 do      MyArray[I] := 1000+I    var J := 5    Test := MyArray[J]  end  begin    F  end.endcodevarvalue Test 1005