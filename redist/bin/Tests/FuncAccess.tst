;Access Specifiers for Function Parametersparsetype declarations;----Passing Literalscode Value Literal  var Test: Integer  procedure Foo(X: Integer);register;  begin	Test := X  end  begin	Foo(5)  end.endcodevarvalue Test 5code VAR Literal  var Test: Integer  procedure Foo(var X: Integer);register;  begin	Test := X  end  begin	Foo(5)  end.endcodecompile ArgMustBeVariablecode CONST Literal  var Test: Integer  procedure Foo(const X: Integer);register;  begin	Test := X  end  begin	Foo(5)  end.endcodevarvalue Test 5code OUT Literal  var Test: Integer  procedure Foo(out X: Integer);register;  begin	Test := X  end  begin	Foo(5)  end.endcodecompile ArgMustBeVariable;-----Passing CONST params to functionscode CONST To Value  var Test: Integer  procedure Foo(X: Integer);register;  begin	Test := X  end    procedure bar(const Y: Integer);register;  begin    Foo(Y)  end  var A:Integer  begin    A := 5	Foo(A)  end.endcodevarvalue Test 5code CONST To VAR  var Test: Integer  procedure Foo(var X: Integer);register;  begin	Test := X  end    procedure bar(const Y: Integer);register;  begin    Foo(Y)  end  var A:Integer  begin    A := 5	Foo(A)  end.endcodecompile CantPassCONSTasVARorOUTcode CONST To CONST  var Test: Integer  procedure Foo(const X: Integer);register;  begin	Test := X  end    procedure bar(const Y: Integer);register;  begin    Foo(Y)  end  var A:Integer  begin    A := 5	Foo(A)  end.endcodevarvalue Test 5code CONST To OUT  var Test: Integer  procedure Foo(out X: Integer);register;  begin	Test := X  end    procedure bar(const Y: Integer);register;  begin    Foo(Y)  end  var A:Integer  begin    A := 5	Foo(A)  end.endcodecompile CantPassCONSTasVARorOUT;========================= REGISTER CALLING CONVENTION;-------------------------Register Typescode Register Register Value  var Test: Integer  procedure Foo(X: Integer);register;  begin	Test := X	X := 12  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue A 5varvalue Test 5code Register Register VAR  var Test: Integer  procedure Foo(var X: Integer);register;  begin	Test := X	X := 12  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue A 12varvalue Test 5code Register Register CONST Write  var Test: Integer  procedure Foo(const X: Integer);register;  begin	Test := X	X := 12  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodecompile AssignToCONSTVarcode Register Register CONST Read  var Test: Integer  procedure Foo(const X: Integer);register;  begin	Test := X  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue A 5varvalue Test 5code Register Register OUT  procedure Foo(out X: Integer);register;  begin	X := 12  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue A 12code Register Register Result  function Foo: Integer;register;  begin	Result := 12  end  var A: Integer  begin    A := 5    A := Foo  end.endcodevarvalue A 12;-------------------------Pointered Typescode Register Pointered Value  type TArray = array[0..5] of Byte  var    TestOld: Byte    TestNew: Byte  procedure FillArray(A: TArray);register;  begin    TestOld := A[5]    for var I := 0 to 5 do      A[I] := I    TestNew := A[5]  end  var MyArray: TArray;  begin    for var I := 0 to 5 do      MyArray[I] := $ff    FillArray(MyArray)  end.endcodevarvalue TestOld $ffvarvalue TestNew 5VarValueString MyArray '[$FF,$FF,$FF,$FF,$FF,$FF]'code Register Pointered VAR  type TArray = array[0..5] of Byte  procedure FillArray(var A: TArray);register;  begin    for var I := 0 to 5 do      A[I] := I  end  var MyArray: TArray;  begin    FillArray(MyArray)  end.endcodeVarValueString MyArray '[$00,$01,$02,$03,$04,$05]'code Register Pointered CONST Write  type TArray = array[0..5] of Byte  procedure FillArray(const A: TArray);register;  begin    for var I := 0 to 5 do      A[I] := I  end  var MyArray: TArray;  begin    FillArray(MyArray)  end.endcodecompile AssignToCONSTVarcode Register Pointered CONST Read  type TArray = array[0..5] of Byte  var test: Byte  procedure FillArray(const A: TArray);register;  begin	Test := A[5];  end  var MyArray: TArray;  begin    for var I := 0 to 5 do	  MyArray[I] := I    FillArray(MyArray)  end.endcodevarvalue Test 5VarValueString MyArray '[$00,$01,$02,$03,$04,$05]'code Register Pointered OUT  type TArray = array[0..5] of Byte  procedure FillArray(out A: TArray);register;  begin    for var I := 0 to 5 do      A[I] := I  end  var MyArray: TArray;  begin    FillArray(MyArray)  end.endcodeVarValueString MyArray '[$00,$01,$02,$03,$04,$05]'code Register Pointered Result  type TArray = array[0..5] of Byte  function FillArray: TArray;register;  begin    for var I := 0 to 5 do      Result[I] := I  end  var MyArray: TArray;  begin    MyArray := FillArray  end.endcodeVarValueString MyArray '[$00,$01,$02,$03,$04,$05]'code register Pointered Result temp var  type TArray = array[0..5] of Byte  function FillArray: TArray;register;  begin    for var I := 0 to 5 do      Result[I] := I  end  function DoubleArray(const A: TArray): TArray;register;  begin    {$R-}    for var I := 0 to 5      Result[I] := A[I] * 2  end  var MyArray: TArray;  begin    MyArray := DoubleArray(FillArray)  end.endcodeVarValueString MyArray '[$00,$02,$04,$06,$08,$0A]';========================= STACK CALLING CONVENTION;-------------------------Register Typescode Stack Register Value Literal  var Test: Integer  procedure Foo(X: Integer);stack;  begin	Test := X	X := 12  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue A 5varvalue Test 5code Stack Register Value Variable  var Test: Integer  procedure Foo(X: Integer);stack;  var Y: Integer = 12  begin	Test := X	X := Y  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue A 5varvalue Test 5;--Test StackRef Load from/to type comboscode Stack Register VAR From Byte->Byte  var Test: Byte  procedure Foo(var X: Byte);stack;  begin	Test := X  end  var A: Byte  begin    A := 5	Foo(A)  end.endcodevarvalue Test 5code Stack Register VAR From Byte->Integer  var Test: Integer  procedure Foo(var X: Byte);stack;  begin	Test := X  end  var A: Byte  begin    A := 5	Foo(A)  end.endcodevarvalue Test 5code Stack Register VAR From Integer->Integer  var Test: Integer  procedure Foo(var X: Integer);stack;  begin	Test := X  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue Test 5code Stack Register VAR From Integer->Byte  var Test: Byte  procedure Foo(var X: Integer);stack;  begin	Test := X  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue Test 5code Stack Register VAR From Lo(Integer)->Byte  var Test: Byte  procedure Foo(var X: Integer);stack;  begin	Test := Lo(X)  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue Test 5code Stack Register VAR From Hi(Integer)->Byte  var Test: Byte  procedure Foo(var X: Integer);stack;  begin	Test := Hi(X)  end  var A: Integer  begin    A := $0102	Foo(A)  end.endcodevarvalue Test 1;---code Stack Register VAR Store Literal Byte  procedure Foo(var X: Byte);stack;  begin	X := 12  end  var A: Byte  begin    A := 5	Foo(A)  end.endcodevarvalue A 12code Stack Register VAR Store Literal Integer  procedure Foo(var X: Integer);stack;  begin	X := 1200  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue A 1200code Stack Register VAR Store Byte->Byte  procedure Foo(var X: Byte);stack;  var Y: Byte = 12  begin	X := Y  end  var A: Byte  begin    A := 5	Foo(A)  end.endcodevarvalue A 12code Stack Register VAR Store Byte->Integer  procedure Foo(var X: Integer);stack;  var Y: Byte = 12  begin	X := Y  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue A 12code Stack Register VAR Store Integer->Integer  procedure Foo(var X: Integer);stack;  var Y: Integer = 1200  begin	X := Y  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue A 1200code Stack Register VAR Store Integer->Byte  procedure Foo(var X: Byte);stack;  var Y: Integer = 12  begin	X := Y  end  var A: Byte  begin    A := 5	Foo(A)  end.endcodevarvalue A 12code Stack Register VAR Store Lo(Integer)->Byte  procedure Foo(var X: Byte);stack;  var Y: Integer = $0102  begin	X := Lo(Y)  end  var A: Byte  begin    A := 5	Foo(A)  end.endcodevarvalue A 2code Stack Register VAR Store Hi(Integer)->Byte  procedure Foo(var X: Byte);stack;  var Y: Integer = $0102  begin	X := Hi(Y)  end  var A: Byte  begin    A := 5	Foo(A)  end.endcodevarvalue A 1;--code Stack Register CONST Write  var Test: Integer  procedure Foo(const X: Integer);stack;  begin	Test := X	X := 12  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodecompile AssignToCONSTVarcode Stack Register CONST Read  var Test: Integer  procedure Foo(const X: Integer);stack;  begin	Test := X  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue A 5varvalue Test 5code Stack Register OUT  var Test: Integer  procedure Foo(out X: Integer);stack;  begin	X := 12  end  var A: Integer  begin    A := 5	Foo(A)  end.endcodevarvalue A 12code Stack Register Result  function Foo: Integer;stack;  begin	Result := 12  end  var A: Integer  begin    A := 5    A := Foo  end.endcodevarvalue A 12;-------------------------Pointered Typescode Stack Pointered Value  type TArray = array[0..5] of Byte  var     TestOld: Byte    TestNew: Byte    TestOriginal: Byte  procedure FillArray(A: TArray);stack;  begin    TestOld := A[5]    for var I := 0 to 5 do      A[I] := I	TestNew := A[5]  end  var MyArray: TArray;  begin    for var I := 0 to 5 do	  MyArray[I] := $80+I    FillArray(MyArray)    TestOriginal := MyArray[5]  end.endcodevarvalue TestOld $85varvalue TestNew 5varvalue TestOriginal $85VarValueString MyArray '[$80,$81,$82,$83,$84,$85]'code Stack Pointered Value w/guard  type TArray = array[0..5] of Byte  var    TestOld: Byte    TestNew: Byte    TestPre: Byte    TestPost: Byte  procedure FillArray(Pre: Byte;A: TArray;Post: Byte);stack;  begin    TestOld := A[5]    for var I := 0 to 5 do      A[I] := I	TestNew := A[5]	TestPre := Pre	TestPost := Post  end  var MyArray: TArray;  begin    for var I := 0 to 5 do	  MyArray[I] := $80+I    FillArray(66, MyArray, 99)  end.endcodevarvalue TestOld $85varvalue TestNew 5VarValueString MyArray '[$80,$81,$82,$83,$84,$85]'varvalue TestPre 66varvalue TestPost 99code Stack Pointered VAR  type TArray = array[0..5] of Byte  procedure FillArray(var A: TArray);stack;  begin    for var I := 0 to 5 do      A[I] := I  end  var MyArray: TArray;  begin    FillArray(MyArray)  end.endcodeVarValueString MyArray '[$00,$01,$02,$03,$04,$05]'code Stack Pointered CONST Write  type TArray = array[0..5] of Byte  procedure FillArray(const A: TArray);stack;  begin    for var I := 0 to 5 do      A[I] := I  end  var MyArray: TArray;  begin    FillArray(MyArray)  end.endcodecompile AssignToCONSTVarcode Stack Pointered CONST Read  type TArray = array[0..5] of Byte  var test: Byte  procedure FillArray(const A: TArray);stack;  begin	Test := A[5];  end  var MyArray: TArray;  begin    for var I := 0 to 5 do	  MyArray[I] := I    FillArray(MyArray)  end.endcodevarvalue Test 5VarValueString MyArray '[$00,$01,$02,$03,$04,$05]'code Stack Pointered OUT  type TArray = array[0..5] of Byte  procedure FillArray(out A: TArray);stack;  begin    for var I := 0 to 5 do      A[I] := I  end  var MyArray: TArray;  begin    FillArray(MyArray)  end.endcodeVarValueString MyArray '[$00,$01,$02,$03,$04,$05]'code Stack Pointered Result  type TArray = array[0..5] of Byte  function FillArray: TArray;stack;  begin    for var I := 0 to 5 do      Result[I] := I  end  var MyArray: TArray;  begin    MyArray := FillArray  end.endcodeVarValueString MyArray '[$00,$01,$02,$03,$04,$05]'code Stack Pointered Result temp var  type TArray = array[0..5] of Byte  function FillArray: TArray;stack;  begin    for var I := 0 to 5 do      Result[I] := I  end  function DoubleArray(const A: TArray): TArray;stack;  begin    {$R-}    for var I := 0 to 5      Result[I] := A[I] * 2  end  var MyArray: TArray;  begin    MyArray := DoubleArray(FillArray)  end.endcodeVarValueString MyArray '[$00,$02,$04,$06,$08,$0A]'