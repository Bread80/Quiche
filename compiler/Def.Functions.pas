unit Def.Functions;

interface
uses Classes, Generics.Collections,
  Def.Operators, Def.QTypes, Def.Consts, Def.Variables,
  Z80.Hardware;

//Maximum number of parameters which can be specified for a routine, including results
const MaxFunctionParams = 10;

type
  TFuncFlag = (
    ffForward,    //This is a forward declaration
    ffOverloaded  //Overloaded if multiple functions with the same name, but different parameters
                  //(Currently no plans to support overloading)
     );
  TFuncFlagSet = set of TFuncFlag;

  TCallingConvention = (
    ccUnknown,    //I.e. not yet assigned/parser error
    ccIntrinsic,  //No call needed! Generated by code generator
                  //Not available for user defined functions
    ccStack,      //Both parameters and variables allocated to an IX based stack frame
    ccRegister,   //Parameters allocated to registers (if possible), otherwise
                  //spilled to static (global) variables
    ccCall,       //A call to external code (at fixed address), otherwise as Register
    ccRST         //As ccCode but for reoutines dispatched via Z80 RST instructions
    );

//This probably ought to be a compiler option. TODO
const
//  DefaultCallingConvention = ccStackFrame;
  DefaultExternCallingConvention = ccRegister;

type
  PParameter = ^TParameter;
  TParameter = record
    Access: TVarAccess; //Ignored for Intrinsics
    Name: String;

    Reg: TCPUReg;       //If the parameter is passed via a register, otherwise rNone
                          //Ignored for Intrinsics
    VarType: TVarType;    //Parameter type
    SuperType: TSuperType;  //Only for intrinsics. Only valid where VarType is vtUnknown.

    HasDefaultValue: Boolean;
    DefaultValue: TImmValue;   //If the parameter is optional.
                          //(only usable by Intrinsics at the moment)

    function ToString: String;
  end;

  TParamArray = array[0..MaxFunctionParams] of TParameter;

  //For functions or procedures
  PFunction = ^TFunction;
  TFunction = record
    NameSpace: String;      //I.e. current file
    Name: String;
    Flags: TFuncFlagSet;    //Meta data about the function

    Preserves: TCPURegSet;  //Registers which are prserved
//    InRegs: TUsedRegSet;    //Registers used for inputs (parameters)
//    OutRegs: TUsedRegSet;   //Registers used for outputs (parameters and return values)

    Overloaded: Boolean;    //Overloaded if multiple functions with the same name, but different parameters
    IsExtern: Boolean;      //True if this is an Extern definition (i.e to external code - O/S etc)
    CallingConvention: TCallingConvention;
    ParamCount: Integer;
    ResultCount: Integer;   //Result count of zero = Procedure

    Op: TOperator;          //If this is an intrinsic (otherwise OpUnknown)
    CodeAddress: Word;      //If implemented in machine code at fixed address

    Params: TParamArray;    //Parameter data

    Comments: String;       //Freeform help etc text

    //Search the parameters of Func, from parameter 0 to Parameter LastIndex for
    //one matching the given ParamName
    function FindParam(ParamName: String; LastIndex: Integer): PParameter;
    //Finds the (first) Result parameter.
    //If none is found raises an exception
    function FindResult: PParameter;

    //Returns variable storage (specified by the calling convention)
    function GetParamStorage: TVarStorage;
    function GetLocalStorage: TVarStorage;

    //Returns the assembly instruction to call this function.
    //(Could be a CALL or an RST, or something fancier).
    function GetCallInstruction: String;

    function ToString: String;
  end;

type TFuncList = TList<PFunction>;

function CreateFuncList: TFuncList;

procedure ClearFunclist(FuncList: TFuncList);

procedure SetCurrentFuncList(AFuncList: TFuncList);

//Find the given function
function FuncFindAllScopes(Name: String): PFunction;

function FuncFindInScope(Name: String): PFunction;

//Create a new function and return it
function FuncCreate(NameSpace, Name: String): PFunction;

type TFuncDirective = (
  dirUNKNOWN,
  dirFORWARD,
  dirCALL, dirRST,
  dirSTACK, dirREGISTER);

function IdentToFuncDirective(const Ident: String): TFuncDirective;

//Converts a string to an access specifier.
//If Ident is an access specifier returns True,
//if not returns False and Access returns paVal
function IdentToAccessSpecifier(const Ident: String;out Access: TVarAccess): Boolean;


procedure FunctionsToStrings(S: TStrings);


implementation
uses SysUtils,
  Def.Scopes;

var FuncList: TFuncList;

function CreateFuncList: TFuncList;
begin
  Result := TFuncList.Create;
end;

procedure ClearFunclist(FuncList: TFuncList);
var F: PFunction;
begin
  for F in FuncList do
    Dispose(F);

  FuncList.Clear;
end;

procedure SetCurrentFuncList(AFuncList: TFuncList);
begin
  FuncList := AFuncList;
end;

function FuncFindAllScopes(Name: String): PFunction;
var IdentType: TIdentType;
  Scope: PScope;
  Item: Pointer;
begin
  Item := SearchScopes(Name,IdentType,Scope);
  if Assigned(Item) then
    if IdentType = itFunction then
      EXIT(PFunction(Item));

  Result := nil;
end;

function FuncFindInScope(Name: String): PFunction;
begin
  for Result in FuncList do
    if CompareText(Result.Name, Name) = 0 then
      EXIT;

  Result := nil;
end;

function FuncCreate(NameSpace, Name: STring): PFunction;
var I: Integer;
begin
  New(Result);
  FuncList.Add(Result);
  Result.NameSpace := NameSpace;
  Result.Name := Name;
  Result.Flags := [];
  Result.Preserves := [];
//  Result.InRegs := [];
//  Result.OutRegs := [];
  Result.IsExtern := False;
  Result.CallingConvention := ccUnknown;
  Result.ParamCount := 0;
  Result.ResultCount := 0;
  Result.Op := OpUnknown;
  Result.CodeAddress := 0;

  for I := 0 to MaxFunctionParams do
  begin
    Result.Params[I].Name := '';
    Result.Params[I].Reg := rNone;
    Result.Params[I].VarType := vtUnknown;
//    Result.Params[I].VarTypes := [];
    Result.Params[I].Access := vaNone;
    Result.Params[I].HasDefaultValue := False;
//    Result.Params[I].DefaultValue := 0;
  end;
end;

function IdentToFuncDirective(const Ident: String): TFuncDirective;
const DirectiveStrings: array[low(TFuncDirective)..high(TFuncDirective)] of String = (
  '',  //Placeholder for Unknown value
  'forward',
  'call','rst',
  'stack','register');
begin
  for Result := low(TFuncDirective) to high(TFuncDirective) do
    if CompareText(DirectiveStrings[Result], Ident) = 0 then
      EXIT;

  Result := dirUnknown;
end;

function IdentToAccessSpecifier(const Ident: String;out Access: TVarAccess): Boolean;
const AccessStrings: array[low(TVarAccess)..high(TVarAccess)] of String = (
  '',
  '',   //Local variables don't have a keyword
  '',   //Val doesn't have a keyword
  'var', 'const', {'in',} 'out',
  '');  //Result doesn't have a keyword
var VA: TVarAccess;
begin
  for VA := low(TVarAccess) to high(TVarAccess) do
    if CompareText(AccessStrings[VA], Ident) = 0 then
    begin
      Access := VA;
      EXIT(True);
    end;

  Access := vaVal;
  Result := False;
end;

{ TParameter }

function TParameter.ToString: String;
//var VT: TTypeEnum;
begin
  case Access of
    vaVal, vaResult: Result := '';
    vaVar: Result := 'var ';
    vaConst: Result := 'const ';
    vaOut: Result := 'out ';
  else
    raise Exception.Create('Unknown param specifier in param');
  end;

  if Access <> vaResult then
    Result := Result + Name;

  Result := Result + ': ';

  if Reg <> rNone then
  begin
    Result := Result + CPURegStrings[Reg];
    Result := Result + ' as ';
  end;

  if VarType <> vtUnknown then
    Result := Result + VarTypeToName(VarType)
  else
    Result := Result + SuperTypeToString(SuperType);

  if HasDefaultValue then
    Result := Result + ' = ' + DefaultValue.ToString;
end;

{ TFunction }

function TFunction.FindParam(ParamName: String; LastIndex: Integer): PParameter;
var I: Integer;
begin
  for I := 0 to LastIndex do
    if I > MaxFunctionParams then
      EXIT(nil)
    else if CompareText(Params[I].Name, ParamName) = 0 then
      EXIT(@Params[I]);

  Result := nil;
end;

function TFunction.FindResult: PParameter;
var I: Integer;
begin
  for I := 0 to Length(Params)-1 do
    if Params[I].Access = vaResult then
      EXIT(@Params[I]);

  Result := nil;
  Assert(False, 'Function result not found');
end;

function TFunction.GetCallInstruction: String;
begin
  case CallingConvention of
    ccCall: Result := 'call $' + IntToHex(CodeAddress, 4);
    ccRST:
      if CodeAddress > 7 then
        Result := 'rst $' + IntToHex(CodeAddress, 2)
      else
        Result := 'rst ' + IntToStr(CodeAddress);
    ccRegister, ccStack:
      Result := 'call _' + Name
  else
    raise exception.Create('GetCallInstruction: Dispatch type not implemented yet');
  end;
end;

function TFunction.GetLocalStorage: TVarStorage;
begin
  case CallingConvention of
    ccRegister: Result := vsStatic;
    ccStack: Result := vsStack;
  else
    raise Exception.Create('Undefined Calling Convention');
  end;
end;

function TFunction.GetParamStorage: TVarStorage;
begin
  case CallingConvention of
    ccRegister:
      //Params are passed in registers. Storage will be alocated in global (static)
      //memory space but may (hopefully will) be optimised away into registers
      Result := vsStatic;
    ccStack: Result := vsStack;
  else
    raise Exception.Create('Undefined Calling Convention');
  end;
end;

function TFunction.ToString: String;
var Param: Integer;
  Flag: TFuncFlag;
begin
  if ResultCount = 0 then
    Result := 'procedure'
  else
    Result := 'function';
  Result := Result + ' ' + Name;
  if ParamCount > 0 then
  begin
    Result := Result + '(';
    for Param := 0 to ParamCount-1 do
    begin
      if Param <> 0 then
        Result := Result + '; ';
      Result := Result + Params[Param].ToString;
    end;
    Result := Result + ')';
  end;
  if ResultCount <> 0 then
  begin
    for Param := ParamCount to ParamCount + ResultCount-1 do
    begin
      if Param > ParamCount then
        Result := Result + ';';
      Result := Result + Params[Param].ToString;
    end;
  end;

  Result := Result + ';';
  case CallingConvention of
    ccUnknown: Result := Result + ' UNKNOWN!!';
    ccIntrinsic: Result := Result + ' (Intrinsic)';
    ccCall, ccRST: Result := Result + GetCallInstruction + ';';
    ccStack: Result := Result + ' Stack;';
    ccRegister: Result := Result + ' Register;';
  else
    raise Exception.Create('Unknown calling convention');
  end;

  for Flag in Flags do
  case Flag of
    ffForward: Result := Result + ' Forward (Unresolved!);';
    ffOverloaded: Result := Result + ' Overloaded;';
  else
    raise Exception.Create('Unknown function flag');
  end;
end;

procedure FunctionsToStrings(S: TStrings);
var Func: PFunction;
  NameSpace: String;
begin
  NameSpace := '';
  S.Clear;
  for Func in FuncList do
  begin
    if Func.NameSpace <> NameSpace then
    begin
      NameSpace := Func.NameSpace;
      S.Add('NameSpace: ' + NameSpace);
    end;
    S.Add(Func.ToString);
  end;
end;

initialization
  FuncList := nil;
finalization
end.
