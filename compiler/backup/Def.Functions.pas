(* Function Data

Paramater passing

Calling Conventions: REGISTER, CALL, RST

|-----------|-----------------------------|
|  Access   | Data Type (of Parameter)    |
| Specifier | Register    | Pointered     |
|-----------|-------------|---------------|
| (value)   | Value       | Ref (copy)[1] |
|-----------|-------------|---------------|
| VAR       | Value       | Ref           |
|-----------|-------------|---------------|
| CONST     | Value       | Ref           |
|-----------|-------------|---------------|
| OUT       | Value       | Ref[2]        |
|-----------|-------------|---------------|
| Result    | Value       | Ref[2]        |
|-----------|-------------|---------------|
[1] - Hidden copy performed by caller into callees static variables
[2] - Reference passed in by caller in registers

Calling Conventions: STACK

|-----------|-----------------------------|
|  Access   | Data Type (of Parameter)    |
| Specifier | Register    | Pointered     |
|-----------|-------------|---------------|
| (value)   | Value       | Ref (copy)[3] |
|-----------|-------------|---------------|
| VAR       | Ref         | Ref           |
|-----------|-------------|---------------|
| CONST     | Value       | Ref           |
|-----------|-------------|---------------|
| OUT       | Ref         | Ref[4]        |
|-----------|-------------|---------------|
| Result    | Value[5]    | Ref[4]        |
|-----------|-------------|---------------|
[3] - Hidden copy performed by caller into stack space. (Note limits on stack frame size).
[4] - References passed in by caller on stack
[5] - Value returned in a register

*)

unit Def.Functions;

interface
uses Classes, Generics.Collections,
  Def.Operators, Def.VarTypes, Def.Consts, Def.Variables, Def.UserTypes,
  Z80.Hardware;

//Maximum number of parameters which can be specified for a routine, including results
const MaxFunctionParams = 10;

type
  TFuncFlag = (
    ffForward,    //This is a forward declaration
    ffOverloaded  //Overloaded if multiple functions with the same name, but different parameters
                  //(Currently no plans to support overloading)
     );
  TFuncFlagSet = set of TFuncFlag;

  TCallingConvention = (
    ccUnknown,    //I.e. not yet assigned/parser error
    ccIntrinsic,  //No call needed! Generated by code generator
                  //Not available for user defined functions
    ccStack,      //Both parameters and variables allocated to an IX based stack frame
    ccRegister,   //Parameters allocated to registers (if possible), otherwise
                  //spilled to static (global) variables
    ccCall,       //A call to external code (at fixed address), otherwise as Register
    ccRST         //As ccCode but for reoutines dispatched via Z80 RST instructions
    );

//This probably ought to be a compiler option. TODO
const
//  DefaultCallingConvention = ccStackFrame;
  DefaultExternCallingConvention = ccRegister;

type
  TParamAccess = (
    //Function parameters:
    paNone,   //No such parameter
    paVal,    //Original value is not modified
    paVar,    //Original value will be modified by the function
    paConst,  //Original value will not be modified by the function
    paOut,    //No value is passed in, a value will be returned
    paResult);  //Is a result

  //Flags for intrinsic parameters
  TIntrinsicFlag = (
    ifToType,       //If parameter is TypeDef will convert it the type in the TypeDef
    ifArrayAsBounds //If the parameter is an array type, and the result is parameterised
                    //then the ResultType will be the OfType of the array's BoundsType
    );
  TIntrinsicFlagSet = set of TIntrinsicFlag;

  PParameter = ^TParameter;
  TParameter = record
    Access: TParamAccess; //Ignored for Intrinsics
    IsByRef: Boolean;   //True if the parameter is passed by reference. The value
                        //will depend on the Access type, the Calling Convention
                        //and the type of the parameter (ie whether it is a Pointered Type)
    Name: String;

    Reg: TCPUReg;       //If the parameter is passed via a register, otherwise rNone
                          //Ignored for Intrinsics
    UserType: PUserType;   //Parameter type
    SuperType: TSuperType;  //Only for intrinsics. Only valid where VarType is vtUnknown.
    IntrinsicFlags: TIntrinsicFlagSet;  //Flags for Intrinsic params

    HasDefaultValue: Boolean;
    DefaultValue: TImmValue;   //If the parameter is optional.
                          //(only usable by Intrinsics at the moment)

    //Returns True if the param requires data to be passed the function (in registers)
    //when the function is called.
    //Val params require data to be passed in in registers for register types.
    //  For pointered types Val requires data to be copied into the functions local
    //  storage
    //VAR params require data to be passed in whether pass by value or pass by reference.
    //OUT and Result params will also require data to be passed in when being
    //passed by reference (ie. the pointer to the data).
    function PassDataIn: Boolean;
    //Returns True if the parameter requires a hidden copy of the arguments value
    //into the functions local storage. Used for Value arguments which are pointered types.
    function CopyDataIn: Boolean;
    //Returns True if the param requires data to be returned (in registers).
    //Params where data is return by reference require a pointer to be passed into
    //the function. The data is thus returned in memory at the referenced address
    //and no data is required to be returned by the function. Thus VAR, OUT and
    //Result params don't return any data when being passed by reference.
    function ReturnsData: Boolean;
    function ToString: String;
  end;

  TParamArray = array[0..MaxFunctionParams] of TParameter;

  //For functions or procedures
  PFunction = ^TFunction;
  TFunction = record
    NameSpace: String;      //I.e. current file
    Name: String;
    Flags: TFuncFlagSet;    //Meta data about the function

    Preserves: TCPURegSet;  //Registers which are prserved
//    InRegs: TUsedRegSet;    //Registers used for inputs (parameters)
//    OutRegs: TUsedRegSet;   //Registers used for outputs (parameters and return values)

    Overloaded: Boolean;    //Overloaded if multiple functions with the same name, but different parameters
    IsExtern: Boolean;      //True if this is an Extern definition (i.e to external code - O/S etc)
    CallingConvention: TCallingConvention;
    ParamCount: Integer;
    ResultCount: Integer;   //Result count of zero = Procedure

    Op: TOperator;          //If this is an intrinsic (otherwise OpUnknown)
    CodeAddress: Word;      //If implemented in machine code at fixed address

    Params: TParamArray;    //Parameter data

    Comments: String;       //Freeform help etc text

    //Search the parameters of Func, from parameter 0 to Parameter LastIndex for
    //one matching the given ParamName
    function FindParam(ParamName: String; LastIndex: Integer): PParameter;
    //Finds the (first) Result parameter.
    //If none is found raises an exception
    function FindResult: PParameter;

    //Returns variable storage (specified by the calling convention)
    function GetParamAddrMode: TAddrMode;
    function GetLocalAddrMode: TAddrMode;

    //Returns the assembly instruction to call this function.
    //(Could be a CALL or an RST, or something fancier).
    function GetCallInstruction: String;

    function ToString: String;
  end;

type TFuncList = TList<PFunction>;

function CreateFuncList: TFuncList;

procedure ClearFunclist(FuncList: TFuncList);

procedure SetCurrentFuncList(AFuncList: TFuncList);

//Find the given function
function FuncFindAllScopes(Name: String): PFunction;

function FuncFindInScope(Name: String): PFunction;

//Create a new function and return it
function FuncCreate(NameSpace, Name: String): PFunction;

type TFuncDirective = (
  dirUNKNOWN,
  dirFORWARD,
  dirCALL, dirRST,
  dirSTACK, dirREGISTER);

function IdentToFuncDirective(const Ident: String): TFuncDirective;

//Converts a string to an access specifier.
//If Ident is an access specifier returns True,
//if not returns False and Access returns paVal
function IdentToAccessSpecifier(const Ident: String;out Access: TParamAccess): Boolean;

//Returns True if a parameter under the given combination of calling convention,
//access specifier and type will be passed by reference, false otherwise
function IsPassByRef(CallingConvention: TCallingConvention; Access: TParamAccess;
  UserType: PUserType): Boolean;

function FunctionToFunctionHandle(Func: PFunction): TFunctionHandle;
function FunctionHandleToFunction(Handle: TFunctionHandle): PFunction;

procedure FunctionsToStrings(S: TStrings);


implementation
uses SysUtils,
  Def.Scopes;

var FuncList: TFuncList;

function CreateFuncList: TFuncList;
begin
  Result := TFuncList.Create;
end;

procedure ClearFunclist(FuncList: TFuncList);
var F: PFunction;
begin
  for F in FuncList do
    Dispose(F);

  FuncList.Clear;
end;

procedure SetCurrentFuncList(AFuncList: TFuncList);
begin
  FuncList := AFuncList;
end;

function FuncFindAllScopes(Name: String): PFunction;
var IdentData: TIdentData;
  Scope: PScope;
begin
  IdentData := SearchScopes(Name, Scope);
  if IdentData.IdentType = itFunction then
    EXIT(IdentData.F);

  Result := nil;
end;

function FuncFindInScope(Name: String): PFunction;
begin
  for Result in FuncList do
    if CompareText(Result.Name, Name) = 0 then
      EXIT;

  Result := nil;
end;

function FuncCreate(NameSpace, Name: String): PFunction;
var I: Integer;
begin
  New(Result);
  FuncList.Add(Result);
  Result.NameSpace := NameSpace;
  Result.Name := Name;
  Result.Flags := [];
  Result.Preserves := [];
//  Result.InRegs := [];
//  Result.OutRegs := [];
  Result.IsExtern := False;
  Result.CallingConvention := ccUnknown;
  Result.ParamCount := 0;
  Result.ResultCount := 0;
  Result.Op := OpUnknown;
  Result.CodeAddress := 0;

  for I := 0 to MaxFunctionParams do
  begin
    Result.Params[I].Name := '';
    Result.Params[I].Reg := rNone;
    Result.Params[I].UserType := nil;
//    Result.Params[I].VarTypes := [];
    Result.Params[I].Access := paNone;
    Result.Params[I].HasDefaultValue := False;
    Result.Params[I].IsByRef := False;
//    Result.Params[I].DefaultValue := 0;
  end;
end;

function IdentToFuncDirective(const Ident: String): TFuncDirective;
const DirectiveStrings: array[low(TFuncDirective)..high(TFuncDirective)] of String = (
  '',  //Placeholder for Unknown value
  'forward',
  'call','rst',
  'stack','register');
begin
  for Result := low(TFuncDirective) to high(TFuncDirective) do
    if CompareText(DirectiveStrings[Result], Ident) = 0 then
      EXIT;

  Result := dirUnknown;
end;

//The keywords used in function declarations. Used when parsing source and when
//reconstructing function definitions (for help etc).
const AccessStrings: array[low(TParamAccess)..high(TParamAccess)] of String = (
  '',   //None
  '',   //Val doesn't have a keyword
  'var',
  'const',
  'out',
  '');  //Result doesn't have a keyword

function IdentToAccessSpecifier(const Ident: String;out Access: TParamAccess): Boolean;
var VA: TParamAccess;
begin
  if Ident = 'var' then
    writeln('var - ',Ident);
  for VA := low(TParamAccess) to high(TParamAccess) do
    if CompareText(AccessStrings[VA], Ident) = 0 then
    begin
      Access := VA;
      {$ifdef fpc}
      if Ident = 'var' then
        writeln('IdentToAccess: ''',Ident,''' = ',Integer(VA));
      {$endif}
      EXIT(True);
    end;

  {$ifdef fpc}
  if Ident = 'var' then
    writeln('IdentToAccess (Unknown): ''',Ident,'''');
  {$endif}
  Access := paVal;
  Result := False;
end;

function IsPassByRef(CallingConvention: TCallingConvention; Access: TParamAccess;
  UserType: PUserType): Boolean;
begin
  case CallingConvention of
    ccRegister, ccCALL, ccRST:
      Result := IsPointeredType(UserType.VarType);
    ccStack:
      Result := IsPointeredType(UserType.VarType) or
        //For these two we need to pass in the data address even for non-pointered types
        (Access in [paVar, paOut]);
  else
    Assert(False);
  end;
end;

{ TParameter }

function TParameter.CopyDataIn: Boolean;
begin
  Result := IsByRef and (Access = paVal);
end;

function TParameter.PassDataIn: Boolean;
begin
  if IsByRef then
    Result := Access in [paVar, paConst, paOut, paResult]
  else
    Result := Access in [paVal, paVar, paConst];
end;

function TParameter.ReturnsData: Boolean;
begin
  Result := (Access in [paVar, paOut, paResult]) and not IsByRef;
end;

function TParameter.ToString: String;
begin
  Result := AccessStrings[Access];
  if Result <> '' then
    Result := Result + ' ';

  if Access <> paResult then
    Result := Result + Name;

  Result := Result + ': ';

  if Reg <> rNone then
  begin
    Result := Result + CPURegStrings[Reg];
    Result := Result + ' as ';
  end;

  if UserType <> nil then
    Result := Result + UserType.Description
  else
    Result := Result + SuperTypeToString(SuperType);

  if HasDefaultValue then
    Result := Result + ' = ' + DefaultValue.ToString;
end;

{ TFunction }

function TFunction.FindParam(ParamName: String; LastIndex: Integer): PParameter;
var I: Integer;
begin
  for I := 0 to LastIndex do
    if I > MaxFunctionParams then
      EXIT(nil)
    else if CompareText(Params[I].Name, ParamName) = 0 then
      EXIT(@Params[I]);

  Result := nil;
end;

function TFunction.FindResult: PParameter;
var I: Integer;
begin
  for I := 0 to Length(Params)-1 do
    if Params[I].Access = paResult then
      EXIT(@Params[I]);

  Result := nil;
  Assert(False, 'Function result not found');
end;

function TFunction.GetCallInstruction: String;
begin
  case CallingConvention of
    ccCall: Result := 'call $' + IntToHex(CodeAddress, 4);
    ccRST:
      if CodeAddress > 7 then
        Result := 'rst $' + IntToHex(CodeAddress, 2)
      else
        Result := 'rst ' + IntToStr(CodeAddress);
    ccRegister, ccStack:
      Result := 'call _' + Name
  else
    raise exception.Create('GetCallInstruction: Dispatch type not implemented yet');
  end;
end;

function TFunction.GetLocalAddrMode: TAddrMode;
begin
  case CallingConvention of
    ccRegister: Result := amStatic;
    ccStack: Result := amStack;
  else
    raise Exception.Create('Undefined Calling Convention');
  end;
end;

function TFunction.GetParamAddrMode: TAddrMode;
begin
  case CallingConvention of
    ccRegister:
      //Params are passed in registers. Storage will be alocated in global (static)
      //memory space but may (hopefully will) be optimised away into registers
      Result := amStatic;
    ccStack: Result := amStack;
  else
    raise Exception.Create('Undefined Calling Convention');
  end;
end;

function TFunction.ToString: String;
var Param: Integer;
  Flag: TFuncFlag;
begin
  if ResultCount = 0 then
    Result := 'procedure'
  else
    Result := 'function';
  Result := Result + ' ' + Name;
  if ParamCount > 0 then
  begin
    Result := Result + '(';
    for Param := 0 to ParamCount-1 do
    begin
      if Param <> 0 then
        Result := Result + '; ';
      Result := Result + Params[Param].ToString;
    end;
    Result := Result + ')';
  end;
  if ResultCount <> 0 then
  begin
    for Param := ParamCount to ParamCount + ResultCount-1 do
    begin
      if Param > ParamCount then
        Result := Result + ';';
      Result := Result + Params[Param].ToString;
    end;
  end;

  Result := Result + ';';
  case CallingConvention of
    ccUnknown: Result := Result + ' UNKNOWN!!';
    ccIntrinsic: Result := Result + ' (Intrinsic)';
    ccCall, ccRST: Result := Result + GetCallInstruction + ';';
    ccStack: Result := Result + ' Stack;';
    ccRegister: Result := Result + ' Register;';
  else
    raise Exception.Create('Unknown calling convention');
  end;

  for Flag in Flags do
  case Flag of
    ffForward: Result := Result + ' Forward (Unresolved!);';
    ffOverloaded: Result := Result + ' Overloaded;';
  else
    raise Exception.Create('Unknown function flag');
  end;
end;

procedure FunctionsToStrings(S: TStrings);
var Func: PFunction;
  NameSpace: String;
begin
  NameSpace := '';
  S.Clear;
  for Func in FuncList do
  begin
    if Func.NameSpace <> NameSpace then
    begin
      NameSpace := Func.NameSpace;
      S.Add('NameSpace: ' + NameSpace);
    end;
    S.Add(Func.ToString);
  end;
end;


function FunctionToFunctionHandle(Func: PFunction): TFunctionHandle;
begin
  Result := TFunctionHandle(Func);
end;

function FunctionHandleToFunction(Handle: TFunctionHandle): PFunction;
begin
  Result := PFunction(Handle);
end;

initialization
  FuncList := nil;
finalization
end.
