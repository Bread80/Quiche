unit Functions;

interface
uses QTypes, Classes, Generics.Collections, Variables, Operators;

//Maximum number of parameters which can be specified for a routine, including results
const MaxFunctionParams = 10;

type
  //To specify corrupted/preserved registers
  //Ideally wants to be 8 or less items so it fits into a byte
  TUsedReg = (urA, urFlags, urB, urC, urD, urE, urH, urL, urIX, urIY);
  TUsedRegSet = set of TUsedReg;

  //To specify registers etc used to pass parameters
  //CF = carry flag, ZF = zero flag
  TParamReg = (prNone, prA, prB, prC, prD, prE, prH, prL, prBC, prDE, prHL, prCF, prZF);
const ParamRegToVarType: array[low(TParamReg)..high(TParamReg)] of TVarType =
    (vtUnknown, vtByte, vtByte, vtByte, vtByte, vtByte, vtByte, vtByte,
    vtWord, vtWord, vtWord, vtBoolean, vtBoolean);

type
  TFuncFlag = (
    ffForward,    //This is a forward declaration
    ffOverloaded  //Overloaded if multiple functions with the same name, but different parameters
                  //(Currently no plans to support overloading)
     );
  TFuncFlagSet = set of TFuncFlag;

  TCallingConvention = (
    ccUnknown,    //I.e. not yet assigned/parser error
    ccStackLocal, //Both parameters and variables allocated to an IX based stack frame
    ccRegister,    //Parameters allocated to registers (if possible), otherwise
                  //spilled to IX based stack frame
    ccIntrinsic  //No call needed! Generated by code generator
                  //Not available for user defined functions
//    ccExtern      //A call to external code (at fixed address). Parameters allocated to fixed addresses
    );

//This probably ought to be a compiler option. TODO
const
//  DefaultCallingConvention = ccStackFrame;
  DefaultExternCallingConvention = ccRegister;

type
  PParameter = ^TParameter;
  TParameter = record
    Access: TVarAccess; //Ignored for Intrinsics
    Name: String;

    Reg: TParamReg;       //If the parameter is passed via a register, otherwise prNone
                          //Ignored for Intrinsics
    VarType: TVarType;    //Parameter type
    SuperType: TSuperType;  //Only for intrinsics. Only valid where VarType is vtUnknown.

    HasDefaultValue: Boolean;
    DefaultValue: TImmValue;   //If the parameter is optional.
                          //(only usable by Intrinsics at the moment)

    function ToString: String;
  end;

  TParamArray = array[0..MaxFunctionParams] of TParameter;

  //For functions or procedures
  PFunction = ^TFunction;
  TFunction = record
    NameSpace: String;      //I.e. current file
    Name: String;
    Flags: TFuncFlagSet;    //Meta data about the function

    Corrupts: TUsedRegSet;  //Registers which are corrupted (not including OutRegs)
//    InRegs: TUsedRegSet;    //Registers used for inputs (parameters)
//    OutRegs: TUsedRegSet;   //Registers used for outputs (parameters and return values)

    Overloaded: Boolean;    //Overloaded if multiple functions with the same name, but different parameters
    IsExtern: Boolean;      //True if this is an Extern definition (i.e to external code - O/S etc)
    CallingConvention: TCallingConvention;
    ParamCount: Integer;
    ResultCount: Integer;   //Result count of zero = Procedure

    Op: TOperator;          //If this is an intrinsic (otherwise OpUnknown)
    CodeAddress: Word;      //If implemented in machine code at fixed address

    Params: TParamArray;    //Parameter data

    Comments: String;       //Freeform help etc text

    //Search the parameters of Func, from parameter 0 to Parameter LastIndex for
    //one matching the given ParamName
    function FindParam(ParamName: String; LastIndex: Integer): PParameter;
    //Finds the (first) Result parameter.
    //If none is found raises an exception
    function FindResult: PParameter;

    //Returns variable storage (specified by the calling convention)
    function GetParamStorage: TVarStorage;
    function GetLocalStorage: TVarStorage;

    //Returns the assembly instruction to call this function.
    //(Could be a CALL or an RST, or something fancier).
    function GetCallInstruction: String;

    function ToString: String;
  end;

type TFuncList = TList<PFunction>;

function CreateFuncList: TFuncList;

procedure ClearFunclist(FuncList: TFuncList);

procedure SetCurrentFuncList(AFuncList: TFuncList);

function IdentToParamReg(Ident: String): TParamReg;

//Find the given function
function FuncFindAllScopes(Name: String): PFunction;

function FuncFindInScope(Name: String): PFunction;

//Create a new function and return it
function FuncCreate(NameSpace, Name: String): PFunction;

type TFuncDirective = (dirUNKNOWN,
  dirEXTERN, dirFORWARD, dirSTACKLOCAL, dirREGISTER);

function IdentToFuncDirective(const Ident: String): TFuncDirective;

//Converts a string to an access specifier.
//If Ident is an access specifier returns True,
//if not returns False and Access returns paVal
function IdentToAccessSpecifier(const Ident: String;out Access: TVarAccess): Boolean;


function FunctionsToStrings(S: TStrings): String;


implementation
uses SysUtils, Scopes;

const ParamRegStrings: array[low(TParamReg)..high(TParamReg)] of String = (
  '',  //Placeholder for Unknown value
  'A', 'B', 'C', 'D', 'E', 'H', 'L', 'BC', 'DE', 'HL', 'CF', 'ZF');

function IdentToParamReg(Ident: String): TParamReg;
begin
  for Result := low(TParamReg) to high(TParamReg) do
    if CompareText(ParamRegStrings[Result], Ident) = 0 then
      EXIT;

  Result := prNone;
end;

var FuncList: TFuncList;

function CreateFuncList: TFuncList;
begin
  Result := TFuncList.Create;
end;

procedure ClearFunclist(FuncList: TFuncList);
var F: PFunction;
begin
  for F in FuncList do
    Dispose(F);

  FuncList.Clear;
end;

procedure SetCurrentFuncList(AFuncList: TFuncList);
begin
  FuncList := AFuncList;
end;

function FuncFindAllScopes(Name: String): PFunction;
var IdentType: TIdentType;
  Scope: PScope;
  Item: Pointer;
begin
  Item := SearchScopes(Name,IdentType,Scope);
  if Assigned(Item) then
    if IdentType = itFunction then
      EXIT(PFunction(Item));

  Result := nil;
end;

function FuncFindInScope(Name: String): PFunction;
begin
  for Result in FuncList do
    if CompareText(Result.Name, Name) = 0 then
      EXIT;

  Result := nil;
end;

function FuncCreate(NameSpace, Name: STring): PFunction;
var I: Integer;
begin
  New(Result);
  FuncList.Add(Result);
  Result.NameSpace := NameSpace;
  Result.Name := Name;
  Result.Flags := [];
  Result.Corrupts := [];
//  Result.InRegs := [];
//  Result.OutRegs := [];
  Result.IsExtern := False;
  Result.CallingConvention := ccUnknown;
  Result.ParamCount := 0;
  Result.ResultCount := 0;
  Result.Op := OpUnknown;
  Result.CodeAddress := 0;

  for I := 0 to MaxFunctionParams do
  begin
    Result.Params[I].Name := '';
    Result.Params[I].Reg := prNone;
    Result.Params[I].VarType := vtUnknown;
//    Result.Params[I].VarTypes := [];
    Result.Params[I].Access := vaVal;
    Result.Params[I].HasDefaultValue := False;
//    Result.Params[I].DefaultValue := 0;
  end;
end;

function IdentToFuncDirective(const Ident: String): TFuncDirective;
const DirectiveStrings: array[low(TFuncDirective)..high(TFuncDirective)] of String = (
  '',  //Placeholder for Unknown value
  'extern','forward','stacklocal','register');
begin
  for Result := low(TFuncDirective) to high(TFuncDirective) do
    if CompareText(DirectiveStrings[Result], Ident) = 0 then
      EXIT;

  Result := dirUnknown;
end;

function IdentToAccessSpecifier(const Ident: String;out Access: TVarAccess): Boolean;
const AccessStrings: array[low(TVarAccess)..high(TVarAccess)] of String = (
  '',   //Local variables don't have a keyword
  '',   //Val doesn't have a keyword
  'var', 'const', {'in',} 'out',
  '');  //Result doesn't have a keyword
var VA: TVarAccess;
begin
  for VA := low(TVarAccess) to high(TVarAccess) do
    if CompareText(AccessStrings[VA], Ident) = 0 then
    begin
      Access := VA;
      EXIT(True);
    end;

  Access := vaVal;
  Result := False;
end;

{ TParameter }

function TParameter.ToString: String;
//var VT: TTypeEnum;
begin
  case Access of
    vaVal, vaResult: Result := '';
    vaVar: Result := 'var ';
    vaConst: Result := 'const ';
    vaOut: Result := 'out ';
  else
    raise Exception.Create('Unknown param specifier in param');
  end;

  if Access <> vaResult then
    Result := Result + Name;

  Result := Result + ': ';

  if Reg <> prNone then
  begin
    Result := Result + ParamRegStrings[Reg];
    Result := Result + ' as ';
  end;

  if VarType <> vtUnknown then
    Result := Result + VarTypeToName(VarType)
  else
    Result := Result + SuperTypeToString(SuperType);

  if HasDefaultValue then
    Result := Result + ' = ' + DefaultValue.ToString;
end;

{ TFunction }

function TFunction.FindParam(ParamName: String; LastIndex: Integer): PParameter;
var I: Integer;
begin
  for I := 0 to LastIndex do
    if I > MaxFunctionParams then
      EXIT(nil)
    else if CompareText(Params[I].Name, ParamName) = 0 then
      EXIT(@Params[I]);

  Result := nil;
end;

function TFunction.FindResult: PParameter;
var I: Integer;
begin
  for I := 0 to Length(Params)-1 do
    if Params[I].Access = vaResult then
      EXIT(@Params[I]);

  Assert(False, 'Function result not found');
end;

function TFunction.GetCallInstruction: String;
begin
  if IsExtern then
    Result := 'call $' + IntToHex(CodeAddress, 4)
  else if CallingConvention in [ccRegister, ccStackLocal] then
    Result := 'call _' + Name
  else
    raise exception.Create('GetCallInstruction: Dispatch type not implemented yet');
end;

function TFunction.GetLocalStorage: TVarStorage;
begin
  case CallingConvention of
{    ccRegister: ;No parameter storage!
    begin
      LocalStorage := vsAbsolute;
    end;
}    ccStackLocal: Result := vsStack;
  else
    Assert(False);
  end;
end;

function TFunction.GetParamStorage: TVarStorage;
begin
  case CallingConvention of
{    ccRegister: ;No parameter storage!
    begin
      LocalStorage := vsAbsolute;
    end;
}    ccStackLocal: Result := vsStack;
  else
    Assert(False);
  end;
end;

function TFunction.ToString: String;
var Param: Integer;
  Flag: TFuncFlag;
begin
  if ResultCount = 0 then
    Result := 'procedure'
  else
    Result := 'function';
  Result := Result + ' ' + Name;
  if ParamCount > 0 then
  begin
    Result := Result + '(';
    for Param := 0 to ParamCount-1 do
    begin
      if Param <> 0 then
        Result := Result + '; ';
      Result := Result + Params[Param].ToString;
    end;
    Result := Result + ')';
  end;
  if ResultCount <> 0 then
  begin
    for Param := ParamCount to ParamCount + ResultCount-1 do
    begin
      if Param > ParamCount then
        Result := Result + ';';
      Result := Result + Params[Param].ToString;
    end;
  end;

  Result := Result + ';';
  case CallingConvention of
    ccUnknown: Result := Result + ' UNKNOWN!!';
    ccIntrinsic: Result := Result + ' (Intrinsic)';
    ccStackLocal: Result := Result + ' StackLocal;';
    ccRegister: Result := Result + ' Register;';
  else
    raise Exception.Create('Unknown calling convention');
  end;
  if IsExtern then
    Result := Result + ' extern $' + IntToHex(CodeAddress) +';';

  for Flag in Flags do
  case Flag of
    ffForward: Result := Result + ' Forward (Unresolved!);';
    ffOverloaded: Result := Result + ' Overloaded;';
  else
    raise Exception.Create('Unknown function flag');
  end;

{  if not Func.IsExtern then
    Result := Result + ' $' + IntToHex(Func.CodeAddress,4) +';';
}end;

function FunctionsToStrings(S: TStrings): String;
var Func: PFunction;
  NameSpace: String;
begin
  NameSpace := '';
  S.Clear;
  for Func in FuncList do
  begin
    if Func.NameSpace <> NameSpace then
    begin
      NameSpace := Func.NameSpace;
      S.Add('NameSpace: ' + NameSpace);
    end;
    S.Add(Func.ToString);
  end;
end;

initialization
  FuncList := nil;
finalization
end.
